'use strict';

var ethers = require('ethers');
var nodeTfhe = require('node-tfhe');
var bigintBuffer = require('bigint-buffer');
var createHash = require('keccak');
var nodeTkms = require('node-tkms');
var fetchRetry = require('fetch-retry');

const SERIALIZED_SIZE_LIMIT_CIPHERTEXT = BigInt(1024 * 1024 * 512);
const SERIALIZED_SIZE_LIMIT_PK = BigInt(1024 * 1024 * 512);
const SERIALIZED_SIZE_LIMIT_CRS = BigInt(1024 * 1024 * 512);
const cleanURL = (url) => {
    if (!url)
        return '';
    return new URL(url).href;
};
const numberToHex = (num) => {
    let hex = num.toString(16);
    return hex.length % 2 ? '0' + hex : hex;
};
const fromHexString = (hexString) => {
    const arr = hexString.replace(/^(0x)/, '').match(/.{1,2}/g);
    if (!arr)
        return new Uint8Array();
    return Uint8Array.from(arr.map((byte) => parseInt(byte, 16)));
};
const toHexString = (bytes) => bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');
const bytesToBigInt = function (byteArray) {
    if (!byteArray || byteArray?.length === 0) {
        return BigInt(0);
    }
    const buffer = Buffer.from(byteArray);
    const result = bigintBuffer.toBigIntBE(buffer);
    return result;
};
const clientKeyDecryptor = (clientKeySer) => {
    const clientKey = nodeTfhe.TfheClientKey.deserialize(clientKeySer);
    return {
        decryptBool: (ciphertext) => nodeTfhe.FheBool.safe_deserialize(fromHexString(ciphertext), SERIALIZED_SIZE_LIMIT_CIPHERTEXT).decrypt(clientKey),
        decrypt4: (ciphertext) => nodeTfhe.FheUint4.safe_deserialize(fromHexString(ciphertext), SERIALIZED_SIZE_LIMIT_CIPHERTEXT).decrypt(clientKey),
        decrypt8: (ciphertext) => nodeTfhe.FheUint8.safe_deserialize(fromHexString(ciphertext), SERIALIZED_SIZE_LIMIT_CIPHERTEXT).decrypt(clientKey),
        decrypt16: (ciphertext) => nodeTfhe.FheUint16.safe_deserialize(fromHexString(ciphertext), SERIALIZED_SIZE_LIMIT_CIPHERTEXT).decrypt(clientKey),
        decrypt32: (ciphertext) => nodeTfhe.FheUint32.safe_deserialize(fromHexString(ciphertext), SERIALIZED_SIZE_LIMIT_CIPHERTEXT).decrypt(clientKey),
        decrypt64: (ciphertext) => nodeTfhe.FheUint64.safe_deserialize(fromHexString(ciphertext), SERIALIZED_SIZE_LIMIT_CIPHERTEXT).decrypt(clientKey),
        decrypt128: (ciphertext) => nodeTfhe.FheUint128.safe_deserialize(fromHexString(ciphertext), SERIALIZED_SIZE_LIMIT_CIPHERTEXT).decrypt(clientKey),
        decryptAddress: (ciphertext) => {
            let hex = nodeTfhe.FheUint160.safe_deserialize(fromHexString(ciphertext), SERIALIZED_SIZE_LIMIT_CIPHERTEXT)
                .decrypt(clientKey)
                .toString(16);
            while (hex.length < 40) {
                hex = '0' + hex;
            }
            return '0x' + hex;
        },
        decrypt256: (ciphertext) => nodeTfhe.FheUint256.safe_deserialize(fromHexString(ciphertext), SERIALIZED_SIZE_LIMIT_CIPHERTEXT).decrypt(clientKey),
        decryptEbytes64: (ciphertext) => nodeTfhe.FheUint512.safe_deserialize(fromHexString(ciphertext), SERIALIZED_SIZE_LIMIT_CIPHERTEXT).decrypt(clientKey),
        decryptEbytes128: (ciphertext) => nodeTfhe.FheUint1024.safe_deserialize(fromHexString(ciphertext), SERIALIZED_SIZE_LIMIT_CIPHERTEXT).decrypt(clientKey),
        decryptEbytes256: (ciphertext) => nodeTfhe.FheUint2048.safe_deserialize(fromHexString(ciphertext), SERIALIZED_SIZE_LIMIT_CIPHERTEXT).decrypt(clientKey),
    };
};
const getCiphertextCallParams = (handle) => {
    let hex = handle.toString(16);
    hex = hex.padStart(64, '0');
    return {
        to: '0x000000000000000000000000000000000000005d',
        data: '0xff627e77' + hex,
    };
};

const keyurlCache = {};
const getKeysFromRelayer = async (url, publicKeyId) => {
    if (keyurlCache[url]) {
        return keyurlCache[url];
    }
    try {
        const response = await fetch(`${url}keyurl`);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        if (data) {
            let pubKeyUrl;
            // If no publicKeyId is provided, use the first one
            // Warning: if there are multiple keys available, the first one will most likely never be the
            // same between several calls (fetching the infos is non-deterministic)
            if (!publicKeyId) {
                pubKeyUrl = data.response.fhe_key_info[0].fhe_public_key.urls[0];
                publicKeyId = data.response.fhe_key_info[0].fhe_public_key.data_id;
            }
            else {
                // If a publicKeyId is provided, get the corresponding info
                const keyInfo = data.response.fhe_key_info.find((info) => info.fhe_public_key.data_id === publicKeyId);
                if (!keyInfo) {
                    throw new Error(`Could not find FHE key info with data_id ${publicKeyId}`);
                }
                // TODO: Get a given party's public key url instead of the first one
                pubKeyUrl = keyInfo.fhe_public_key.urls[0];
            }
            const publicKeyResponse = await fetch(pubKeyUrl);
            if (!publicKeyResponse.ok) {
                throw new Error(`HTTP error! status: ${publicKeyResponse.status} on ${publicKeyResponse.url}`);
            }
            const publicKey = await publicKeyResponse.bytes();
            const publicParamsUrl = data.response.crs['2048'].urls[0];
            const publicParamsId = data.response.crs['2048'].data_id;
            const publicParams2048Response = await fetch(publicParamsUrl);
            if (!publicParams2048Response.ok) {
                throw new Error(`HTTP error! status: ${publicParams2048Response.status} on ${publicParams2048Response.url}`);
            }
            const publicParams2048 = await publicParams2048Response.bytes();
            let pub_key;
            try {
                pub_key = nodeTfhe.TfheCompactPublicKey.safe_deserialize(publicKey, SERIALIZED_SIZE_LIMIT_PK);
            }
            catch (e) {
                throw new Error('Invalid public key (deserialization failed)', {
                    cause: e,
                });
            }
            let crs;
            try {
                crs = nodeTfhe.CompactPkeCrs.safe_deserialize(new Uint8Array(publicParams2048), SERIALIZED_SIZE_LIMIT_CRS);
            }
            catch (e) {
                throw new Error('Invalid crs (deserialization failed)', {
                    cause: e,
                });
            }
            const result = {
                publicKey: pub_key,
                publicKeyId,
                publicParams: {
                    2048: {
                        publicParams: crs,
                        publicParamsId,
                    },
                },
            };
            keyurlCache[url] = result;
            return result;
        }
        else {
            throw new Error('No public key available');
        }
    }
    catch (e) {
        throw new Error('Impossible to fetch public key: wrong relayer url.', {
            cause: e,
        });
    }
};

var abi = [
	{
		inputs: [
		],
		stateMutability: "nonpayable",
		type: "constructor"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "target",
				type: "address"
			}
		],
		name: "AddressEmptyCode",
		type: "error"
	},
	{
		inputs: [
		],
		name: "ECDSAInvalidSignature",
		type: "error"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "length",
				type: "uint256"
			}
		],
		name: "ECDSAInvalidSignatureLength",
		type: "error"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "s",
				type: "bytes32"
			}
		],
		name: "ECDSAInvalidSignatureS",
		type: "error"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "implementation",
				type: "address"
			}
		],
		name: "ERC1967InvalidImplementation",
		type: "error"
	},
	{
		inputs: [
		],
		name: "ERC1967NonPayable",
		type: "error"
	},
	{
		inputs: [
		],
		name: "FailedInnerCall",
		type: "error"
	},
	{
		inputs: [
		],
		name: "InvalidInitialization",
		type: "error"
	},
	{
		inputs: [
		],
		name: "NotInitializing",
		type: "error"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "owner",
				type: "address"
			}
		],
		name: "OwnableInvalidOwner",
		type: "error"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "OwnableUnauthorizedAccount",
		type: "error"
	},
	{
		inputs: [
		],
		name: "UUPSUnauthorizedCallContext",
		type: "error"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "slot",
				type: "bytes32"
			}
		],
		name: "UUPSUnsupportedProxiableUUID",
		type: "error"
	},
	{
		anonymous: false,
		inputs: [
		],
		name: "EIP712DomainChanged",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "uint64",
				name: "version",
				type: "uint64"
			}
		],
		name: "Initialized",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "previousOwner",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "newOwner",
				type: "address"
			}
		],
		name: "OwnershipTransferStarted",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "previousOwner",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "newOwner",
				type: "address"
			}
		],
		name: "OwnershipTransferred",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "signer",
				type: "address"
			}
		],
		name: "SignerAdded",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "signer",
				type: "address"
			}
		],
		name: "SignerRemoved",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "implementation",
				type: "address"
			}
		],
		name: "Upgraded",
		type: "event"
	},
	{
		inputs: [
		],
		name: "UPGRADE_INTERFACE_VERSION",
		outputs: [
			{
				internalType: "string",
				name: "",
				type: "string"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "acceptOwnership",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "signer",
				type: "address"
			}
		],
		name: "addSigner",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
		],
		name: "eip712Domain",
		outputs: [
			{
				internalType: "bytes1",
				name: "fields",
				type: "bytes1"
			},
			{
				internalType: "string",
				name: "name",
				type: "string"
			},
			{
				internalType: "string",
				name: "version",
				type: "string"
			},
			{
				internalType: "uint256",
				name: "chainId",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "verifyingContract",
				type: "address"
			},
			{
				internalType: "bytes32",
				name: "salt",
				type: "bytes32"
			},
			{
				internalType: "uint256[]",
				name: "extensions",
				type: "uint256[]"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "getSigners",
		outputs: [
			{
				internalType: "address[]",
				name: "",
				type: "address[]"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "getThreshold",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "getVersion",
		outputs: [
			{
				internalType: "string",
				name: "",
				type: "string"
			}
		],
		stateMutability: "pure",
		type: "function"
	},
	{
		inputs: [
		],
		name: "get_DECRYPTIONRESULT_TYPE",
		outputs: [
			{
				internalType: "string",
				name: "",
				type: "string"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "initialOwner",
				type: "address"
			}
		],
		name: "initialize",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "isSigner",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
		],
		name: "owner",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "pendingOwner",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "proxiableUUID",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "signer",
				type: "address"
			}
		],
		name: "removeSigner",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
		],
		name: "renounceOwnership",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "newOwner",
				type: "address"
			}
		],
		name: "transferOwnership",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "newImplementation",
				type: "address"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			}
		],
		name: "upgradeToAndCall",
		outputs: [
		],
		stateMutability: "payable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "aclAddress",
				type: "address"
			},
			{
				internalType: "uint256[]",
				name: "handlesList",
				type: "uint256[]"
			},
			{
				internalType: "bytes",
				name: "decryptedResult",
				type: "bytes"
			},
			{
				internalType: "bytes[]",
				name: "signatures",
				type: "bytes[]"
			}
		],
		name: "verifySignatures",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "nonpayable",
		type: "function"
	}
];

const getProvider = (config) => {
    if (typeof config.network === 'string') {
        return new ethers.JsonRpcProvider(config.network);
    }
    else if (config.network) {
        return new ethers.BrowserProvider(config.network);
    }
    throw new Error('You must provide a network URL or a EIP1193 object (eg: window.ethereum)');
};
const getChainId = async (provider, config) => {
    if (config.chainId && typeof config.chainId === 'number') {
        return config.chainId;
    }
    else if (config.chainId && typeof config.chainId !== 'number') {
        throw new Error('chainId must be a number.');
    }
    else {
        const chainId = (await provider.getNetwork()).chainId;
        return Number(chainId);
    }
};
const getTfheCompactPublicKey = async (config) => {
    if (config.relayerUrl && !config.publicKey) {
        const inputs = await getKeysFromRelayer(cleanURL(config.relayerUrl));
        return { publicKey: inputs.publicKey, publicKeyId: inputs.publicKeyId };
    }
    else if (config.publicKey && config.publicKey.data && config.publicKey.id) {
        const buff = config.publicKey.data;
        try {
            return {
                publicKey: nodeTfhe.TfheCompactPublicKey.safe_deserialize(buff, SERIALIZED_SIZE_LIMIT_PK),
                publicKeyId: config.publicKey.id,
            };
        }
        catch (e) {
            throw new Error('Invalid public key (deserialization failed)', {
                cause: e,
            });
        }
    }
    else {
        throw new Error('You must provide a public key with its public key ID.');
    }
};
const getPublicParams = async (config) => {
    if (config.relayerUrl && !config.publicParams) {
        const inputs = await getKeysFromRelayer(cleanURL(config.relayerUrl));
        return inputs.publicParams;
    }
    else if (config.publicParams && config.publicParams['2048']) {
        const buff = config.publicParams['2048'].publicParams;
        try {
            return {
                2048: {
                    publicParams: nodeTfhe.CompactPkeCrs.safe_deserialize(buff, SERIALIZED_SIZE_LIMIT_CRS),
                    publicParamsId: config.publicParams['2048'].publicParamsId,
                },
            };
        }
        catch (e) {
            throw new Error('Invalid public key (deserialization failed)', {
                cause: e,
            });
        }
    }
    else {
        throw new Error('You must provide a valid CRS with its CRS ID.');
    }
};
const getKMSSigners = async (provider, config) => {
    const kmsContract = new ethers.Contract(config.kmsContractAddress, abi, provider);
    const signers = await kmsContract.getSigners();
    return signers;
};

const ENCRYPTION_TYPES = {
    1: 0, // ebool takes 2 encrypted bits
    4: 1,
    8: 2,
    16: 3,
    32: 4,
    64: 5,
    128: 6,
    160: 7,
    256: 8,
    512: 9,
    1024: 10,
    2048: 11,
};

const compute_handles = (ciphertextWithZKProof, bitwidths, aclContractAddress, chainId, ciphertextVersion) => {
    // Should be identical to:
    // https://github.com/zama-ai/fhevm-backend/blob/bae00d1b0feafb63286e94acdc58dc88d9c481bf/fhevm-engine/zkproof-worker/src/verifier.rs#L301
    const blob_hash = createHash('keccak256')
        .update(Buffer.from(ciphertextWithZKProof))
        .digest();
    const aclContractAddress20Bytes = Buffer.from(fromHexString(aclContractAddress));
    const chainId32Bytes = Buffer.from(new Uint8Array(bigintBuffer.toBufferBE(BigInt(chainId), 32)));
    const handles = bitwidths.map((bitwidth, encryptionIndex) => {
        const encryptionType = ENCRYPTION_TYPES[bitwidth];
        const encryptionIndex1Byte = Buffer.from([encryptionIndex]);
        const handleHash = createHash('keccak256')
            .update(blob_hash)
            .update(encryptionIndex1Byte)
            .update(aclContractAddress20Bytes)
            .update(chainId32Bytes)
            .digest();
        const dataInput = new Uint8Array(32);
        dataInput.set(handleHash, 0);
        dataInput.set([encryptionIndex, encryptionType, ciphertextVersion], 29);
        return dataInput;
    });
    return handles;
};

const currentCiphertextVersion = () => {
    return 0;
};
const checkEncryptedValue = (value, bits) => {
    if (value == null)
        throw new Error('Missing value');
    let limit;
    if (bits >= 8) {
        limit = BigInt(`0x${new Array(bits / 8).fill(null).reduce((v) => `${v}ff`, '')}`);
    }
    else {
        limit = BigInt(2 ** bits - 1);
    }
    if (typeof value !== 'number' && typeof value !== 'bigint')
        throw new Error('Value must be a number or a bigint.');
    if (value > limit) {
        throw new Error(`The value exceeds the limit for ${bits}bits integer (${limit.toString()}).`);
    }
};
const createEncryptedInput = (aclContractAddress, chainId, relayer_url, tfheCompactPublicKey, publicParams) => (contractAddress, userAddress) => {
    if (!ethers.isAddress(contractAddress)) {
        throw new Error('Contract address is not a valid address.');
    }
    if (!ethers.isAddress(userAddress)) {
        throw new Error('User address is not a valid address.');
    }
    const publicKey = tfheCompactPublicKey;
    const bits = [];
    const builder = nodeTfhe.CompactCiphertextList.builder(publicKey);
    let ciphertextWithZKProof = new Uint8Array(); // updated in `_prove`
    let nbCiphertextWithZKProof = 0; // use to invalidate ciphertextWithZKProof, e.g. add is called between 2 `encrypt`
    const checkLimit = (added) => {
        if (bits.reduce((acc, val) => acc + Math.max(2, val), 0) + added > 2048) {
            throw Error('Packing more than 2048 bits in a single input ciphertext is unsupported');
        }
        if (bits.length + 1 > 256)
            throw Error('Packing more than 256 variables in a single input ciphertext is unsupported');
    };
    relayer_url =
        relayer_url.slice(-1) == '/' ? relayer_url.slice(0, -1) : relayer_url;
    return {
        addBool(value) {
            if (value == null)
                throw new Error('Missing value');
            if (typeof value !== 'boolean' &&
                typeof value !== 'number' &&
                typeof value !== 'bigint')
                throw new Error('The value must be a boolean, a number or a bigint.');
            if ((typeof value !== 'bigint' || typeof value !== 'number') &&
                Number(value) > 1)
                throw new Error('The value must be 1 or 0.');
            checkEncryptedValue(Number(value), 1);
            checkLimit(2);
            builder.push_boolean(!!value);
            bits.push(1); // ebool takes 2 encrypted bits
            return this;
        },
        add4(value) {
            checkEncryptedValue(value, 4);
            checkLimit(4);
            builder.push_u4(Number(value));
            bits.push(4);
            return this;
        },
        add8(value) {
            checkEncryptedValue(value, 8);
            checkLimit(8);
            builder.push_u8(Number(value));
            bits.push(8);
            return this;
        },
        add16(value) {
            checkEncryptedValue(value, 16);
            checkLimit(16);
            builder.push_u16(Number(value));
            bits.push(16);
            return this;
        },
        add32(value) {
            checkEncryptedValue(value, 32);
            checkLimit(32);
            builder.push_u32(Number(value));
            bits.push(32);
            return this;
        },
        add64(value) {
            checkEncryptedValue(value, 64);
            checkLimit(64);
            builder.push_u64(BigInt(value));
            bits.push(64);
            return this;
        },
        add128(value) {
            checkEncryptedValue(value, 128);
            checkLimit(128);
            builder.push_u128(BigInt(value));
            bits.push(128);
            return this;
        },
        addAddress(value) {
            if (!ethers.isAddress(value)) {
                throw new Error('The value must be a valid address.');
            }
            checkLimit(160);
            builder.push_u160(BigInt(value));
            bits.push(160);
            return this;
        },
        add256(value) {
            checkEncryptedValue(value, 256);
            checkLimit(256);
            builder.push_u256(BigInt(value));
            bits.push(256);
            return this;
        },
        addBytes64(value) {
            if (value.length !== 64)
                throw Error('Uncorrect length of input Uint8Array, should be 64 for an ebytes64');
            const bigIntValue = bytesToBigInt(value);
            checkEncryptedValue(bigIntValue, 512);
            checkLimit(512);
            builder.push_u512(bigIntValue);
            bits.push(512);
            return this;
        },
        addBytes128(value) {
            if (value.length !== 128)
                throw Error('Uncorrect length of input Uint8Array, should be 128 for an ebytes128');
            const bigIntValue = bytesToBigInt(value);
            checkEncryptedValue(bigIntValue, 1024);
            checkLimit(1024);
            builder.push_u1024(bigIntValue);
            bits.push(1024);
            return this;
        },
        addBytes256(value) {
            if (value.length !== 256)
                throw Error('Uncorrect length of input Uint8Array, should be 256 for an ebytes256');
            const bigIntValue = bytesToBigInt(value);
            checkEncryptedValue(bigIntValue, 2048);
            checkLimit(2048);
            builder.push_u2048(bigIntValue);
            bits.push(2048);
            return this;
        },
        getBits() {
            return bits;
        },
        _getClosestPP() {
            const getKeys = (obj) => Object.keys(obj);
            const totalBits = bits.reduce((total, v) => total + v, 0);
            const ppTypes = getKeys(publicParams);
            const closestPP = ppTypes.find((k) => Number(k) >= totalBits);
            if (!closestPP) {
                throw new Error(`Too many bits in provided values. Maximum is ${ppTypes[ppTypes.length - 1]}.`);
            }
            return closestPP;
        },
        _prove() {
            // _prove is cached, also used for function `handles`
            if (ciphertextWithZKProof.length > 0 &&
                nbCiphertextWithZKProof == bits.length) {
                return ciphertextWithZKProof;
            }
            const closestPP = this._getClosestPP();
            const pp = publicParams[closestPP].publicParams;
            const buffContract = fromHexString(contractAddress);
            const buffUser = fromHexString(userAddress);
            const buffAcl = fromHexString(aclContractAddress);
            const buffChainId = fromHexString(chainId.toString(16));
            const auxData = new Uint8Array(buffContract.length + buffUser.length + buffAcl.length + 32);
            auxData.set(buffContract, 0);
            auxData.set(buffUser, 20);
            auxData.set(buffAcl, 40);
            auxData.set(buffChainId, auxData.length - buffChainId.length);
            const encrypted = builder.build_with_proof_packed(pp, auxData, nodeTfhe.ZkComputeLoad.Verify);
            ciphertextWithZKProof = encrypted.safe_serialize(SERIALIZED_SIZE_LIMIT_CIPHERTEXT);
            nbCiphertextWithZKProof = bits.length;
            return ciphertextWithZKProof;
        },
        async _verify(ciphertext) {
            // https://github.com/zama-ai/fhevm-relayer/blob/978b08f62de060a9b50d2c6cc19fd71b5fb8d873/src/input_http_listener.rs#L13C1-L22C1
            const payload = {
                contractAddress: ethers.getAddress(contractAddress),
                userAddress: ethers.getAddress(userAddress),
                ciphertextWithZkpok: Buffer.from(ciphertext).toString('hex'),
                contractChainId: '0x' + chainId.toString(16),
            };
            const options = {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(payload),
            };
            const url = `${relayer_url}/input-proof`;
            let json;
            try {
                const response = await fetch(url, options);
                if (!response.ok) {
                    throw new Error(`Httpz-relayer didn't response correctly. Bad status ${response.statusText}. Content: ${await response.text()}`);
                }
                try {
                    json = await response.json();
                }
                catch (e) {
                    throw new Error("Httpz-relayer didn't response correctly. Bad JSON.", { cause: e });
                }
            }
            catch (e) {
                throw new Error("Httpz-relayer didn't response correctly.", {
                    cause: e,
                });
            }
            const handles = this._handles();
            // Note that the hex strings returned by the relayer do have have the 0x prefix
            if (json.response.handles && json.response.handles.length > 0) {
                const response_handles = json.response.handles.map(fromHexString);
                if (handles.length != response_handles.length) {
                    throw new Error(`Incorrect Handles list sizes: (expected) ${handles.length} != ${response_handles.length} (received)`);
                }
                for (let index = 0; index < handles.length; index++) {
                    let handle = handles[index];
                    let response_handle = response_handles[index];
                    let expected = Buffer.from(handle).toString('hex');
                    let current = Buffer.from(response_handle).toString('hex');
                    if (expected !== current) {
                        throw new Error(`Incorrect Handle ${index}: (expected) ${expected} != ${current} (received)`);
                    }
                }
            }
            const signatures = json.response.signatures;
            // inputProof is len(list_handles) + numCoprocessorSigners + list_handles + signatureCoprocessorSigners (1+1+NUM_HANDLES*32+65*numSigners)
            let inputProof = numberToHex(handles.length);
            const numSigners = signatures.length;
            inputProof += numberToHex(numSigners);
            const listHandlesStr = handles.map((i) => toHexString(i));
            listHandlesStr.map((handle) => (inputProof += handle));
            signatures.map((signature) => (inputProof += signature.slice(2))); // removes the '0x' prefix from the `signature` string
            return {
                handles,
                inputProof: fromHexString(inputProof),
            };
        },
        _handles() {
            return compute_handles(this._prove(), bits, aclContractAddress, chainId, currentCiphertextVersion());
        },
        async encrypt() {
            let start = Date.now();
            const ciphertextWithZKProof = await this._prove();
            console.log(`Encrypting and proving in ${Math.round((Date.now() - start) / 100) / 10}s`);
            start = Date.now();
            const verification = await this._verify(ciphertextWithZKProof);
            console.log(`Verifying in ${Math.round((Date.now() - start) / 100) / 10}s`);
            return verification;
        },
    };
};

/**
 * Creates an EIP712 structure specifically for user decrypt requests
 *
 * @param gatewayChainId The chain ID of the gateway
 * @param verifyingContract The address of the contract that will verify the signature
 * @param publicKey The user's public key as a hex string or Uint8Array
 * @param contractAddresses Array of contract addresses that can access the decryption
 * @param contractsChainId The chain ID where the contracts are deployed
 * @param startTimestamp The timestamp when the decryption permission becomes valid
 * @param durationDays How many days the decryption permission remains valid
 * @returns EIP712 typed data structure for user decryption
 */
const createEIP712 = (gatewayChainId, verifyingContract, contractsChainId) => (publicKey, contractAddresses, startTimestamp, durationDays, delegatedAccount) => {
    if (delegatedAccount && !ethers.isAddress(delegatedAccount))
        throw new Error('Invalid delegated account.');
    if (!ethers.isAddress(verifyingContract)) {
        throw new Error('Invalid verifying contract address.');
    }
    if (!contractAddresses.every((c) => ethers.isAddress(c))) {
        throw new Error('Invalid contract address.');
    }
    // Format the public key based on its type
    const formattedPublicKey = typeof publicKey === 'string'
        ? publicKey.startsWith('0x')
            ? publicKey
            : `0x${publicKey}`
        : publicKey;
    // Convert timestamps to strings if they're bigints
    const formattedStartTimestamp = typeof startTimestamp === 'number'
        ? startTimestamp.toString()
        : startTimestamp;
    const formattedDurationDays = typeof durationDays === 'number' ? durationDays.toString() : durationDays;
    const EIP712Domain = [
        { name: 'name', type: 'string' },
        { name: 'version', type: 'string' },
        { name: 'chainId', type: 'uint256' },
        { name: 'verifyingContract', type: 'address' },
    ];
    const domain = {
        name: 'DecryptionManager',
        version: '1',
        chainId: gatewayChainId,
        verifyingContract,
    };
    if (delegatedAccount) {
        return {
            types: {
                EIP712Domain,
                DelegatedUserDecryptRequestVerification: [
                    { name: 'publicKey', type: 'bytes' },
                    { name: 'contractAddresses', type: 'address[]' },
                    { name: 'contractsChainId', type: 'uint256' },
                    { name: 'startTimestamp', type: 'uint256' },
                    { name: 'durationDays', type: 'uint256' },
                    {
                        name: 'delegatedAccount',
                        type: 'address',
                    },
                ],
            },
            primaryType: 'DelegatedUserDecryptRequestVerification',
            domain,
            message: {
                publicKey: formattedPublicKey,
                contractAddresses,
                contractsChainId,
                startTimestamp: formattedStartTimestamp,
                durationDays: formattedDurationDays,
                delegatedAccount: delegatedAccount,
            },
        };
    }
    return {
        types: {
            EIP712Domain,
            UserDecryptRequestVerification: [
                { name: 'publicKey', type: 'bytes' },
                { name: 'contractAddresses', type: 'address[]' },
                { name: 'contractsChainId', type: 'uint256' },
                { name: 'startTimestamp', type: 'uint256' },
                { name: 'durationDays', type: 'uint256' },
            ],
        },
        primaryType: 'UserDecryptRequestVerification',
        domain,
        message: {
            publicKey: formattedPublicKey,
            contractAddresses,
            contractsChainId,
            startTimestamp: formattedStartTimestamp,
            durationDays: formattedDurationDays,
        },
    };
};
const generateKeypair = () => {
    const keypair = nodeTkms.cryptobox_keygen();
    return {
        publicKey: toHexString(nodeTkms.cryptobox_pk_to_u8vec(nodeTkms.cryptobox_get_pk(keypair))),
        privateKey: toHexString(nodeTkms.cryptobox_sk_to_u8vec(keypair)),
    };
};

const aclABI = [
    'function persistAllowed(uint256 handle, address account) view returns (bool)',
];
const userDecryptRequest = (kmsSignatures, gatewayChainId, chainId, verifyingContractAddress, aclContractAddress, relayerUrl, provider) => async (handles, privateKey, publicKey, signature, contractAddresses, userAddress, startTimestamp, durationDays) => {
    console.log('gatewayChainId', gatewayChainId);
    console.log('chainId', chainId);
    console.log('verifyingContractAddress', verifyingContractAddress);
    const acl = new ethers.ethers.Contract(aclContractAddress, aclABI, provider);
    const verifications = handles.map(async ({ ctHandle, contractAddress }) => {
        const userAllowed = await acl.persistAllowed(ctHandle, userAddress);
        const contractAllowed = await acl.persistAllowed(ctHandle, contractAddress);
        if (!userAllowed) {
            throw new Error('User is not authorized to reencrypt this handle!');
        }
        if (!contractAllowed) {
            throw new Error('dApp contract is not authorized to reencrypt this handle!');
        }
        if (userAddress === contractAddress) {
            throw new Error('userAddress should not be equal to contractAddress when requesting reencryption!');
        }
    });
    Promise.all(verifications).catch((e) => {
        throw e;
    });
    const payloadForRequest = {
        ctHandleContractPairs: handles.map((h) => {
            return {
                ctHandle: h.ctHandle.toString(16).padStart(64, '0'),
                contractAddress: h.contractAddress,
            };
        }),
        requestValidity: {
            startTimestamp: startTimestamp.toString(), // Convert to string
            durationDays: durationDays.toString(), // Convert to string
        },
        contractsChainId: chainId.toString(), // Convert to string
        contractAddresses: contractAddresses.map((c) => ethers.getAddress(c)),
        userAddress: ethers.getAddress(userAddress),
        signature: signature.replace(/^(0x)/, ''),
        publicKey: publicKey.replace(/^(0x)/, ''),
    };
    const options = {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(payloadForRequest),
    };
    let pubKey;
    let privKey;
    try {
        pubKey = nodeTkms.u8vec_to_cryptobox_pk(fromHexString(publicKey));
        privKey = nodeTkms.u8vec_to_cryptobox_sk(fromHexString(privateKey));
    }
    catch (e) {
        throw new Error('Invalid public or private key', { cause: e });
    }
    let response;
    let json;
    try {
        response = await fetch(`${relayerUrl}user-decrypt`, options);
        if (!response.ok) {
            throw new Error(`Reencrypt failed: relayer respond with HTTP code ${response.status}`);
        }
    }
    catch (e) {
        throw new Error("Reencrypt failed: Relayer didn't respond", { cause: e });
    }
    try {
        json = await response.json();
    }
    catch (e) {
        throw new Error("Reencrypt failed: Relayer didn't return a JSON", {
            cause: e,
        });
    }
    if (json.status === 'failure') {
        throw new Error("Reencrypt failed: the reencryption didn't succeed for an unknown reason", { cause: json });
    }
    const client = nodeTkms.new_client(kmsSignatures, userAddress, 'default');
    try {
        const buffer = new ArrayBuffer(32);
        const view = new DataView(buffer);
        view.setUint32(28, gatewayChainId, false);
        const chainIdArrayBE = new Uint8Array(buffer);
        const eip712Domain = {
            name: 'DecryptionManager',
            version: '1',
            chain_id: chainIdArrayBE,
            verifying_contract: verifyingContractAddress,
            salt: null,
        };
        // Duplicate payloadForRequest and replace ciphertext_handle with ciphertext_digest.
        // TODO check all ciphertext digests are all the same
        const payloadForVerification = {
            signature,
            client_address: userAddress,
            enc_key: publicKey,
            ciphertext_handles: handles.map((h) => h.ctHandle.toString(16).padStart(64, '0')),
            eip712_verifying_contract: verifyingContractAddress,
        };
        const decryption = nodeTkms.process_reencryption_resp_from_js(client, payloadForVerification, eip712Domain, json.response, pubKey, privKey, true);
        return decryption.map((d) => bytesToBigInt(d.bytes));
    }
    catch (e) {
        throw new Error('An error occured during decryption', { cause: e });
    }
};

const publicDecryptRequest = (kmsSignatures, gatewayChainId, chainId, verifyingContractAddress, aclContractAddress, relayerUrl, provider) => async (handle) => {
    const payloadForRequest = {
        ciphertext_handle: handle.toString(16).padStart(64, '0'),
    };
    const options = {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(payloadForRequest),
    };
    let response;
    let json;
    try {
        response = await fetch(`${relayerUrl}publicDecrypt`, options);
        if (!response.ok) {
            throw new Error(`Reencrypt failed: relayer respond with HTTP code ${response.status}`);
        }
    }
    catch (e) {
        throw new Error("Public decrypt failed: Relayer didn't respond", {
            cause: e,
        });
    }
    try {
        json = await response.json();
    }
    catch (e) {
        throw new Error("Public decrypt failed: Relayer didn't return a JSON", {
            cause: e,
        });
    }
    if (json.status === 'failure') {
        throw new Error("Public decrypt failed: the public decrypt didn't succeed for an unknown reason", { cause: json });
    }
    // TODO verify signature on decryption
    return json;
};

global.fetch = fetchRetry(global.fetch, { retries: 5, retryDelay: 500 });
const createInstance = async (config) => {
    const { publicKey, kmsContractAddress, verifyingContractAddress, aclContractAddress, gatewayChainId, } = config;
    if (!kmsContractAddress || !ethers.isAddress(kmsContractAddress)) {
        throw new Error('KMS contract address is not valid or empty');
    }
    if (!verifyingContractAddress || !ethers.isAddress(verifyingContractAddress)) {
        throw new Error('Verifying contract address is not valid or empty');
    }
    if (!aclContractAddress || !ethers.isAddress(aclContractAddress)) {
        throw new Error('ACL contract address is not valid or empty');
    }
    if (publicKey && !(publicKey.data instanceof Uint8Array))
        throw new Error('publicKey must be a Uint8Array');
    const provider = getProvider(config);
    if (!provider) {
        throw new Error('No network has been provided!');
    }
    const chainId = await getChainId(provider, config);
    const publicKeyData = await getTfheCompactPublicKey(config);
    const publicParamsData = await getPublicParams(config);
    const kmsSigners = await getKMSSigners(provider, config);
    const userDecrypt = userDecryptRequest(kmsSigners, gatewayChainId, chainId, verifyingContractAddress, aclContractAddress, cleanURL(config.relayerUrl), provider);
    const publicDecrypt = publicDecryptRequest(kmsSigners, gatewayChainId, chainId, verifyingContractAddress, aclContractAddress, cleanURL(config.relayerUrl));
    return {
        createEncryptedInput: createEncryptedInput(aclContractAddress, chainId, cleanURL(config.relayerUrl), publicKeyData.publicKey, publicParamsData),
        generateKeypair,
        createEIP712: createEIP712(gatewayChainId, verifyingContractAddress, chainId),
        publicDecrypt,
        userDecrypt,
        getPublicKey: () => publicKeyData.publicKey
            ? {
                publicKey: publicKeyData.publicKey.safe_serialize(SERIALIZED_SIZE_LIMIT_PK),
                publicKeyId: publicKeyData.publicKeyId,
            }
            : null,
        getPublicParams: (bits) => {
            if (publicParamsData[bits]) {
                return {
                    publicParams: publicParamsData[bits].publicParams.safe_serialize(SERIALIZED_SIZE_LIMIT_CRS),
                    publicParamsId: publicParamsData[bits].publicParamsId,
                };
            }
            return null;
        },
    };
};

const createTfheKeypair = () => {
    const block_params = new nodeTfhe.ShortintParameters(nodeTfhe.ShortintParametersName.PARAM_MESSAGE_2_CARRY_2_KS_PBS_TUNIFORM_2M128);
    const casting_params = new nodeTfhe.ShortintCompactPublicKeyEncryptionParameters(nodeTfhe.ShortintCompactPublicKeyEncryptionParametersName.V1_0_PARAM_PKE_MESSAGE_2_CARRY_2_KS_PBS_TUNIFORM_2M128);
    const config = nodeTfhe.TfheConfigBuilder.default()
        .use_custom_parameters(block_params)
        .use_dedicated_compact_public_key_parameters(casting_params)
        .build();
    let clientKey = nodeTfhe.TfheClientKey.generate(config);
    let publicKey = nodeTfhe.TfheCompactPublicKey.new(clientKey);
    const crs = nodeTfhe.CompactPkeCrs.from_config(config, 4 * 512);
    return { clientKey, publicKey, crs };
};
const createTfhePublicKey = () => {
    const { publicKey } = createTfheKeypair();
    return toHexString(publicKey.serialize());
};

exports.clientKeyDecryptor = clientKeyDecryptor;
exports.createEIP712 = createEIP712;
exports.createInstance = createInstance;
exports.createTfheKeypair = createTfheKeypair;
exports.createTfhePublicKey = createTfhePublicKey;
exports.generateKeypair = generateKeypair;
exports.getCiphertextCallParams = getCiphertextCallParams;
