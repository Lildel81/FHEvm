import { TfheCompactPublicKey, CompactPkeCrs } from 'node-tfhe';
import { ENCRYPTION_TYPES } from './encryptionTypes';
type EncryptionTypes = keyof typeof ENCRYPTION_TYPES;
export type HttpzRelayerInputProofResponse = {
    response: {
        handles: string[];
        signatures: string[];
    };
    status: string;
};
export type ZKInput = {
    addBool: (value: boolean) => ZKInput;
    add4: (value: number | bigint) => ZKInput;
    add8: (value: number | bigint) => ZKInput;
    add16: (value: number | bigint) => ZKInput;
    add32: (value: number | bigint) => ZKInput;
    add64: (value: number | bigint) => ZKInput;
    add128: (value: number | bigint) => ZKInput;
    add256: (value: number | bigint) => ZKInput;
    addBytes64: (value: Uint8Array) => ZKInput;
    addBytes128: (value: Uint8Array) => ZKInput;
    addBytes256: (value: Uint8Array) => ZKInput;
    addAddress: (value: string) => ZKInput;
    getBits: () => number[];
    _getClosestPP: () => EncryptionTypes;
    _prove: () => Uint8Array;
    _verify: (ciphertext: Uint8Array) => Promise<{
        handles: Uint8Array[];
        inputProof: Uint8Array;
    }>;
    _handles: () => Uint8Array[];
    encrypt: () => Promise<{
        handles: Uint8Array[];
        inputProof: Uint8Array;
    }>;
};
export type PublicParams<T = CompactPkeCrs> = {
    [key in EncryptionTypes]?: {
        publicParams: T;
        publicParamsId: string;
    };
};
export declare const createEncryptedInput: (aclContractAddress: string, chainId: number, relayer_url: string, tfheCompactPublicKey: TfheCompactPublicKey, publicParams: PublicParams) => (contractAddress: string, userAddress: string) => ZKInput;
export {};
