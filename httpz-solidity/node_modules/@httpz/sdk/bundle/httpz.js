var tb = Object.defineProperty;
var dh = (n) => {
  throw TypeError(n);
};
var eb = (n, t, e) => t in n ? tb(n, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : n[t] = e;
var U = (n, t, e) => eb(n, typeof t != "symbol" ? t + "" : t, e), Jl = (n, t, e) => t.has(n) || dh("Cannot " + e);
var w = (n, t, e) => (Jl(n, t, "read from private field"), e ? e.call(n) : t.get(n)), j = (n, t, e) => t.has(n) ? dh("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), P = (n, t, e, r) => (Jl(n, t, "write to private field"), r ? r.call(n, e) : t.set(n, e), e), ct = (n, t, e) => (Jl(n, t, "access private method"), e);
var Ua = (n, t, e, r) => ({
  set _(i) {
    P(n, t, i, e);
  },
  get _() {
    return w(n, t, r);
  }
});
const ba = globalThis || void 0 || self;
var ie = {}, D_ = {};
D_.byteLength = ib;
D_.toByteArray = ob;
D_.fromByteArray = _b;
var an = [], je = [], rb = typeof Uint8Array < "u" ? Uint8Array : Array, $l = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var Rs = 0, nb = $l.length; Rs < nb; ++Rs)
  an[Rs] = $l[Rs], je[$l.charCodeAt(Rs)] = Rs;
je[45] = 62;
je[95] = 63;
function qw(n) {
  var t = n.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var e = n.indexOf("=");
  e === -1 && (e = t);
  var r = e === t ? 0 : 4 - e % 4;
  return [e, r];
}
function ib(n) {
  var t = qw(n), e = t[0], r = t[1];
  return (e + r) * 3 / 4 - r;
}
function sb(n, t, e) {
  return (t + e) * 3 / 4 - e;
}
function ob(n) {
  var t, e = qw(n), r = e[0], i = e[1], s = new rb(sb(n, r, i)), a = 0, c = i > 0 ? r - 4 : r, _;
  for (_ = 0; _ < c; _ += 4)
    t = je[n.charCodeAt(_)] << 18 | je[n.charCodeAt(_ + 1)] << 12 | je[n.charCodeAt(_ + 2)] << 6 | je[n.charCodeAt(_ + 3)], s[a++] = t >> 16 & 255, s[a++] = t >> 8 & 255, s[a++] = t & 255;
  return i === 2 && (t = je[n.charCodeAt(_)] << 2 | je[n.charCodeAt(_ + 1)] >> 4, s[a++] = t & 255), i === 1 && (t = je[n.charCodeAt(_)] << 10 | je[n.charCodeAt(_ + 1)] << 4 | je[n.charCodeAt(_ + 2)] >> 2, s[a++] = t >> 8 & 255, s[a++] = t & 255), s;
}
function ab(n) {
  return an[n >> 18 & 63] + an[n >> 12 & 63] + an[n >> 6 & 63] + an[n & 63];
}
function cb(n, t, e) {
  for (var r, i = [], s = t; s < e; s += 3)
    r = (n[s] << 16 & 16711680) + (n[s + 1] << 8 & 65280) + (n[s + 2] & 255), i.push(ab(r));
  return i.join("");
}
function _b(n) {
  for (var t, e = n.length, r = e % 3, i = [], s = 16383, a = 0, c = e - r; a < c; a += s)
    i.push(cb(n, a, a + s > c ? c : a + s));
  return r === 1 ? (t = n[e - 1], i.push(
    an[t >> 2] + an[t << 4 & 63] + "=="
  )) : r === 2 && (t = (n[e - 2] << 8) + n[e - 1], i.push(
    an[t >> 10] + an[t >> 4 & 63] + an[t << 2 & 63] + "="
  )), i.join("");
}
var Bf = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
Bf.read = function(n, t, e, r, i) {
  var s, a, c = i * 8 - r - 1, _ = (1 << c) - 1, p = _ >> 1, f = -7, d = e ? i - 1 : 0, y = e ? -1 : 1, b = n[t + d];
  for (d += y, s = b & (1 << -f) - 1, b >>= -f, f += c; f > 0; s = s * 256 + n[t + d], d += y, f -= 8)
    ;
  for (a = s & (1 << -f) - 1, s >>= -f, f += r; f > 0; a = a * 256 + n[t + d], d += y, f -= 8)
    ;
  if (s === 0)
    s = 1 - p;
  else {
    if (s === _)
      return a ? NaN : (b ? -1 : 1) * (1 / 0);
    a = a + Math.pow(2, r), s = s - p;
  }
  return (b ? -1 : 1) * a * Math.pow(2, s - r);
};
Bf.write = function(n, t, e, r, i, s) {
  var a, c, _, p = s * 8 - i - 1, f = (1 << p) - 1, d = f >> 1, y = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, b = r ? 0 : s - 1, v = r ? 1 : -1, R = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (c = isNaN(t) ? 1 : 0, a = f) : (a = Math.floor(Math.log(t) / Math.LN2), t * (_ = Math.pow(2, -a)) < 1 && (a--, _ *= 2), a + d >= 1 ? t += y / _ : t += y * Math.pow(2, 1 - d), t * _ >= 2 && (a++, _ /= 2), a + d >= f ? (c = 0, a = f) : a + d >= 1 ? (c = (t * _ - 1) * Math.pow(2, i), a = a + d) : (c = t * Math.pow(2, d - 1) * Math.pow(2, i), a = 0)); i >= 8; n[e + b] = c & 255, b += v, c /= 256, i -= 8)
    ;
  for (a = a << i | c, p += i; p > 0; n[e + b] = a & 255, b += v, a /= 256, p -= 8)
    ;
  n[e + b - v] |= R * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(n) {
  const t = D_, e = Bf, r = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  n.Buffer = f, n.SlowBuffer = D, n.INSPECT_MAX_BYTES = 50;
  const i = 2147483647;
  n.kMaxLength = i;
  const { Uint8Array: s, ArrayBuffer: a, SharedArrayBuffer: c } = globalThis;
  f.TYPED_ARRAY_SUPPORT = _(), !f.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function _() {
    try {
      const g = new s(1), l = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(l, s.prototype), Object.setPrototypeOf(g, l), g.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(f.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (f.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(f.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (f.isBuffer(this))
        return this.byteOffset;
    }
  });
  function p(g) {
    if (g > i)
      throw new RangeError('The value "' + g + '" is invalid for option "size"');
    const l = new s(g);
    return Object.setPrototypeOf(l, f.prototype), l;
  }
  function f(g, l, h) {
    if (typeof g == "number") {
      if (typeof l == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return v(g);
    }
    return d(g, l, h);
  }
  f.poolSize = 8192;
  function d(g, l, h) {
    if (typeof g == "string")
      return R(g, l);
    if (a.isView(g))
      return A(g);
    if (g == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof g
      );
    if (_e(g, a) || g && _e(g.buffer, a) || typeof c < "u" && (_e(g, c) || g && _e(g.buffer, c)))
      return B(g, l, h);
    if (typeof g == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const S = g.valueOf && g.valueOf();
    if (S != null && S !== g)
      return f.from(S, l, h);
    const C = N(g);
    if (C) return C;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof g[Symbol.toPrimitive] == "function")
      return f.from(g[Symbol.toPrimitive]("string"), l, h);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof g
    );
  }
  f.from = function(g, l, h) {
    return d(g, l, h);
  }, Object.setPrototypeOf(f.prototype, s.prototype), Object.setPrototypeOf(f, s);
  function y(g) {
    if (typeof g != "number")
      throw new TypeError('"size" argument must be of type number');
    if (g < 0)
      throw new RangeError('The value "' + g + '" is invalid for option "size"');
  }
  function b(g, l, h) {
    return y(g), g <= 0 ? p(g) : l !== void 0 ? typeof h == "string" ? p(g).fill(l, h) : p(g).fill(l) : p(g);
  }
  f.alloc = function(g, l, h) {
    return b(g, l, h);
  };
  function v(g) {
    return y(g), p(g < 0 ? 0 : G(g) | 0);
  }
  f.allocUnsafe = function(g) {
    return v(g);
  }, f.allocUnsafeSlow = function(g) {
    return v(g);
  };
  function R(g, l) {
    if ((typeof l != "string" || l === "") && (l = "utf8"), !f.isEncoding(l))
      throw new TypeError("Unknown encoding: " + l);
    const h = $(g, l) | 0;
    let S = p(h);
    const C = S.write(g, l);
    return C !== h && (S = S.slice(0, C)), S;
  }
  function M(g) {
    const l = g.length < 0 ? 0 : G(g.length) | 0, h = p(l);
    for (let S = 0; S < l; S += 1)
      h[S] = g[S] & 255;
    return h;
  }
  function A(g) {
    if (_e(g, s)) {
      const l = new s(g);
      return B(l.buffer, l.byteOffset, l.byteLength);
    }
    return M(g);
  }
  function B(g, l, h) {
    if (l < 0 || g.byteLength < l)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (g.byteLength < l + (h || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let S;
    return l === void 0 && h === void 0 ? S = new s(g) : h === void 0 ? S = new s(g, l) : S = new s(g, l, h), Object.setPrototypeOf(S, f.prototype), S;
  }
  function N(g) {
    if (f.isBuffer(g)) {
      const l = G(g.length) | 0, h = p(l);
      return h.length === 0 || g.copy(h, 0, 0, l), h;
    }
    if (g.length !== void 0)
      return typeof g.length != "number" || Ge(g.length) ? p(0) : M(g);
    if (g.type === "Buffer" && Array.isArray(g.data))
      return M(g.data);
  }
  function G(g) {
    if (g >= i)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
    return g | 0;
  }
  function D(g) {
    return +g != g && (g = 0), f.alloc(+g);
  }
  f.isBuffer = function(l) {
    return l != null && l._isBuffer === !0 && l !== f.prototype;
  }, f.compare = function(l, h) {
    if (_e(l, s) && (l = f.from(l, l.offset, l.byteLength)), _e(h, s) && (h = f.from(h, h.offset, h.byteLength)), !f.isBuffer(l) || !f.isBuffer(h))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (l === h) return 0;
    let S = l.length, C = h.length;
    for (let K = 0, q = Math.min(S, C); K < q; ++K)
      if (l[K] !== h[K]) {
        S = l[K], C = h[K];
        break;
      }
    return S < C ? -1 : C < S ? 1 : 0;
  }, f.isEncoding = function(l) {
    switch (String(l).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, f.concat = function(l, h) {
    if (!Array.isArray(l))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (l.length === 0)
      return f.alloc(0);
    let S;
    if (h === void 0)
      for (h = 0, S = 0; S < l.length; ++S)
        h += l[S].length;
    const C = f.allocUnsafe(h);
    let K = 0;
    for (S = 0; S < l.length; ++S) {
      let q = l[S];
      if (_e(q, s))
        K + q.length > C.length ? (f.isBuffer(q) || (q = f.from(q)), q.copy(C, K)) : s.prototype.set.call(
          C,
          q,
          K
        );
      else if (f.isBuffer(q))
        q.copy(C, K);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      K += q.length;
    }
    return C;
  };
  function $(g, l) {
    if (f.isBuffer(g))
      return g.length;
    if (a.isView(g) || _e(g, a))
      return g.byteLength;
    if (typeof g != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof g
      );
    const h = g.length, S = arguments.length > 2 && arguments[2] === !0;
    if (!S && h === 0) return 0;
    let C = !1;
    for (; ; )
      switch (l) {
        case "ascii":
        case "latin1":
        case "binary":
          return h;
        case "utf8":
        case "utf-8":
          return tr(g).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return h * 2;
        case "hex":
          return h >>> 1;
        case "base64":
          return fn(g).length;
        default:
          if (C)
            return S ? -1 : tr(g).length;
          l = ("" + l).toLowerCase(), C = !0;
      }
  }
  f.byteLength = $;
  function X(g, l, h) {
    let S = !1;
    if ((l === void 0 || l < 0) && (l = 0), l > this.length || ((h === void 0 || h > this.length) && (h = this.length), h <= 0) || (h >>>= 0, l >>>= 0, h <= l))
      return "";
    for (g || (g = "utf8"); ; )
      switch (g) {
        case "hex":
          return k(this, l, h);
        case "utf8":
        case "utf-8":
          return dt(this, l, h);
        case "ascii":
          return It(this, l, h);
        case "latin1":
        case "binary":
          return Dt(this, l, h);
        case "base64":
          return ot(this, l, h);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Y(this, l, h);
        default:
          if (S) throw new TypeError("Unknown encoding: " + g);
          g = (g + "").toLowerCase(), S = !0;
      }
  }
  f.prototype._isBuffer = !0;
  function V(g, l, h) {
    const S = g[l];
    g[l] = g[h], g[h] = S;
  }
  f.prototype.swap16 = function() {
    const l = this.length;
    if (l % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let h = 0; h < l; h += 2)
      V(this, h, h + 1);
    return this;
  }, f.prototype.swap32 = function() {
    const l = this.length;
    if (l % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let h = 0; h < l; h += 4)
      V(this, h, h + 3), V(this, h + 1, h + 2);
    return this;
  }, f.prototype.swap64 = function() {
    const l = this.length;
    if (l % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let h = 0; h < l; h += 8)
      V(this, h, h + 7), V(this, h + 1, h + 6), V(this, h + 2, h + 5), V(this, h + 3, h + 4);
    return this;
  }, f.prototype.toString = function() {
    const l = this.length;
    return l === 0 ? "" : arguments.length === 0 ? dt(this, 0, l) : X.apply(this, arguments);
  }, f.prototype.toLocaleString = f.prototype.toString, f.prototype.equals = function(l) {
    if (!f.isBuffer(l)) throw new TypeError("Argument must be a Buffer");
    return this === l ? !0 : f.compare(this, l) === 0;
  }, f.prototype.inspect = function() {
    let l = "";
    const h = n.INSPECT_MAX_BYTES;
    return l = this.toString("hex", 0, h).replace(/(.{2})/g, "$1 ").trim(), this.length > h && (l += " ... "), "<Buffer " + l + ">";
  }, r && (f.prototype[r] = f.prototype.inspect), f.prototype.compare = function(l, h, S, C, K) {
    if (_e(l, s) && (l = f.from(l, l.offset, l.byteLength)), !f.isBuffer(l))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof l
      );
    if (h === void 0 && (h = 0), S === void 0 && (S = l ? l.length : 0), C === void 0 && (C = 0), K === void 0 && (K = this.length), h < 0 || S > l.length || C < 0 || K > this.length)
      throw new RangeError("out of range index");
    if (C >= K && h >= S)
      return 0;
    if (C >= K)
      return -1;
    if (h >= S)
      return 1;
    if (h >>>= 0, S >>>= 0, C >>>= 0, K >>>= 0, this === l) return 0;
    let q = K - C, mt = S - h;
    const Kt = Math.min(q, mt), Gt = this.slice(C, K), Vt = l.slice(h, S);
    for (let Ft = 0; Ft < Kt; ++Ft)
      if (Gt[Ft] !== Vt[Ft]) {
        q = Gt[Ft], mt = Vt[Ft];
        break;
      }
    return q < mt ? -1 : mt < q ? 1 : 0;
  };
  function nt(g, l, h, S, C) {
    if (g.length === 0) return -1;
    if (typeof h == "string" ? (S = h, h = 0) : h > 2147483647 ? h = 2147483647 : h < -2147483648 && (h = -2147483648), h = +h, Ge(h) && (h = C ? 0 : g.length - 1), h < 0 && (h = g.length + h), h >= g.length) {
      if (C) return -1;
      h = g.length - 1;
    } else if (h < 0)
      if (C) h = 0;
      else return -1;
    if (typeof l == "string" && (l = f.from(l, S)), f.isBuffer(l))
      return l.length === 0 ? -1 : ft(g, l, h, S, C);
    if (typeof l == "number")
      return l = l & 255, typeof s.prototype.indexOf == "function" ? C ? s.prototype.indexOf.call(g, l, h) : s.prototype.lastIndexOf.call(g, l, h) : ft(g, [l], h, S, C);
    throw new TypeError("val must be string, number or Buffer");
  }
  function ft(g, l, h, S, C) {
    let K = 1, q = g.length, mt = l.length;
    if (S !== void 0 && (S = String(S).toLowerCase(), S === "ucs2" || S === "ucs-2" || S === "utf16le" || S === "utf-16le")) {
      if (g.length < 2 || l.length < 2)
        return -1;
      K = 2, q /= 2, mt /= 2, h /= 2;
    }
    function Kt(Vt, Ft) {
      return K === 1 ? Vt[Ft] : Vt.readUInt16BE(Ft * K);
    }
    let Gt;
    if (C) {
      let Vt = -1;
      for (Gt = h; Gt < q; Gt++)
        if (Kt(g, Gt) === Kt(l, Vt === -1 ? 0 : Gt - Vt)) {
          if (Vt === -1 && (Vt = Gt), Gt - Vt + 1 === mt) return Vt * K;
        } else
          Vt !== -1 && (Gt -= Gt - Vt), Vt = -1;
    } else
      for (h + mt > q && (h = q - mt), Gt = h; Gt >= 0; Gt--) {
        let Vt = !0;
        for (let Ft = 0; Ft < mt; Ft++)
          if (Kt(g, Gt + Ft) !== Kt(l, Ft)) {
            Vt = !1;
            break;
          }
        if (Vt) return Gt;
      }
    return -1;
  }
  f.prototype.includes = function(l, h, S) {
    return this.indexOf(l, h, S) !== -1;
  }, f.prototype.indexOf = function(l, h, S) {
    return nt(this, l, h, S, !0);
  }, f.prototype.lastIndexOf = function(l, h, S) {
    return nt(this, l, h, S, !1);
  };
  function pt(g, l, h, S) {
    h = Number(h) || 0;
    const C = g.length - h;
    S ? (S = Number(S), S > C && (S = C)) : S = C;
    const K = l.length;
    S > K / 2 && (S = K / 2);
    let q;
    for (q = 0; q < S; ++q) {
      const mt = parseInt(l.substr(q * 2, 2), 16);
      if (Ge(mt)) return q;
      g[h + q] = mt;
    }
    return q;
  }
  function At(g, l, h, S) {
    return er(tr(l, g.length - h), g, h, S);
  }
  function Nt(g, l, h, S) {
    return er(yi(l), g, h, S);
  }
  function kt(g, l, h, S) {
    return er(fn(l), g, h, S);
  }
  function it(g, l, h, S) {
    return er(bi(l, g.length - h), g, h, S);
  }
  f.prototype.write = function(l, h, S, C) {
    if (h === void 0)
      C = "utf8", S = this.length, h = 0;
    else if (S === void 0 && typeof h == "string")
      C = h, S = this.length, h = 0;
    else if (isFinite(h))
      h = h >>> 0, isFinite(S) ? (S = S >>> 0, C === void 0 && (C = "utf8")) : (C = S, S = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const K = this.length - h;
    if ((S === void 0 || S > K) && (S = K), l.length > 0 && (S < 0 || h < 0) || h > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    C || (C = "utf8");
    let q = !1;
    for (; ; )
      switch (C) {
        case "hex":
          return pt(this, l, h, S);
        case "utf8":
        case "utf-8":
          return At(this, l, h, S);
        case "ascii":
        case "latin1":
        case "binary":
          return Nt(this, l, h, S);
        case "base64":
          return kt(this, l, h, S);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return it(this, l, h, S);
        default:
          if (q) throw new TypeError("Unknown encoding: " + C);
          C = ("" + C).toLowerCase(), q = !0;
      }
  }, f.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function ot(g, l, h) {
    return l === 0 && h === g.length ? t.fromByteArray(g) : t.fromByteArray(g.slice(l, h));
  }
  function dt(g, l, h) {
    h = Math.min(g.length, h);
    const S = [];
    let C = l;
    for (; C < h; ) {
      const K = g[C];
      let q = null, mt = K > 239 ? 4 : K > 223 ? 3 : K > 191 ? 2 : 1;
      if (C + mt <= h) {
        let Kt, Gt, Vt, Ft;
        switch (mt) {
          case 1:
            K < 128 && (q = K);
            break;
          case 2:
            Kt = g[C + 1], (Kt & 192) === 128 && (Ft = (K & 31) << 6 | Kt & 63, Ft > 127 && (q = Ft));
            break;
          case 3:
            Kt = g[C + 1], Gt = g[C + 2], (Kt & 192) === 128 && (Gt & 192) === 128 && (Ft = (K & 15) << 12 | (Kt & 63) << 6 | Gt & 63, Ft > 2047 && (Ft < 55296 || Ft > 57343) && (q = Ft));
            break;
          case 4:
            Kt = g[C + 1], Gt = g[C + 2], Vt = g[C + 3], (Kt & 192) === 128 && (Gt & 192) === 128 && (Vt & 192) === 128 && (Ft = (K & 15) << 18 | (Kt & 63) << 12 | (Gt & 63) << 6 | Vt & 63, Ft > 65535 && Ft < 1114112 && (q = Ft));
        }
      }
      q === null ? (q = 65533, mt = 1) : q > 65535 && (q -= 65536, S.push(q >>> 10 & 1023 | 55296), q = 56320 | q & 1023), S.push(q), C += mt;
    }
    return yt(S);
  }
  const bt = 4096;
  function yt(g) {
    const l = g.length;
    if (l <= bt)
      return String.fromCharCode.apply(String, g);
    let h = "", S = 0;
    for (; S < l; )
      h += String.fromCharCode.apply(
        String,
        g.slice(S, S += bt)
      );
    return h;
  }
  function It(g, l, h) {
    let S = "";
    h = Math.min(g.length, h);
    for (let C = l; C < h; ++C)
      S += String.fromCharCode(g[C] & 127);
    return S;
  }
  function Dt(g, l, h) {
    let S = "";
    h = Math.min(g.length, h);
    for (let C = l; C < h; ++C)
      S += String.fromCharCode(g[C]);
    return S;
  }
  function k(g, l, h) {
    const S = g.length;
    (!l || l < 0) && (l = 0), (!h || h < 0 || h > S) && (h = S);
    let C = "";
    for (let K = l; K < h; ++K)
      C += rr[g[K]];
    return C;
  }
  function Y(g, l, h) {
    const S = g.slice(l, h);
    let C = "";
    for (let K = 0; K < S.length - 1; K += 2)
      C += String.fromCharCode(S[K] + S[K + 1] * 256);
    return C;
  }
  f.prototype.slice = function(l, h) {
    const S = this.length;
    l = ~~l, h = h === void 0 ? S : ~~h, l < 0 ? (l += S, l < 0 && (l = 0)) : l > S && (l = S), h < 0 ? (h += S, h < 0 && (h = 0)) : h > S && (h = S), h < l && (h = l);
    const C = this.subarray(l, h);
    return Object.setPrototypeOf(C, f.prototype), C;
  };
  function Q(g, l, h) {
    if (g % 1 !== 0 || g < 0) throw new RangeError("offset is not uint");
    if (g + l > h) throw new RangeError("Trying to access beyond buffer length");
  }
  f.prototype.readUintLE = f.prototype.readUIntLE = function(l, h, S) {
    l = l >>> 0, h = h >>> 0, S || Q(l, h, this.length);
    let C = this[l], K = 1, q = 0;
    for (; ++q < h && (K *= 256); )
      C += this[l + q] * K;
    return C;
  }, f.prototype.readUintBE = f.prototype.readUIntBE = function(l, h, S) {
    l = l >>> 0, h = h >>> 0, S || Q(l, h, this.length);
    let C = this[l + --h], K = 1;
    for (; h > 0 && (K *= 256); )
      C += this[l + --h] * K;
    return C;
  }, f.prototype.readUint8 = f.prototype.readUInt8 = function(l, h) {
    return l = l >>> 0, h || Q(l, 1, this.length), this[l];
  }, f.prototype.readUint16LE = f.prototype.readUInt16LE = function(l, h) {
    return l = l >>> 0, h || Q(l, 2, this.length), this[l] | this[l + 1] << 8;
  }, f.prototype.readUint16BE = f.prototype.readUInt16BE = function(l, h) {
    return l = l >>> 0, h || Q(l, 2, this.length), this[l] << 8 | this[l + 1];
  }, f.prototype.readUint32LE = f.prototype.readUInt32LE = function(l, h) {
    return l = l >>> 0, h || Q(l, 4, this.length), (this[l] | this[l + 1] << 8 | this[l + 2] << 16) + this[l + 3] * 16777216;
  }, f.prototype.readUint32BE = f.prototype.readUInt32BE = function(l, h) {
    return l = l >>> 0, h || Q(l, 4, this.length), this[l] * 16777216 + (this[l + 1] << 16 | this[l + 2] << 8 | this[l + 3]);
  }, f.prototype.readBigUInt64LE = re(function(l) {
    l = l >>> 0, wt(l, "offset");
    const h = this[l], S = this[l + 7];
    (h === void 0 || S === void 0) && Pt(l, this.length - 8);
    const C = h + this[++l] * 2 ** 8 + this[++l] * 2 ** 16 + this[++l] * 2 ** 24, K = this[++l] + this[++l] * 2 ** 8 + this[++l] * 2 ** 16 + S * 2 ** 24;
    return BigInt(C) + (BigInt(K) << BigInt(32));
  }), f.prototype.readBigUInt64BE = re(function(l) {
    l = l >>> 0, wt(l, "offset");
    const h = this[l], S = this[l + 7];
    (h === void 0 || S === void 0) && Pt(l, this.length - 8);
    const C = h * 2 ** 24 + this[++l] * 2 ** 16 + this[++l] * 2 ** 8 + this[++l], K = this[++l] * 2 ** 24 + this[++l] * 2 ** 16 + this[++l] * 2 ** 8 + S;
    return (BigInt(C) << BigInt(32)) + BigInt(K);
  }), f.prototype.readIntLE = function(l, h, S) {
    l = l >>> 0, h = h >>> 0, S || Q(l, h, this.length);
    let C = this[l], K = 1, q = 0;
    for (; ++q < h && (K *= 256); )
      C += this[l + q] * K;
    return K *= 128, C >= K && (C -= Math.pow(2, 8 * h)), C;
  }, f.prototype.readIntBE = function(l, h, S) {
    l = l >>> 0, h = h >>> 0, S || Q(l, h, this.length);
    let C = h, K = 1, q = this[l + --C];
    for (; C > 0 && (K *= 256); )
      q += this[l + --C] * K;
    return K *= 128, q >= K && (q -= Math.pow(2, 8 * h)), q;
  }, f.prototype.readInt8 = function(l, h) {
    return l = l >>> 0, h || Q(l, 1, this.length), this[l] & 128 ? (255 - this[l] + 1) * -1 : this[l];
  }, f.prototype.readInt16LE = function(l, h) {
    l = l >>> 0, h || Q(l, 2, this.length);
    const S = this[l] | this[l + 1] << 8;
    return S & 32768 ? S | 4294901760 : S;
  }, f.prototype.readInt16BE = function(l, h) {
    l = l >>> 0, h || Q(l, 2, this.length);
    const S = this[l + 1] | this[l] << 8;
    return S & 32768 ? S | 4294901760 : S;
  }, f.prototype.readInt32LE = function(l, h) {
    return l = l >>> 0, h || Q(l, 4, this.length), this[l] | this[l + 1] << 8 | this[l + 2] << 16 | this[l + 3] << 24;
  }, f.prototype.readInt32BE = function(l, h) {
    return l = l >>> 0, h || Q(l, 4, this.length), this[l] << 24 | this[l + 1] << 16 | this[l + 2] << 8 | this[l + 3];
  }, f.prototype.readBigInt64LE = re(function(l) {
    l = l >>> 0, wt(l, "offset");
    const h = this[l], S = this[l + 7];
    (h === void 0 || S === void 0) && Pt(l, this.length - 8);
    const C = this[l + 4] + this[l + 5] * 2 ** 8 + this[l + 6] * 2 ** 16 + (S << 24);
    return (BigInt(C) << BigInt(32)) + BigInt(h + this[++l] * 2 ** 8 + this[++l] * 2 ** 16 + this[++l] * 2 ** 24);
  }), f.prototype.readBigInt64BE = re(function(l) {
    l = l >>> 0, wt(l, "offset");
    const h = this[l], S = this[l + 7];
    (h === void 0 || S === void 0) && Pt(l, this.length - 8);
    const C = (h << 24) + // Overflow
    this[++l] * 2 ** 16 + this[++l] * 2 ** 8 + this[++l];
    return (BigInt(C) << BigInt(32)) + BigInt(this[++l] * 2 ** 24 + this[++l] * 2 ** 16 + this[++l] * 2 ** 8 + S);
  }), f.prototype.readFloatLE = function(l, h) {
    return l = l >>> 0, h || Q(l, 4, this.length), e.read(this, l, !0, 23, 4);
  }, f.prototype.readFloatBE = function(l, h) {
    return l = l >>> 0, h || Q(l, 4, this.length), e.read(this, l, !1, 23, 4);
  }, f.prototype.readDoubleLE = function(l, h) {
    return l = l >>> 0, h || Q(l, 8, this.length), e.read(this, l, !0, 52, 8);
  }, f.prototype.readDoubleBE = function(l, h) {
    return l = l >>> 0, h || Q(l, 8, this.length), e.read(this, l, !1, 52, 8);
  };
  function _t(g, l, h, S, C, K) {
    if (!f.isBuffer(g)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (l > C || l < K) throw new RangeError('"value" argument is out of bounds');
    if (h + S > g.length) throw new RangeError("Index out of range");
  }
  f.prototype.writeUintLE = f.prototype.writeUIntLE = function(l, h, S, C) {
    if (l = +l, h = h >>> 0, S = S >>> 0, !C) {
      const mt = Math.pow(2, 8 * S) - 1;
      _t(this, l, h, S, mt, 0);
    }
    let K = 1, q = 0;
    for (this[h] = l & 255; ++q < S && (K *= 256); )
      this[h + q] = l / K & 255;
    return h + S;
  }, f.prototype.writeUintBE = f.prototype.writeUIntBE = function(l, h, S, C) {
    if (l = +l, h = h >>> 0, S = S >>> 0, !C) {
      const mt = Math.pow(2, 8 * S) - 1;
      _t(this, l, h, S, mt, 0);
    }
    let K = S - 1, q = 1;
    for (this[h + K] = l & 255; --K >= 0 && (q *= 256); )
      this[h + K] = l / q & 255;
    return h + S;
  }, f.prototype.writeUint8 = f.prototype.writeUInt8 = function(l, h, S) {
    return l = +l, h = h >>> 0, S || _t(this, l, h, 1, 255, 0), this[h] = l & 255, h + 1;
  }, f.prototype.writeUint16LE = f.prototype.writeUInt16LE = function(l, h, S) {
    return l = +l, h = h >>> 0, S || _t(this, l, h, 2, 65535, 0), this[h] = l & 255, this[h + 1] = l >>> 8, h + 2;
  }, f.prototype.writeUint16BE = f.prototype.writeUInt16BE = function(l, h, S) {
    return l = +l, h = h >>> 0, S || _t(this, l, h, 2, 65535, 0), this[h] = l >>> 8, this[h + 1] = l & 255, h + 2;
  }, f.prototype.writeUint32LE = f.prototype.writeUInt32LE = function(l, h, S) {
    return l = +l, h = h >>> 0, S || _t(this, l, h, 4, 4294967295, 0), this[h + 3] = l >>> 24, this[h + 2] = l >>> 16, this[h + 1] = l >>> 8, this[h] = l & 255, h + 4;
  }, f.prototype.writeUint32BE = f.prototype.writeUInt32BE = function(l, h, S) {
    return l = +l, h = h >>> 0, S || _t(this, l, h, 4, 4294967295, 0), this[h] = l >>> 24, this[h + 1] = l >>> 16, this[h + 2] = l >>> 8, this[h + 3] = l & 255, h + 4;
  };
  function O(g, l, h, S, C) {
    xt(l, S, C, g, h, 7);
    let K = Number(l & BigInt(4294967295));
    g[h++] = K, K = K >> 8, g[h++] = K, K = K >> 8, g[h++] = K, K = K >> 8, g[h++] = K;
    let q = Number(l >> BigInt(32) & BigInt(4294967295));
    return g[h++] = q, q = q >> 8, g[h++] = q, q = q >> 8, g[h++] = q, q = q >> 8, g[h++] = q, h;
  }
  function I(g, l, h, S, C) {
    xt(l, S, C, g, h, 7);
    let K = Number(l & BigInt(4294967295));
    g[h + 7] = K, K = K >> 8, g[h + 6] = K, K = K >> 8, g[h + 5] = K, K = K >> 8, g[h + 4] = K;
    let q = Number(l >> BigInt(32) & BigInt(4294967295));
    return g[h + 3] = q, q = q >> 8, g[h + 2] = q, q = q >> 8, g[h + 1] = q, q = q >> 8, g[h] = q, h + 8;
  }
  f.prototype.writeBigUInt64LE = re(function(l, h = 0) {
    return O(this, l, h, BigInt(0), BigInt("0xffffffffffffffff"));
  }), f.prototype.writeBigUInt64BE = re(function(l, h = 0) {
    return I(this, l, h, BigInt(0), BigInt("0xffffffffffffffff"));
  }), f.prototype.writeIntLE = function(l, h, S, C) {
    if (l = +l, h = h >>> 0, !C) {
      const Kt = Math.pow(2, 8 * S - 1);
      _t(this, l, h, S, Kt - 1, -Kt);
    }
    let K = 0, q = 1, mt = 0;
    for (this[h] = l & 255; ++K < S && (q *= 256); )
      l < 0 && mt === 0 && this[h + K - 1] !== 0 && (mt = 1), this[h + K] = (l / q >> 0) - mt & 255;
    return h + S;
  }, f.prototype.writeIntBE = function(l, h, S, C) {
    if (l = +l, h = h >>> 0, !C) {
      const Kt = Math.pow(2, 8 * S - 1);
      _t(this, l, h, S, Kt - 1, -Kt);
    }
    let K = S - 1, q = 1, mt = 0;
    for (this[h + K] = l & 255; --K >= 0 && (q *= 256); )
      l < 0 && mt === 0 && this[h + K + 1] !== 0 && (mt = 1), this[h + K] = (l / q >> 0) - mt & 255;
    return h + S;
  }, f.prototype.writeInt8 = function(l, h, S) {
    return l = +l, h = h >>> 0, S || _t(this, l, h, 1, 127, -128), l < 0 && (l = 255 + l + 1), this[h] = l & 255, h + 1;
  }, f.prototype.writeInt16LE = function(l, h, S) {
    return l = +l, h = h >>> 0, S || _t(this, l, h, 2, 32767, -32768), this[h] = l & 255, this[h + 1] = l >>> 8, h + 2;
  }, f.prototype.writeInt16BE = function(l, h, S) {
    return l = +l, h = h >>> 0, S || _t(this, l, h, 2, 32767, -32768), this[h] = l >>> 8, this[h + 1] = l & 255, h + 2;
  }, f.prototype.writeInt32LE = function(l, h, S) {
    return l = +l, h = h >>> 0, S || _t(this, l, h, 4, 2147483647, -2147483648), this[h] = l & 255, this[h + 1] = l >>> 8, this[h + 2] = l >>> 16, this[h + 3] = l >>> 24, h + 4;
  }, f.prototype.writeInt32BE = function(l, h, S) {
    return l = +l, h = h >>> 0, S || _t(this, l, h, 4, 2147483647, -2147483648), l < 0 && (l = 4294967295 + l + 1), this[h] = l >>> 24, this[h + 1] = l >>> 16, this[h + 2] = l >>> 8, this[h + 3] = l & 255, h + 4;
  }, f.prototype.writeBigInt64LE = re(function(l, h = 0) {
    return O(this, l, h, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), f.prototype.writeBigInt64BE = re(function(l, h = 0) {
    return I(this, l, h, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function H(g, l, h, S, C, K) {
    if (h + S > g.length) throw new RangeError("Index out of range");
    if (h < 0) throw new RangeError("Index out of range");
  }
  function rt(g, l, h, S, C) {
    return l = +l, h = h >>> 0, C || H(g, l, h, 4), e.write(g, l, h, S, 23, 4), h + 4;
  }
  f.prototype.writeFloatLE = function(l, h, S) {
    return rt(this, l, h, !0, S);
  }, f.prototype.writeFloatBE = function(l, h, S) {
    return rt(this, l, h, !1, S);
  };
  function at(g, l, h, S, C) {
    return l = +l, h = h >>> 0, C || H(g, l, h, 8), e.write(g, l, h, S, 52, 8), h + 8;
  }
  f.prototype.writeDoubleLE = function(l, h, S) {
    return at(this, l, h, !0, S);
  }, f.prototype.writeDoubleBE = function(l, h, S) {
    return at(this, l, h, !1, S);
  }, f.prototype.copy = function(l, h, S, C) {
    if (!f.isBuffer(l)) throw new TypeError("argument should be a Buffer");
    if (S || (S = 0), !C && C !== 0 && (C = this.length), h >= l.length && (h = l.length), h || (h = 0), C > 0 && C < S && (C = S), C === S || l.length === 0 || this.length === 0) return 0;
    if (h < 0)
      throw new RangeError("targetStart out of bounds");
    if (S < 0 || S >= this.length) throw new RangeError("Index out of range");
    if (C < 0) throw new RangeError("sourceEnd out of bounds");
    C > this.length && (C = this.length), l.length - h < C - S && (C = l.length - h + S);
    const K = C - S;
    return this === l && typeof s.prototype.copyWithin == "function" ? this.copyWithin(h, S, C) : s.prototype.set.call(
      l,
      this.subarray(S, C),
      h
    ), K;
  }, f.prototype.fill = function(l, h, S, C) {
    if (typeof l == "string") {
      if (typeof h == "string" ? (C = h, h = 0, S = this.length) : typeof S == "string" && (C = S, S = this.length), C !== void 0 && typeof C != "string")
        throw new TypeError("encoding must be a string");
      if (typeof C == "string" && !f.isEncoding(C))
        throw new TypeError("Unknown encoding: " + C);
      if (l.length === 1) {
        const q = l.charCodeAt(0);
        (C === "utf8" && q < 128 || C === "latin1") && (l = q);
      }
    } else typeof l == "number" ? l = l & 255 : typeof l == "boolean" && (l = Number(l));
    if (h < 0 || this.length < h || this.length < S)
      throw new RangeError("Out of range index");
    if (S <= h)
      return this;
    h = h >>> 0, S = S === void 0 ? this.length : S >>> 0, l || (l = 0);
    let K;
    if (typeof l == "number")
      for (K = h; K < S; ++K)
        this[K] = l;
    else {
      const q = f.isBuffer(l) ? l : f.from(l, C), mt = q.length;
      if (mt === 0)
        throw new TypeError('The value "' + l + '" is invalid for argument "value"');
      for (K = 0; K < S - h; ++K)
        this[K + h] = q[K % mt];
    }
    return this;
  };
  const m = {};
  function E(g, l, h) {
    m[g] = class extends h {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: l.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${g}]`, this.stack, delete this.name;
      }
      get code() {
        return g;
      }
      set code(C) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: C,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${g}]: ${this.message}`;
      }
    };
  }
  E(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(g) {
      return g ? `${g} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), E(
    "ERR_INVALID_ARG_TYPE",
    function(g, l) {
      return `The "${g}" argument must be of type number. Received type ${typeof l}`;
    },
    TypeError
  ), E(
    "ERR_OUT_OF_RANGE",
    function(g, l, h) {
      let S = `The value of "${g}" is out of range.`, C = h;
      return Number.isInteger(h) && Math.abs(h) > 2 ** 32 ? C = J(String(h)) : typeof h == "bigint" && (C = String(h), (h > BigInt(2) ** BigInt(32) || h < -(BigInt(2) ** BigInt(32))) && (C = J(C)), C += "n"), S += ` It must be ${l}. Received ${C}`, S;
    },
    RangeError
  );
  function J(g) {
    let l = "", h = g.length;
    const S = g[0] === "-" ? 1 : 0;
    for (; h >= S + 4; h -= 3)
      l = `_${g.slice(h - 3, h)}${l}`;
    return `${g.slice(0, h)}${l}`;
  }
  function st(g, l, h) {
    wt(l, "offset"), (g[l] === void 0 || g[l + h] === void 0) && Pt(l, g.length - (h + 1));
  }
  function xt(g, l, h, S, C, K) {
    if (g > h || g < l) {
      const q = typeof l == "bigint" ? "n" : "";
      let mt;
      throw l === 0 || l === BigInt(0) ? mt = `>= 0${q} and < 2${q} ** ${(K + 1) * 8}${q}` : mt = `>= -(2${q} ** ${(K + 1) * 8 - 1}${q}) and < 2 ** ${(K + 1) * 8 - 1}${q}`, new m.ERR_OUT_OF_RANGE("value", mt, g);
    }
    st(S, C, K);
  }
  function wt(g, l) {
    if (typeof g != "number")
      throw new m.ERR_INVALID_ARG_TYPE(l, "number", g);
  }
  function Pt(g, l, h) {
    throw Math.floor(g) !== g ? (wt(g, h), new m.ERR_OUT_OF_RANGE("offset", "an integer", g)) : l < 0 ? new m.ERR_BUFFER_OUT_OF_BOUNDS() : new m.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${l}`,
      g
    );
  }
  const Ce = /[^+/0-9A-Za-z-_]/g;
  function Z(g) {
    if (g = g.split("=")[0], g = g.trim().replace(Ce, ""), g.length < 2) return "";
    for (; g.length % 4 !== 0; )
      g = g + "=";
    return g;
  }
  function tr(g, l) {
    l = l || 1 / 0;
    let h;
    const S = g.length;
    let C = null;
    const K = [];
    for (let q = 0; q < S; ++q) {
      if (h = g.charCodeAt(q), h > 55295 && h < 57344) {
        if (!C) {
          if (h > 56319) {
            (l -= 3) > -1 && K.push(239, 191, 189);
            continue;
          } else if (q + 1 === S) {
            (l -= 3) > -1 && K.push(239, 191, 189);
            continue;
          }
          C = h;
          continue;
        }
        if (h < 56320) {
          (l -= 3) > -1 && K.push(239, 191, 189), C = h;
          continue;
        }
        h = (C - 55296 << 10 | h - 56320) + 65536;
      } else C && (l -= 3) > -1 && K.push(239, 191, 189);
      if (C = null, h < 128) {
        if ((l -= 1) < 0) break;
        K.push(h);
      } else if (h < 2048) {
        if ((l -= 2) < 0) break;
        K.push(
          h >> 6 | 192,
          h & 63 | 128
        );
      } else if (h < 65536) {
        if ((l -= 3) < 0) break;
        K.push(
          h >> 12 | 224,
          h >> 6 & 63 | 128,
          h & 63 | 128
        );
      } else if (h < 1114112) {
        if ((l -= 4) < 0) break;
        K.push(
          h >> 18 | 240,
          h >> 12 & 63 | 128,
          h >> 6 & 63 | 128,
          h & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return K;
  }
  function yi(g) {
    const l = [];
    for (let h = 0; h < g.length; ++h)
      l.push(g.charCodeAt(h) & 255);
    return l;
  }
  function bi(g, l) {
    let h, S, C;
    const K = [];
    for (let q = 0; q < g.length && !((l -= 2) < 0); ++q)
      h = g.charCodeAt(q), S = h >> 8, C = h % 256, K.push(C), K.push(S);
    return K;
  }
  function fn(g) {
    return t.toByteArray(Z(g));
  }
  function er(g, l, h, S) {
    let C;
    for (C = 0; C < S && !(C + h >= l.length || C >= g.length); ++C)
      l[C + h] = g[C];
    return C;
  }
  function _e(g, l) {
    return g instanceof l || g != null && g.constructor != null && g.constructor.name != null && g.constructor.name === l.name;
  }
  function Ge(g) {
    return g !== g;
  }
  const rr = function() {
    const g = "0123456789abcdef", l = new Array(256);
    for (let h = 0; h < 16; ++h) {
      const S = h * 16;
      for (let C = 0; C < 16; ++C)
        l[S + C] = g[h] + g[C];
    }
    return l;
  }();
  function re(g) {
    return typeof BigInt > "u" ? ka : g;
  }
  function ka() {
    throw new Error("BigInt not supported");
  }
})(ie);
const ne = ie.Buffer, lb = ie.Blob, ub = ie.BlobOptions, fb = ie.Buffer, hb = ie.File, pb = ie.FileOptions, db = ie.INSPECT_MAX_BYTES, wb = ie.SlowBuffer, gb = ie.TranscodeEncoding, yb = ie.atob, bb = ie.btoa, Ab = ie.constants, mb = ie.isAscii, Sb = ie.isUtf8, Eb = ie.kMaxLength, Rb = ie.kStringMaxLength, Pb = ie.resolveObjectURL, vb = ie.transcode, Mb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Blob: lb,
  BlobOptions: ub,
  Buffer: fb,
  File: hb,
  FileOptions: pb,
  INSPECT_MAX_BYTES: db,
  SlowBuffer: wb,
  TranscodeEncoding: gb,
  atob: yb,
  btoa: bb,
  constants: Ab,
  default: ne,
  isAscii: mb,
  isUtf8: Sb,
  kMaxLength: Eb,
  kStringMaxLength: Rb,
  resolveObjectURL: Pb,
  transcode: vb
}, Symbol.toStringTag, { value: "Module" })), xb = "6.13.4";
function Bb(n, t, e) {
  const r = t.split("|").map((s) => s.trim());
  for (let s = 0; s < r.length; s++)
    switch (t) {
      case "any":
        return;
      case "bigint":
      case "boolean":
      case "number":
      case "string":
        if (typeof n === t)
          return;
    }
  const i = new Error(`invalid value for type ${t}`);
  throw i.code = "INVALID_ARGUMENT", i.argument = `value.${e}`, i.value = n, i;
}
async function be(n) {
  const t = Object.keys(n);
  return (await Promise.all(t.map((r) => Promise.resolve(n[r])))).reduce((r, i, s) => (r[t[s]] = i, r), {});
}
function gt(n, t, e) {
  for (let r in t) {
    let i = t[r];
    const s = e ? e[r] : null;
    s && Bb(i, s, r), Object.defineProperty(n, r, { enumerable: !0, value: i, writable: !1 });
  }
}
function zs(n) {
  if (n == null)
    return "null";
  if (Array.isArray(n))
    return "[ " + n.map(zs).join(", ") + " ]";
  if (n instanceof Uint8Array) {
    const t = "0123456789abcdef";
    let e = "0x";
    for (let r = 0; r < n.length; r++)
      e += t[n[r] >> 4], e += t[n[r] & 15];
    return e;
  }
  if (typeof n == "object" && typeof n.toJSON == "function")
    return zs(n.toJSON());
  switch (typeof n) {
    case "boolean":
    case "symbol":
      return n.toString();
    case "bigint":
      return BigInt(n).toString();
    case "number":
      return n.toString();
    case "string":
      return JSON.stringify(n);
    case "object": {
      const t = Object.keys(n);
      return t.sort(), "{ " + t.map((e) => `${zs(e)}: ${zs(n[e])}`).join(", ") + " }";
    }
  }
  return "[ COULD NOT SERIALIZE ]";
}
function fe(n, t) {
  return n && n.code === t;
}
function Cf(n) {
  return fe(n, "CALL_EXCEPTION");
}
function Wt(n, t, e) {
  let r = n;
  {
    const s = [];
    if (e) {
      if ("message" in e || "code" in e || "name" in e)
        throw new Error(`value will overwrite populated values: ${zs(e)}`);
      for (const a in e) {
        if (a === "shortMessage")
          continue;
        const c = e[a];
        s.push(a + "=" + zs(c));
      }
    }
    s.push(`code=${t}`), s.push(`version=${xb}`), s.length && (n += " (" + s.join(", ") + ")");
  }
  let i;
  switch (t) {
    case "INVALID_ARGUMENT":
      i = new TypeError(n);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      i = new RangeError(n);
      break;
    default:
      i = new Error(n);
  }
  return gt(i, { code: t }), e && Object.assign(i, e), i.shortMessage == null && gt(i, { shortMessage: r }), i;
}
function et(n, t, e, r) {
  if (!n)
    throw Wt(t, e, r);
}
function T(n, t, e, r) {
  et(n, t, "INVALID_ARGUMENT", { argument: e, value: r });
}
function Zw(n, t, e) {
  e == null && (e = ""), e && (e = ": " + e), et(n >= t, "missing arguemnt" + e, "MISSING_ARGUMENT", {
    count: n,
    expectedCount: t
  }), et(n <= t, "too many arguments" + e, "UNEXPECTED_ARGUMENT", {
    count: n,
    expectedCount: t
  });
}
["NFD", "NFC", "NFKD", "NFKC"].reduce((n, t) => {
  try {
    if ("test".normalize(t) !== "test")
      throw new Error("bad");
    if (t === "NFD" && "é".normalize("NFD") !== "é")
      throw new Error("broken");
    n.push(t);
  } catch {
  }
  return n;
}, []);
function K_(n, t, e) {
  if (e == null && (e = ""), n !== t) {
    let r = e, i = "new";
    e && (r += ".", i += " " + e), et(!1, `private constructor; use ${r}from* methods`, "UNSUPPORTED_OPERATION", {
      operation: i
    });
  }
}
function Xw(n, t, e) {
  if (n instanceof Uint8Array)
    return e ? new Uint8Array(n) : n;
  if (typeof n == "string" && n.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
    const r = new Uint8Array((n.length - 2) / 2);
    let i = 2;
    for (let s = 0; s < r.length; s++)
      r[s] = parseInt(n.substring(i, i + 2), 16), i += 2;
    return r;
  }
  T(!1, "invalid BytesLike value", t || "value", n);
}
function Tt(n, t) {
  return Xw(n, t, !1);
}
function Ae(n, t) {
  return Xw(n, t, !0);
}
function jt(n, t) {
  return !(typeof n != "string" || !n.match(/^0x[0-9A-Fa-f]*$/) || typeof t == "number" && n.length !== 2 + 2 * t || t === !0 && n.length % 2 !== 0);
}
function If(n) {
  return jt(n, !0) || n instanceof Uint8Array;
}
const wh = "0123456789abcdef";
function ut(n) {
  const t = Tt(n);
  let e = "0x";
  for (let r = 0; r < t.length; r++) {
    const i = t[r];
    e += wh[(i & 240) >> 4] + wh[i & 15];
  }
  return e;
}
function Xt(n) {
  return "0x" + n.map((t) => ut(t).substring(2)).join("");
}
function So(n) {
  return jt(n, !0) ? (n.length - 2) / 2 : Tt(n).length;
}
function Jt(n, t, e) {
  const r = Tt(n);
  return e != null && e > r.length && et(!1, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
    buffer: r,
    length: r.length,
    offset: e
  }), ut(r.slice(t ?? 0, e ?? r.length));
}
function tg(n, t, e) {
  const r = Tt(n);
  et(t >= r.length, "padding exceeds data length", "BUFFER_OVERRUN", {
    buffer: new Uint8Array(r),
    length: t,
    offset: t + 1
  });
  const i = new Uint8Array(t);
  return i.fill(0), e ? i.set(r, t - r.length) : i.set(r, 0), ut(i);
}
function fs(n, t) {
  return tg(n, t, !0);
}
function Cb(n, t) {
  return tg(n, t, !1);
}
const V_ = BigInt(0), lr = BigInt(1), ks = 9007199254740991;
function Ib(n, t) {
  const e = j_(n, "value"), r = BigInt(Rt(t, "width"));
  if (et(e >> r === V_, "overflow", "NUMERIC_FAULT", {
    operation: "fromTwos",
    fault: "overflow",
    value: n
  }), e >> r - lr) {
    const i = (lr << r) - lr;
    return -((~e & i) + lr);
  }
  return e;
}
function eg(n, t) {
  let e = ht(n, "value");
  const r = BigInt(Rt(t, "width")), i = lr << r - lr;
  if (e < V_) {
    e = -e, et(e <= i, "too low", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: n
    });
    const s = (lr << r) - lr;
    return (~e & s) + lr;
  } else
    et(e < i, "too high", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: n
    });
  return e;
}
function Da(n, t) {
  const e = j_(n, "value"), r = BigInt(Rt(t, "bits"));
  return e & (lr << r) - lr;
}
function ht(n, t) {
  switch (typeof n) {
    case "bigint":
      return n;
    case "number":
      return T(Number.isInteger(n), "underflow", t || "value", n), T(n >= -ks && n <= ks, "overflow", t || "value", n), BigInt(n);
    case "string":
      try {
        if (n === "")
          throw new Error("empty string");
        return n[0] === "-" && n[1] !== "-" ? -BigInt(n.substring(1)) : BigInt(n);
      } catch (e) {
        T(!1, `invalid BigNumberish string: ${e.message}`, t || "value", n);
      }
  }
  T(!1, "invalid BigNumberish value", t || "value", n);
}
function j_(n, t) {
  const e = ht(n, t);
  return et(e >= V_, "unsigned value cannot be negative", "NUMERIC_FAULT", {
    fault: "overflow",
    operation: "getUint",
    value: n
  }), e;
}
const gh = "0123456789abcdef";
function Nf(n) {
  if (n instanceof Uint8Array) {
    let t = "0x0";
    for (const e of n)
      t += gh[e >> 4], t += gh[e & 15];
    return BigInt(t);
  }
  return ht(n);
}
function Rt(n, t) {
  switch (typeof n) {
    case "bigint":
      return T(n >= -ks && n <= ks, "overflow", t || "value", n), Number(n);
    case "number":
      return T(Number.isInteger(n), "underflow", t || "value", n), T(n >= -ks && n <= ks, "overflow", t || "value", n), n;
    case "string":
      try {
        if (n === "")
          throw new Error("empty string");
        return Rt(BigInt(n), t);
      } catch (e) {
        T(!1, `invalid numeric string: ${e.message}`, t || "value", n);
      }
  }
  T(!1, "invalid numeric value", t || "value", n);
}
function Nb(n) {
  return Rt(Nf(n));
}
function di(n, t) {
  let r = j_(n, "value").toString(16);
  if (t == null)
    r.length % 2 && (r = "0" + r);
  else {
    const i = Rt(t, "width");
    for (et(i * 2 >= r.length, `value exceeds width (${i} bytes)`, "NUMERIC_FAULT", {
      operation: "toBeHex",
      fault: "overflow",
      value: n
    }); r.length < i * 2; )
      r = "0" + r;
  }
  return "0x" + r;
}
function me(n) {
  const t = j_(n, "value");
  if (t === V_)
    return new Uint8Array([]);
  let e = t.toString(16);
  e.length % 2 && (e = "0" + e);
  const r = new Uint8Array(e.length / 2);
  for (let i = 0; i < r.length; i++) {
    const s = i * 2;
    r[i] = parseInt(e.substring(s, s + 2), 16);
  }
  return r;
}
function Us(n) {
  let t = ut(If(n) ? n : me(n)).substring(2);
  for (; t.startsWith("0"); )
    t = t.substring(1);
  return t === "" && (t = "0"), "0x" + t;
}
const yh = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
BigInt(0);
const bh = BigInt(58);
function Ob(n) {
  const t = Tt(n);
  let e = Nf(t), r = "";
  for (; e; )
    r = yh[Number(e % bh)] + r, e /= bh;
  for (let i = 0; i < t.length && !t[i]; i++)
    r = yh[0] + r;
  return r;
}
function Tb(n) {
  n = atob(n);
  const t = new Uint8Array(n.length);
  for (let e = 0; e < n.length; e++)
    t[e] = n.charCodeAt(e);
  return Tt(t);
}
function zb(n) {
  const t = Tt(n);
  let e = "";
  for (let r = 0; r < t.length; r++)
    e += String.fromCharCode(t[r]);
  return btoa(e);
}
var Oo;
class rg {
  /**
   *  Create a new **EventPayload** for %%emitter%% with
   *  the %%listener%% and for %%filter%%.
   */
  constructor(t, e, r) {
    /**
     *  The event filter.
     */
    U(this, "filter");
    /**
     *  The **EventEmitterable**.
     */
    U(this, "emitter");
    j(this, Oo);
    P(this, Oo, e), gt(this, { emitter: t, filter: r });
  }
  /**
   *  Unregister the triggered listener for future events.
   */
  async removeListener() {
    w(this, Oo) != null && await this.emitter.off(this.filter, w(this, Oo));
  }
}
Oo = new WeakMap();
function kb(n, t, e, r, i) {
  T(!1, `invalid codepoint at offset ${t}; ${n}`, "bytes", e);
}
function ng(n, t, e, r, i) {
  if (n === "BAD_PREFIX" || n === "UNEXPECTED_CONTINUE") {
    let s = 0;
    for (let a = t + 1; a < e.length && e[a] >> 6 === 2; a++)
      s++;
    return s;
  }
  return n === "OVERRUN" ? e.length - t - 1 : 0;
}
function Ub(n, t, e, r, i) {
  return n === "OVERLONG" ? (T(typeof i == "number", "invalid bad code point for replacement", "badCodepoint", i), r.push(i), 0) : (r.push(65533), ng(n, t, e));
}
const Fb = Object.freeze({
  error: kb,
  ignore: ng,
  replace: Ub
});
function Gb(n, t) {
  t == null && (t = Fb.error);
  const e = Tt(n, "bytes"), r = [];
  let i = 0;
  for (; i < e.length; ) {
    const s = e[i++];
    if (!(s >> 7)) {
      r.push(s);
      continue;
    }
    let a = null, c = null;
    if ((s & 224) === 192)
      a = 1, c = 127;
    else if ((s & 240) === 224)
      a = 2, c = 2047;
    else if ((s & 248) === 240)
      a = 3, c = 65535;
    else {
      (s & 192) === 128 ? i += t("UNEXPECTED_CONTINUE", i - 1, e, r) : i += t("BAD_PREFIX", i - 1, e, r);
      continue;
    }
    if (i - 1 + a >= e.length) {
      i += t("OVERRUN", i - 1, e, r);
      continue;
    }
    let _ = s & (1 << 8 - a - 1) - 1;
    for (let p = 0; p < a; p++) {
      let f = e[i];
      if ((f & 192) != 128) {
        i += t("MISSING_CONTINUE", i, e, r), _ = null;
        break;
      }
      _ = _ << 6 | f & 63, i++;
    }
    if (_ !== null) {
      if (_ > 1114111) {
        i += t("OUT_OF_RANGE", i - 1 - a, e, r, _);
        continue;
      }
      if (_ >= 55296 && _ <= 57343) {
        i += t("UTF16_SURROGATE", i - 1 - a, e, r, _);
        continue;
      }
      if (_ <= c) {
        i += t("OVERLONG", i - 1 - a, e, r, _);
        continue;
      }
      r.push(_);
    }
  }
  return r;
}
function On(n, t) {
  T(typeof n == "string", "invalid string value", "str", n);
  let e = [];
  for (let r = 0; r < n.length; r++) {
    const i = n.charCodeAt(r);
    if (i < 128)
      e.push(i);
    else if (i < 2048)
      e.push(i >> 6 | 192), e.push(i & 63 | 128);
    else if ((i & 64512) == 55296) {
      r++;
      const s = n.charCodeAt(r);
      T(r < n.length && (s & 64512) === 56320, "invalid surrogate pair", "str", n);
      const a = 65536 + ((i & 1023) << 10) + (s & 1023);
      e.push(a >> 18 | 240), e.push(a >> 12 & 63 | 128), e.push(a >> 6 & 63 | 128), e.push(a & 63 | 128);
    } else
      e.push(i >> 12 | 224), e.push(i >> 6 & 63 | 128), e.push(i & 63 | 128);
  }
  return new Uint8Array(e);
}
function Lb(n) {
  return n.map((t) => t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode((t >> 10 & 1023) + 55296, (t & 1023) + 56320))).join("");
}
function d_(n, t) {
  return Lb(Gb(n, t));
}
function ig(n) {
  async function t(e, r) {
    et(r == null || !r.cancelled, "request cancelled before sending", "CANCELLED");
    const i = e.url.split(":")[0].toLowerCase();
    et(i === "http" || i === "https", `unsupported protocol ${i}`, "UNSUPPORTED_OPERATION", {
      info: { protocol: i },
      operation: "request"
    }), et(i === "https" || !e.credentials || e.allowInsecureAuthentication, "insecure authorized connections unsupported", "UNSUPPORTED_OPERATION", {
      operation: "request"
    });
    let s = null;
    const a = new AbortController(), c = setTimeout(() => {
      s = Wt("request timeout", "TIMEOUT"), a.abort();
    }, e.timeout);
    r && r.addListener(() => {
      s = Wt("request cancelled", "CANCELLED"), a.abort();
    });
    const _ = {
      method: e.method,
      headers: new Headers(Array.from(e)),
      body: e.body || void 0,
      signal: a.signal
    };
    let p;
    try {
      p = await fetch(e.url, _);
    } catch (b) {
      throw clearTimeout(c), s || b;
    }
    clearTimeout(c);
    const f = {};
    p.headers.forEach((b, v) => {
      f[v.toLowerCase()] = b;
    });
    const d = await p.arrayBuffer(), y = d == null ? null : new Uint8Array(d);
    return {
      statusCode: p.status,
      statusMessage: p.statusText,
      headers: f,
      body: y
    };
  }
  return t;
}
const Db = 12, Kb = 250;
let Ah = ig();
const Vb = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i"), jb = new RegExp("^ipfs://(ipfs/)?(.*)$", "i");
let ql = !1;
async function sg(n, t) {
  try {
    const e = n.match(Vb);
    if (!e)
      throw new Error("invalid data");
    return new fi(200, "OK", {
      "content-type": e[1] || "text/plain"
    }, e[2] ? Tb(e[3]) : Yb(e[3]));
  } catch {
    return new fi(599, "BAD REQUEST (invalid data: URI)", {}, null, new kn(n));
  }
}
function og(n) {
  async function t(e, r) {
    try {
      const i = e.match(jb);
      if (!i)
        throw new Error("invalid link");
      return new kn(`${n}${i[2]}`);
    } catch {
      return new fi(599, "BAD REQUEST (invalid IPFS URI)", {}, null, new kn(e));
    }
  }
  return t;
}
const Fc = {
  data: sg,
  ipfs: og("https://gateway.ipfs.io/ipfs/")
}, ag = /* @__PURE__ */ new WeakMap();
var Di, Jn;
class Hb {
  constructor(t) {
    j(this, Di);
    j(this, Jn);
    P(this, Di, []), P(this, Jn, !1), ag.set(t, () => {
      if (!w(this, Jn)) {
        P(this, Jn, !0);
        for (const e of w(this, Di))
          setTimeout(() => {
            e();
          }, 0);
        P(this, Di, []);
      }
    });
  }
  addListener(t) {
    et(!w(this, Jn), "singal already cancelled", "UNSUPPORTED_OPERATION", {
      operation: "fetchCancelSignal.addCancelListener"
    }), w(this, Di).push(t);
  }
  get cancelled() {
    return w(this, Jn);
  }
  checkSignal() {
    et(!this.cancelled, "cancelled", "CANCELLED", {});
  }
}
Di = new WeakMap(), Jn = new WeakMap();
function Gc(n) {
  if (n == null)
    throw new Error("missing signal; should not happen");
  return n.checkSignal(), n;
}
var To, zo, or, yn, ko, Uo, se, Te, bn, Ki, Vi, ji, Sr, ar, $n, Hi, Ka;
const T_ = class T_ {
  /**
   *  Create a new FetchRequest instance with default values.
   *
   *  Once created, each property may be set before issuing a
   *  ``.send()`` to make the request.
   */
  constructor(t) {
    j(this, Hi);
    j(this, To);
    j(this, zo);
    j(this, or);
    j(this, yn);
    j(this, ko);
    j(this, Uo);
    j(this, se);
    j(this, Te);
    j(this, bn);
    // Hooks
    j(this, Ki);
    j(this, Vi);
    j(this, ji);
    j(this, Sr);
    j(this, ar);
    j(this, $n);
    P(this, Uo, String(t)), P(this, To, !1), P(this, zo, !0), P(this, or, {}), P(this, yn, ""), P(this, ko, 3e5), P(this, ar, {
      slotInterval: Kb,
      maxAttempts: Db
    }), P(this, $n, null);
  }
  /**
   *  The fetch URL to request.
   */
  get url() {
    return w(this, Uo);
  }
  set url(t) {
    P(this, Uo, String(t));
  }
  /**
   *  The fetch body, if any, to send as the request body. //(default: null)//
   *
   *  When setting a body, the intrinsic ``Content-Type`` is automatically
   *  set and will be used if **not overridden** by setting a custom
   *  header.
   *
   *  If %%body%% is null, the body is cleared (along with the
   *  intrinsic ``Content-Type``).
   *
   *  If %%body%% is a string, the intrinsic ``Content-Type`` is set to
   *  ``text/plain``.
   *
   *  If %%body%% is a Uint8Array, the intrinsic ``Content-Type`` is set to
   *  ``application/octet-stream``.
   *
   *  If %%body%% is any other object, the intrinsic ``Content-Type`` is
   *  set to ``application/json``.
   */
  get body() {
    return w(this, se) == null ? null : new Uint8Array(w(this, se));
  }
  set body(t) {
    if (t == null)
      P(this, se, void 0), P(this, Te, void 0);
    else if (typeof t == "string")
      P(this, se, On(t)), P(this, Te, "text/plain");
    else if (t instanceof Uint8Array)
      P(this, se, t), P(this, Te, "application/octet-stream");
    else if (typeof t == "object")
      P(this, se, On(JSON.stringify(t))), P(this, Te, "application/json");
    else
      throw new Error("invalid body");
  }
  /**
   *  Returns true if the request has a body.
   */
  hasBody() {
    return w(this, se) != null;
  }
  /**
   *  The HTTP method to use when requesting the URI. If no method
   *  has been explicitly set, then ``GET`` is used if the body is
   *  null and ``POST`` otherwise.
   */
  get method() {
    return w(this, yn) ? w(this, yn) : this.hasBody() ? "POST" : "GET";
  }
  set method(t) {
    t == null && (t = ""), P(this, yn, String(t).toUpperCase());
  }
  /**
   *  The headers that will be used when requesting the URI. All
   *  keys are lower-case.
   *
   *  This object is a copy, so any changes will **NOT** be reflected
   *  in the ``FetchRequest``.
   *
   *  To set a header entry, use the ``setHeader`` method.
   */
  get headers() {
    const t = Object.assign({}, w(this, or));
    return w(this, bn) && (t.authorization = `Basic ${zb(On(w(this, bn)))}`), this.allowGzip && (t["accept-encoding"] = "gzip"), t["content-type"] == null && w(this, Te) && (t["content-type"] = w(this, Te)), this.body && (t["content-length"] = String(this.body.length)), t;
  }
  /**
   *  Get the header for %%key%%, ignoring case.
   */
  getHeader(t) {
    return this.headers[t.toLowerCase()];
  }
  /**
   *  Set the header for %%key%% to %%value%%. All values are coerced
   *  to a string.
   */
  setHeader(t, e) {
    w(this, or)[String(t).toLowerCase()] = String(e);
  }
  /**
   *  Clear all headers, resetting all intrinsic headers.
   */
  clearHeaders() {
    P(this, or, {});
  }
  [Symbol.iterator]() {
    const t = this.headers, e = Object.keys(t);
    let r = 0;
    return {
      next: () => {
        if (r < e.length) {
          const i = e[r++];
          return {
            value: [i, t[i]],
            done: !1
          };
        }
        return { value: void 0, done: !0 };
      }
    };
  }
  /**
   *  The value that will be sent for the ``Authorization`` header.
   *
   *  To set the credentials, use the ``setCredentials`` method.
   */
  get credentials() {
    return w(this, bn) || null;
  }
  /**
   *  Sets an ``Authorization`` for %%username%% with %%password%%.
   */
  setCredentials(t, e) {
    T(!t.match(/:/), "invalid basic authentication username", "username", "[REDACTED]"), P(this, bn, `${t}:${e}`);
  }
  /**
   *  Enable and request gzip-encoded responses. The response will
   *  automatically be decompressed. //(default: true)//
   */
  get allowGzip() {
    return w(this, zo);
  }
  set allowGzip(t) {
    P(this, zo, !!t);
  }
  /**
   *  Allow ``Authentication`` credentials to be sent over insecure
   *  channels. //(default: false)//
   */
  get allowInsecureAuthentication() {
    return !!w(this, To);
  }
  set allowInsecureAuthentication(t) {
    P(this, To, !!t);
  }
  /**
   *  The timeout (in milliseconds) to wait for a complete response.
   *  //(default: 5 minutes)//
   */
  get timeout() {
    return w(this, ko);
  }
  set timeout(t) {
    T(t >= 0, "timeout must be non-zero", "timeout", t), P(this, ko, t);
  }
  /**
   *  This function is called prior to each request, for example
   *  during a redirection or retry in case of server throttling.
   *
   *  This offers an opportunity to populate headers or update
   *  content before sending a request.
   */
  get preflightFunc() {
    return w(this, Ki) || null;
  }
  set preflightFunc(t) {
    P(this, Ki, t);
  }
  /**
   *  This function is called after each response, offering an
   *  opportunity to provide client-level throttling or updating
   *  response data.
   *
   *  Any error thrown in this causes the ``send()`` to throw.
   *
   *  To schedule a retry attempt (assuming the maximum retry limit
   *  has not been reached), use [[response.throwThrottleError]].
   */
  get processFunc() {
    return w(this, Vi) || null;
  }
  set processFunc(t) {
    P(this, Vi, t);
  }
  /**
   *  This function is called on each retry attempt.
   */
  get retryFunc() {
    return w(this, ji) || null;
  }
  set retryFunc(t) {
    P(this, ji, t);
  }
  /**
   *  This function is called to fetch content from HTTP and
   *  HTTPS URLs and is platform specific (e.g. nodejs vs
   *  browsers).
   *
   *  This is by default the currently registered global getUrl
   *  function, which can be changed using [[registerGetUrl]].
   *  If this has been set, setting is to ``null`` will cause
   *  this FetchRequest (and any future clones) to revert back to
   *  using the currently registered global getUrl function.
   *
   *  Setting this is generally not necessary, but may be useful
   *  for developers that wish to intercept requests or to
   *  configurege a proxy or other agent.
   */
  get getUrlFunc() {
    return w(this, $n) || Ah;
  }
  set getUrlFunc(t) {
    P(this, $n, t);
  }
  toString() {
    return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${w(this, se) ? ut(w(this, se)) : "null"}>`;
  }
  /**
   *  Update the throttle parameters used to determine maximum
   *  attempts and exponential-backoff properties.
   */
  setThrottleParams(t) {
    t.slotInterval != null && (w(this, ar).slotInterval = t.slotInterval), t.maxAttempts != null && (w(this, ar).maxAttempts = t.maxAttempts);
  }
  /**
   *  Resolves to the response by sending the request.
   */
  send() {
    return et(w(this, Sr) == null, "request already sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.send" }), P(this, Sr, new Hb(this)), ct(this, Hi, Ka).call(this, 0, mh() + this.timeout, 0, this, new fi(0, "", {}, null, this));
  }
  /**
   *  Cancels the inflight response, causing a ``CANCELLED``
   *  error to be rejected from the [[send]].
   */
  cancel() {
    et(w(this, Sr) != null, "request has not been sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.cancel" });
    const t = ag.get(this);
    if (!t)
      throw new Error("missing signal; should not happen");
    t();
  }
  /**
   *  Returns a new [[FetchRequest]] that represents the redirection
   *  to %%location%%.
   */
  redirect(t) {
    const e = this.url.split(":")[0].toLowerCase(), r = t.split(":")[0].toLowerCase();
    et(this.method === "GET" && (e !== "https" || r !== "http") && t.match(/^https?:/), "unsupported redirect", "UNSUPPORTED_OPERATION", {
      operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(t)})`
    });
    const i = new T_(t);
    return i.method = "GET", i.allowGzip = this.allowGzip, i.timeout = this.timeout, P(i, or, Object.assign({}, w(this, or))), w(this, se) && P(i, se, new Uint8Array(w(this, se))), P(i, Te, w(this, Te)), i;
  }
  /**
   *  Create a new copy of this request.
   */
  clone() {
    const t = new T_(this.url);
    return P(t, yn, w(this, yn)), w(this, se) && P(t, se, w(this, se)), P(t, Te, w(this, Te)), P(t, or, Object.assign({}, w(this, or))), P(t, bn, w(this, bn)), this.allowGzip && (t.allowGzip = !0), t.timeout = this.timeout, this.allowInsecureAuthentication && (t.allowInsecureAuthentication = !0), P(t, Ki, w(this, Ki)), P(t, Vi, w(this, Vi)), P(t, ji, w(this, ji)), P(t, ar, Object.assign({}, w(this, ar))), P(t, $n, w(this, $n)), t;
  }
  /**
   *  Locks all static configuration for gateways and FetchGetUrlFunc
   *  registration.
   */
  static lockConfig() {
    ql = !0;
  }
  /**
   *  Get the current Gateway function for %%scheme%%.
   */
  static getGateway(t) {
    return Fc[t.toLowerCase()] || null;
  }
  /**
   *  Use the %%func%% when fetching URIs using %%scheme%%.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGateway(t, e) {
    if (t = t.toLowerCase(), t === "http" || t === "https")
      throw new Error(`cannot intercept ${t}; use registerGetUrl`);
    if (ql)
      throw new Error("gateways locked");
    Fc[t] = e;
  }
  /**
   *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGetUrl(t) {
    if (ql)
      throw new Error("gateways locked");
    Ah = t;
  }
  /**
   *  Creates a getUrl function that fetches content from HTTP and
   *  HTTPS URLs.
   *
   *  The available %%options%% are dependent on the platform
   *  implementation of the default getUrl function.
   *
   *  This is not generally something that is needed, but is useful
   *  when trying to customize simple behaviour when fetching HTTP
   *  content.
   */
  static createGetUrlFunc(t) {
    return ig();
  }
  /**
   *  Creates a function that can "fetch" data URIs.
   *
   *  Note that this is automatically done internally to support
   *  data URIs, so it is not necessary to register it.
   *
   *  This is not generally something that is needed, but may
   *  be useful in a wrapper to perfom custom data URI functionality.
   */
  static createDataGateway() {
    return sg;
  }
  /**
   *  Creates a function that will fetch IPFS (unvalidated) from
   *  a custom gateway baseUrl.
   *
   *  The default IPFS gateway used internally is
   *  ``"https:/\/gateway.ipfs.io/ipfs/"``.
   */
  static createIpfsGatewayFunc(t) {
    return og(t);
  }
};
To = new WeakMap(), zo = new WeakMap(), or = new WeakMap(), yn = new WeakMap(), ko = new WeakMap(), Uo = new WeakMap(), se = new WeakMap(), Te = new WeakMap(), bn = new WeakMap(), Ki = new WeakMap(), Vi = new WeakMap(), ji = new WeakMap(), Sr = new WeakMap(), ar = new WeakMap(), $n = new WeakMap(), Hi = new WeakSet(), Ka = async function(t, e, r, i, s) {
  var f, d, y;
  if (t >= w(this, ar).maxAttempts)
    return s.makeServerError("exceeded maximum retry limit");
  et(mh() <= e, "timeout", "TIMEOUT", {
    operation: "request.send",
    reason: "timeout",
    request: i
  }), r > 0 && await Qb(r);
  let a = this.clone();
  const c = (a.url.split(":")[0] || "").toLowerCase();
  if (c in Fc) {
    const b = await Fc[c](a.url, Gc(w(i, Sr)));
    if (b instanceof fi) {
      let v = b;
      if (this.processFunc) {
        Gc(w(i, Sr));
        try {
          v = await this.processFunc(a, v);
        } catch (R) {
          (R.throttle == null || typeof R.stall != "number") && v.makeServerError("error in post-processing function", R).assertOk();
        }
      }
      return v;
    }
    a = b;
  }
  this.preflightFunc && (a = await this.preflightFunc(a));
  const _ = await this.getUrlFunc(a, Gc(w(i, Sr)));
  let p = new fi(_.statusCode, _.statusMessage, _.headers, _.body, i);
  if (p.statusCode === 301 || p.statusCode === 302) {
    try {
      const b = p.headers.location || "";
      return ct(f = a.redirect(b), Hi, Ka).call(f, t + 1, e, 0, i, p);
    } catch {
    }
    return p;
  } else if (p.statusCode === 429 && (this.retryFunc == null || await this.retryFunc(a, p, t))) {
    const b = p.headers["retry-after"];
    let v = w(this, ar).slotInterval * Math.trunc(Math.random() * Math.pow(2, t));
    return typeof b == "string" && b.match(/^[1-9][0-9]*$/) && (v = parseInt(b)), ct(d = a.clone(), Hi, Ka).call(d, t + 1, e, v, i, p);
  }
  if (this.processFunc) {
    Gc(w(i, Sr));
    try {
      p = await this.processFunc(a, p);
    } catch (b) {
      (b.throttle == null || typeof b.stall != "number") && p.makeServerError("error in post-processing function", b).assertOk();
      let v = w(this, ar).slotInterval * Math.trunc(Math.random() * Math.pow(2, t));
      return b.stall >= 0 && (v = b.stall), ct(y = a.clone(), Hi, Ka).call(y, t + 1, e, v, i, p);
    }
  }
  return p;
};
let kn = T_;
var dc, wc, gc, ze, Fo, Yi;
const fh = class fh {
  constructor(t, e, r, i, s) {
    j(this, dc);
    j(this, wc);
    j(this, gc);
    j(this, ze);
    j(this, Fo);
    j(this, Yi);
    P(this, dc, t), P(this, wc, e), P(this, gc, Object.keys(r).reduce((a, c) => (a[c.toLowerCase()] = String(r[c]), a), {})), P(this, ze, i == null ? null : new Uint8Array(i)), P(this, Fo, s || null), P(this, Yi, { message: "" });
  }
  toString() {
    return `<FetchResponse status=${this.statusCode} body=${w(this, ze) ? ut(w(this, ze)) : "null"}>`;
  }
  /**
   *  The response status code.
   */
  get statusCode() {
    return w(this, dc);
  }
  /**
   *  The response status message.
   */
  get statusMessage() {
    return w(this, wc);
  }
  /**
   *  The response headers. All keys are lower-case.
   */
  get headers() {
    return Object.assign({}, w(this, gc));
  }
  /**
   *  The response body, or ``null`` if there was no body.
   */
  get body() {
    return w(this, ze) == null ? null : new Uint8Array(w(this, ze));
  }
  /**
   *  The response body as a UTF-8 encoded string, or the empty
   *  string (i.e. ``""``) if there was no body.
   *
   *  An error is thrown if the body is invalid UTF-8 data.
   */
  get bodyText() {
    try {
      return w(this, ze) == null ? "" : d_(w(this, ze));
    } catch {
      et(!1, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
        operation: "bodyText",
        info: { response: this }
      });
    }
  }
  /**
   *  The response body, decoded as JSON.
   *
   *  An error is thrown if the body is invalid JSON-encoded data
   *  or if there was no body.
   */
  get bodyJson() {
    try {
      return JSON.parse(this.bodyText);
    } catch {
      et(!1, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
        operation: "bodyJson",
        info: { response: this }
      });
    }
  }
  [Symbol.iterator]() {
    const t = this.headers, e = Object.keys(t);
    let r = 0;
    return {
      next: () => {
        if (r < e.length) {
          const i = e[r++];
          return {
            value: [i, t[i]],
            done: !1
          };
        }
        return { value: void 0, done: !0 };
      }
    };
  }
  /**
   *  Return a Response with matching headers and body, but with
   *  an error status code (i.e. 599) and %%message%% with an
   *  optional %%error%%.
   */
  makeServerError(t, e) {
    let r;
    t ? r = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${t})` : (t = `${this.statusCode} ${this.statusMessage}`, r = `CLIENT ESCALATED SERVER ERROR (${t})`);
    const i = new fh(599, r, this.headers, this.body, w(this, Fo) || void 0);
    return P(i, Yi, { message: t, error: e }), i;
  }
  /**
   *  If called within a [request.processFunc](FetchRequest-processFunc)
   *  call, causes the request to retry as if throttled for %%stall%%
   *  milliseconds.
   */
  throwThrottleError(t, e) {
    e == null ? e = -1 : T(Number.isInteger(e) && e >= 0, "invalid stall timeout", "stall", e);
    const r = new Error(t || "throttling requests");
    throw gt(r, { stall: e, throttle: !0 }), r;
  }
  /**
   *  Get the header value for %%key%%, ignoring case.
   */
  getHeader(t) {
    return this.headers[t.toLowerCase()];
  }
  /**
   *  Returns true if the response has a body.
   */
  hasBody() {
    return w(this, ze) != null;
  }
  /**
   *  The request made for this response.
   */
  get request() {
    return w(this, Fo);
  }
  /**
   *  Returns true if this response was a success statusCode.
   */
  ok() {
    return w(this, Yi).message === "" && this.statusCode >= 200 && this.statusCode < 300;
  }
  /**
   *  Throws a ``SERVER_ERROR`` if this response is not ok.
   */
  assertOk() {
    if (this.ok())
      return;
    let { message: t, error: e } = w(this, Yi);
    t === "" && (t = `server response ${this.statusCode} ${this.statusMessage}`);
    let r = null;
    this.request && (r = this.request.url);
    let i = null;
    try {
      w(this, ze) && (i = d_(w(this, ze)));
    } catch {
    }
    et(!1, t, "SERVER_ERROR", {
      request: this.request || "unknown request",
      response: this,
      error: e,
      info: {
        requestUrl: r,
        responseBody: i,
        responseStatus: `${this.statusCode} ${this.statusMessage}`
      }
    });
  }
};
dc = new WeakMap(), wc = new WeakMap(), gc = new WeakMap(), ze = new WeakMap(), Fo = new WeakMap(), Yi = new WeakMap();
let fi = fh;
function mh() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function Yb(n) {
  return On(n.replace(/%([0-9a-f][0-9a-f])/gi, (t, e) => String.fromCharCode(parseInt(e, 16))));
}
function Qb(n) {
  return new Promise((t) => setTimeout(t, n));
}
function Wb(n) {
  let t = n.toString(16);
  for (; t.length < 2; )
    t = "0" + t;
  return "0x" + t;
}
function Sh(n, t, e) {
  let r = 0;
  for (let i = 0; i < e; i++)
    r = r * 256 + n[t + i];
  return r;
}
function Eh(n, t, e, r) {
  const i = [];
  for (; e < t + 1 + r; ) {
    const s = cg(n, e);
    i.push(s.result), e += s.consumed, et(e <= t + 1 + r, "child data too short", "BUFFER_OVERRUN", {
      buffer: n,
      length: r,
      offset: t
    });
  }
  return { consumed: 1 + r, result: i };
}
function cg(n, t) {
  et(n.length !== 0, "data too short", "BUFFER_OVERRUN", {
    buffer: n,
    length: 0,
    offset: 1
  });
  const e = (r) => {
    et(r <= n.length, "data short segment too short", "BUFFER_OVERRUN", {
      buffer: n,
      length: n.length,
      offset: r
    });
  };
  if (n[t] >= 248) {
    const r = n[t] - 247;
    e(t + 1 + r);
    const i = Sh(n, t + 1, r);
    return e(t + 1 + r + i), Eh(n, t, t + 1 + r, r + i);
  } else if (n[t] >= 192) {
    const r = n[t] - 192;
    return e(t + 1 + r), Eh(n, t, t + 1, r);
  } else if (n[t] >= 184) {
    const r = n[t] - 183;
    e(t + 1 + r);
    const i = Sh(n, t + 1, r);
    e(t + 1 + r + i);
    const s = ut(n.slice(t + 1 + r, t + 1 + r + i));
    return { consumed: 1 + r + i, result: s };
  } else if (n[t] >= 128) {
    const r = n[t] - 128;
    e(t + 1 + r);
    const i = ut(n.slice(t + 1, t + 1 + r));
    return { consumed: 1 + r, result: i };
  }
  return { consumed: 1, result: Wb(n[t]) };
}
function H_(n) {
  const t = Tt(n, "data"), e = cg(t, 0);
  return T(e.consumed === t.length, "unexpected junk after rlp payload", "data", n), e.result;
}
function Rh(n) {
  const t = [];
  for (; n; )
    t.unshift(n & 255), n >>= 8;
  return t;
}
function _g(n) {
  if (Array.isArray(n)) {
    let r = [];
    if (n.forEach(function(s) {
      r = r.concat(_g(s));
    }), r.length <= 55)
      return r.unshift(192 + r.length), r;
    const i = Rh(r.length);
    return i.unshift(247 + i.length), i.concat(r);
  }
  const t = Array.prototype.slice.call(Tt(n, "object"));
  if (t.length === 1 && t[0] <= 127)
    return t;
  if (t.length <= 55)
    return t.unshift(128 + t.length), t;
  const e = Rh(t.length);
  return e.unshift(183 + e.length), e.concat(t);
}
const Ph = "0123456789abcdef";
function hs(n) {
  let t = "0x";
  for (const e of _g(n))
    t += Ph[e >> 4], t += Ph[e & 15];
  return t;
}
const Se = 32, ku = new Uint8Array(Se), Jb = ["then"], Lc = {}, lg = /* @__PURE__ */ new WeakMap();
function Ri(n) {
  return lg.get(n);
}
function vh(n, t) {
  lg.set(n, t);
}
function Fa(n, t) {
  const e = new Error(`deferred error during ABI decoding triggered accessing ${n}`);
  throw e.error = t, e;
}
function Uu(n, t, e) {
  return n.indexOf(null) >= 0 ? t.map((r, i) => r instanceof Aa ? Uu(Ri(r), r, e) : r) : n.reduce((r, i, s) => {
    let a = t.getValue(i);
    return i in r || (e && a instanceof Aa && (a = Uu(Ri(a), a, e)), r[i] = a), r;
  }, {});
}
var Go;
const bo = class bo extends Array {
  /**
   *  @private
   */
  constructor(...e) {
    const r = e[0];
    let i = e[1], s = (e[2] || []).slice(), a = !0;
    r !== Lc && (i = e, s = [], a = !1);
    super(i.length);
    // No longer used; but cannot be removed as it will remove the
    // #private field from the .d.ts which may break backwards
    // compatibility
    j(this, Go);
    i.forEach((p, f) => {
      this[f] = p;
    });
    const c = s.reduce((p, f) => (typeof f == "string" && p.set(f, (p.get(f) || 0) + 1), p), /* @__PURE__ */ new Map());
    if (vh(this, Object.freeze(i.map((p, f) => {
      const d = s[f];
      return d != null && c.get(d) === 1 ? d : null;
    }))), P(this, Go, []), w(this, Go) == null && w(this, Go), !a)
      return;
    Object.freeze(this);
    const _ = new Proxy(this, {
      get: (p, f, d) => {
        if (typeof f == "string") {
          if (f.match(/^[0-9]+$/)) {
            const b = Rt(f, "%index");
            if (b < 0 || b >= this.length)
              throw new RangeError("out of result range");
            const v = p[b];
            return v instanceof Error && Fa(`index ${b}`, v), v;
          }
          if (Jb.indexOf(f) >= 0)
            return Reflect.get(p, f, d);
          const y = p[f];
          if (y instanceof Function)
            return function(...b) {
              return y.apply(this === d ? p : this, b);
            };
          if (!(f in p))
            return p.getValue.apply(this === d ? p : this, [f]);
        }
        return Reflect.get(p, f, d);
      }
    });
    return vh(_, Ri(this)), _;
  }
  /**
   *  Returns the Result as a normal Array. If %%deep%%, any children
   *  which are Result objects are also converted to a normal Array.
   *
   *  This will throw if there are any outstanding deferred
   *  errors.
   */
  toArray(e) {
    const r = [];
    return this.forEach((i, s) => {
      i instanceof Error && Fa(`index ${s}`, i), e && i instanceof bo && (i = i.toArray(e)), r.push(i);
    }), r;
  }
  /**
   *  Returns the Result as an Object with each name-value pair. If
   *  %%deep%%, any children which are Result objects are also
   *  converted to an Object.
   *
   *  This will throw if any value is unnamed, or if there are
   *  any outstanding deferred errors.
   */
  toObject(e) {
    const r = Ri(this);
    return r.reduce((i, s, a) => (et(s != null, `value at index ${a} unnamed`, "UNSUPPORTED_OPERATION", {
      operation: "toObject()"
    }), Uu(r, this, e)), {});
  }
  /**
   *  @_ignore
   */
  slice(e, r) {
    e == null && (e = 0), e < 0 && (e += this.length, e < 0 && (e = 0)), r == null && (r = this.length), r < 0 && (r += this.length, r < 0 && (r = 0)), r > this.length && (r = this.length);
    const i = Ri(this), s = [], a = [];
    for (let c = e; c < r; c++)
      s.push(this[c]), a.push(i[c]);
    return new bo(Lc, s, a);
  }
  /**
   *  @_ignore
   */
  filter(e, r) {
    const i = Ri(this), s = [], a = [];
    for (let c = 0; c < this.length; c++) {
      const _ = this[c];
      _ instanceof Error && Fa(`index ${c}`, _), e.call(r, _, c, this) && (s.push(_), a.push(i[c]));
    }
    return new bo(Lc, s, a);
  }
  /**
   *  @_ignore
   */
  map(e, r) {
    const i = [];
    for (let s = 0; s < this.length; s++) {
      const a = this[s];
      a instanceof Error && Fa(`index ${s}`, a), i.push(e.call(r, a, s, this));
    }
    return i;
  }
  /**
   *  Returns the value for %%name%%.
   *
   *  Since it is possible to have a key whose name conflicts with
   *  a method on a [[Result]] or its superclass Array, or any
   *  JavaScript keyword, this ensures all named values are still
   *  accessible by name.
   */
  getValue(e) {
    const r = Ri(this).indexOf(e);
    if (r === -1)
      return;
    const i = this[r];
    return i instanceof Error && Fa(`property ${JSON.stringify(e)}`, i.error), i;
  }
  /**
   *  Creates a new [[Result]] for %%items%% with each entry
   *  also accessible by its corresponding name in %%keys%%.
   */
  static fromItems(e, r) {
    return new bo(Lc, e, r);
  }
};
Go = new WeakMap();
let Aa = bo;
function Mh(n) {
  let t = me(n);
  return et(t.length <= Se, "value out-of-bounds", "BUFFER_OVERRUN", { buffer: t, length: Se, offset: t.length }), t.length !== Se && (t = Ae(Xt([ku.slice(t.length % Se), t]))), t;
}
class Ln {
  constructor(t, e, r, i) {
    // The coder name:
    //   - address, uint256, tuple, array, etc.
    U(this, "name");
    // The fully expanded type, including composite types:
    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.
    U(this, "type");
    // The localName bound in the signature, in this example it is "baz":
    //   - tuple(address foo, uint bar) baz
    U(this, "localName");
    // Whether this type is dynamic:
    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.
    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)
    U(this, "dynamic");
    gt(this, { name: t, type: e, localName: r, dynamic: i }, {
      name: "string",
      type: "string",
      localName: "string",
      dynamic: "boolean"
    });
  }
  _throwError(t, e) {
    T(!1, t, this.localName, e);
  }
}
var An, Qi, Lo, Jc;
class Fu {
  constructor() {
    j(this, Lo);
    // An array of WordSize lengthed objects to concatenation
    j(this, An);
    j(this, Qi);
    P(this, An, []), P(this, Qi, 0);
  }
  get data() {
    return Xt(w(this, An));
  }
  get length() {
    return w(this, Qi);
  }
  appendWriter(t) {
    return ct(this, Lo, Jc).call(this, Ae(t.data));
  }
  // Arrayish item; pad on the right to *nearest* WordSize
  writeBytes(t) {
    let e = Ae(t);
    const r = e.length % Se;
    return r && (e = Ae(Xt([e, ku.slice(r)]))), ct(this, Lo, Jc).call(this, e);
  }
  // Numeric item; pad on the left *to* WordSize
  writeValue(t) {
    return ct(this, Lo, Jc).call(this, Mh(t));
  }
  // Inserts a numeric place-holder, returning a callback that can
  // be used to asjust the value later
  writeUpdatableValue() {
    const t = w(this, An).length;
    return w(this, An).push(ku), P(this, Qi, w(this, Qi) + Se), (e) => {
      w(this, An)[t] = Mh(e);
    };
  }
}
An = new WeakMap(), Qi = new WeakMap(), Lo = new WeakSet(), Jc = function(t) {
  return w(this, An).push(t), P(this, Qi, w(this, Qi) + t.length), t.length;
};
var Pe, ke, Wi, Ji, qn, As, Lu, ug;
const hh = class hh {
  constructor(t, e, r) {
    j(this, As);
    // Allows incomplete unpadded data to be read; otherwise an error
    // is raised if attempting to overrun the buffer. This is required
    // to deal with an old Solidity bug, in which event data for
    // external (not public thoguh) was tightly packed.
    U(this, "allowLoose");
    j(this, Pe);
    j(this, ke);
    j(this, Wi);
    j(this, Ji);
    j(this, qn);
    gt(this, { allowLoose: !!e }), P(this, Pe, Ae(t)), P(this, Wi, 0), P(this, Ji, null), P(this, qn, r ?? 1024), P(this, ke, 0);
  }
  get data() {
    return ut(w(this, Pe));
  }
  get dataLength() {
    return w(this, Pe).length;
  }
  get consumed() {
    return w(this, ke);
  }
  get bytes() {
    return new Uint8Array(w(this, Pe));
  }
  // Create a sub-reader with the same underlying data, but offset
  subReader(t) {
    const e = new hh(w(this, Pe).slice(w(this, ke) + t), this.allowLoose, w(this, qn));
    return P(e, Ji, this), e;
  }
  // Read bytes
  readBytes(t, e) {
    let r = ct(this, As, ug).call(this, 0, t, !!e);
    return ct(this, As, Lu).call(this, t), P(this, ke, w(this, ke) + r.length), r.slice(0, t);
  }
  // Read a numeric values
  readValue() {
    return Nf(this.readBytes(Se));
  }
  readIndex() {
    return Nb(this.readBytes(Se));
  }
};
Pe = new WeakMap(), ke = new WeakMap(), Wi = new WeakMap(), Ji = new WeakMap(), qn = new WeakMap(), As = new WeakSet(), Lu = function(t) {
  var e;
  if (w(this, Ji))
    return ct(e = w(this, Ji), As, Lu).call(e, t);
  P(this, Wi, w(this, Wi) + t), et(w(this, qn) < 1 || w(this, Wi) <= w(this, qn) * this.dataLength, `compressed ABI data exceeds inflation ratio of ${w(this, qn)} ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`, "BUFFER_OVERRUN", {
    buffer: Ae(w(this, Pe)),
    offset: w(this, ke),
    length: t,
    info: {
      bytesRead: w(this, Wi),
      dataLength: this.dataLength
    }
  });
}, ug = function(t, e, r) {
  let i = Math.ceil(e / Se) * Se;
  return w(this, ke) + i > w(this, Pe).length && (this.allowLoose && r && w(this, ke) + e <= w(this, Pe).length ? i = e : et(!1, "data out-of-bounds", "BUFFER_OVERRUN", {
    buffer: Ae(w(this, Pe)),
    length: w(this, Pe).length,
    offset: w(this, ke) + i
  })), w(this, Pe).slice(w(this, ke), w(this, ke) + i);
};
let Gu = hh;
function w_(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`Wrong positive integer: ${n}`);
}
function Of(n, ...t) {
  if (!(n instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (t.length > 0 && !t.includes(n.length))
    throw new Error(`Expected Uint8Array of length ${t}, not of length=${n.length}`);
}
function $b(n) {
  if (typeof n != "function" || typeof n.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  w_(n.outputLen), w_(n.blockLen);
}
function ma(n, t = !0) {
  if (n.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && n.finished)
    throw new Error("Hash#digest() has already been called");
}
function fg(n, t) {
  Of(n);
  const e = t.outputLen;
  if (n.length < e)
    throw new Error(`digestInto() expects output buffer of length at least ${e}`);
}
const Zl = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const hg = (n) => n instanceof Uint8Array, qb = (n) => new Uint32Array(n.buffer, n.byteOffset, Math.floor(n.byteLength / 4)), Xl = (n) => new DataView(n.buffer, n.byteOffset, n.byteLength), wr = (n, t) => n << 32 - t | n >>> t, Zb = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!Zb)
  throw new Error("Non little-endian hardware is not supported");
function Xb(n) {
  if (typeof n != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof n}`);
  return new Uint8Array(new TextEncoder().encode(n));
}
function Y_(n) {
  if (typeof n == "string" && (n = Xb(n)), !hg(n))
    throw new Error(`expected Uint8Array, got ${typeof n}`);
  return n;
}
function t1(...n) {
  const t = new Uint8Array(n.reduce((r, i) => r + i.length, 0));
  let e = 0;
  return n.forEach((r) => {
    if (!hg(r))
      throw new Error("Uint8Array expected");
    t.set(r, e), e += r.length;
  }), t;
}
class Tf {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function zf(n) {
  const t = (r) => n().update(Y_(r)).digest(), e = n();
  return t.outputLen = e.outputLen, t.blockLen = e.blockLen, t.create = () => n(), t;
}
function e1(n = 32) {
  if (Zl && typeof Zl.getRandomValues == "function")
    return Zl.getRandomValues(new Uint8Array(n));
  throw new Error("crypto.getRandomValues must be defined");
}
class pg extends Tf {
  constructor(t, e) {
    super(), this.finished = !1, this.destroyed = !1, $b(t);
    const r = Y_(e);
    if (this.iHash = t.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const i = this.blockLen, s = new Uint8Array(i);
    s.set(r.length > i ? t.create().update(r).digest() : r);
    for (let a = 0; a < s.length; a++)
      s[a] ^= 54;
    this.iHash.update(s), this.oHash = t.create();
    for (let a = 0; a < s.length; a++)
      s[a] ^= 106;
    this.oHash.update(s), s.fill(0);
  }
  update(t) {
    return ma(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    ma(this), Of(t, this.outputLen), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: e, iHash: r, finished: i, destroyed: s, blockLen: a, outputLen: c } = this;
    return t = t, t.finished = i, t.destroyed = s, t.blockLen = a, t.outputLen = c, t.oHash = e._cloneInto(t.oHash), t.iHash = r._cloneInto(t.iHash), t;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
}
const dg = (n, t, e) => new pg(n, t).update(e).digest();
dg.create = (n, t) => new pg(n, t);
function r1(n, t, e, r) {
  if (typeof n.setBigUint64 == "function")
    return n.setBigUint64(t, e, r);
  const i = BigInt(32), s = BigInt(4294967295), a = Number(e >> i & s), c = Number(e & s), _ = r ? 4 : 0, p = r ? 0 : 4;
  n.setUint32(t + _, a, r), n.setUint32(t + p, c, r);
}
class wg extends Tf {
  constructor(t, e, r, i) {
    super(), this.blockLen = t, this.outputLen = e, this.padOffset = r, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = Xl(this.buffer);
  }
  update(t) {
    ma(this);
    const { view: e, buffer: r, blockLen: i } = this;
    t = Y_(t);
    const s = t.length;
    for (let a = 0; a < s; ) {
      const c = Math.min(i - this.pos, s - a);
      if (c === i) {
        const _ = Xl(t);
        for (; i <= s - a; a += i)
          this.process(_, a);
        continue;
      }
      r.set(t.subarray(a, a + c), this.pos), this.pos += c, a += c, this.pos === i && (this.process(e, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    ma(this), fg(t, this), this.finished = !0;
    const { buffer: e, view: r, blockLen: i, isLE: s } = this;
    let { pos: a } = this;
    e[a++] = 128, this.buffer.subarray(a).fill(0), this.padOffset > i - a && (this.process(r, 0), a = 0);
    for (let d = a; d < i; d++)
      e[d] = 0;
    r1(r, i - 8, BigInt(this.length * 8), s), this.process(r, 0);
    const c = Xl(t), _ = this.outputLen;
    if (_ % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const p = _ / 4, f = this.get();
    if (p > f.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let d = 0; d < p; d++)
      c.setUint32(4 * d, f[d], s);
  }
  digest() {
    const { buffer: t, outputLen: e } = this;
    this.digestInto(t);
    const r = t.slice(0, e);
    return this.destroy(), r;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: e, buffer: r, length: i, finished: s, destroyed: a, pos: c } = this;
    return t.length = i, t.pos = c, t.finished = s, t.destroyed = a, i % e && t.buffer.set(r), t;
  }
}
const n1 = (n, t, e) => n & t ^ ~n & e, i1 = (n, t, e) => n & t ^ n & e ^ t & e, s1 = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), Kn = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), Vn = /* @__PURE__ */ new Uint32Array(64);
class o1 extends wg {
  constructor() {
    super(64, 32, 8, !1), this.A = Kn[0] | 0, this.B = Kn[1] | 0, this.C = Kn[2] | 0, this.D = Kn[3] | 0, this.E = Kn[4] | 0, this.F = Kn[5] | 0, this.G = Kn[6] | 0, this.H = Kn[7] | 0;
  }
  get() {
    const { A: t, B: e, C: r, D: i, E: s, F: a, G: c, H: _ } = this;
    return [t, e, r, i, s, a, c, _];
  }
  // prettier-ignore
  set(t, e, r, i, s, a, c, _) {
    this.A = t | 0, this.B = e | 0, this.C = r | 0, this.D = i | 0, this.E = s | 0, this.F = a | 0, this.G = c | 0, this.H = _ | 0;
  }
  process(t, e) {
    for (let d = 0; d < 16; d++, e += 4)
      Vn[d] = t.getUint32(e, !1);
    for (let d = 16; d < 64; d++) {
      const y = Vn[d - 15], b = Vn[d - 2], v = wr(y, 7) ^ wr(y, 18) ^ y >>> 3, R = wr(b, 17) ^ wr(b, 19) ^ b >>> 10;
      Vn[d] = R + Vn[d - 7] + v + Vn[d - 16] | 0;
    }
    let { A: r, B: i, C: s, D: a, E: c, F: _, G: p, H: f } = this;
    for (let d = 0; d < 64; d++) {
      const y = wr(c, 6) ^ wr(c, 11) ^ wr(c, 25), b = f + y + n1(c, _, p) + s1[d] + Vn[d] | 0, R = (wr(r, 2) ^ wr(r, 13) ^ wr(r, 22)) + i1(r, i, s) | 0;
      f = p, p = _, _ = c, c = a + b | 0, a = s, s = i, i = r, r = b + R | 0;
    }
    r = r + this.A | 0, i = i + this.B | 0, s = s + this.C | 0, a = a + this.D | 0, c = c + this.E | 0, _ = _ + this.F | 0, p = p + this.G | 0, f = f + this.H | 0, this.set(r, i, s, a, c, _, p, f);
  }
  roundClean() {
    Vn.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
const gg = /* @__PURE__ */ zf(() => new o1()), Dc = /* @__PURE__ */ BigInt(2 ** 32 - 1), Du = /* @__PURE__ */ BigInt(32);
function yg(n, t = !1) {
  return t ? { h: Number(n & Dc), l: Number(n >> Du & Dc) } : { h: Number(n >> Du & Dc) | 0, l: Number(n & Dc) | 0 };
}
function bg(n, t = !1) {
  let e = new Uint32Array(n.length), r = new Uint32Array(n.length);
  for (let i = 0; i < n.length; i++) {
    const { h: s, l: a } = yg(n[i], t);
    [e[i], r[i]] = [s, a];
  }
  return [e, r];
}
const a1 = (n, t) => BigInt(n >>> 0) << Du | BigInt(t >>> 0), c1 = (n, t, e) => n >>> e, _1 = (n, t, e) => n << 32 - e | t >>> e, l1 = (n, t, e) => n >>> e | t << 32 - e, u1 = (n, t, e) => n << 32 - e | t >>> e, f1 = (n, t, e) => n << 64 - e | t >>> e - 32, h1 = (n, t, e) => n >>> e - 32 | t << 64 - e, p1 = (n, t) => t, d1 = (n, t) => n, Ag = (n, t, e) => n << e | t >>> 32 - e, mg = (n, t, e) => t << e | n >>> 32 - e, Sg = (n, t, e) => t << e - 32 | n >>> 64 - e, Eg = (n, t, e) => n << e - 32 | t >>> 64 - e;
function w1(n, t, e, r) {
  const i = (t >>> 0) + (r >>> 0);
  return { h: n + e + (i / 2 ** 32 | 0) | 0, l: i | 0 };
}
const g1 = (n, t, e) => (n >>> 0) + (t >>> 0) + (e >>> 0), y1 = (n, t, e, r) => t + e + r + (n / 2 ** 32 | 0) | 0, b1 = (n, t, e, r) => (n >>> 0) + (t >>> 0) + (e >>> 0) + (r >>> 0), A1 = (n, t, e, r, i) => t + e + r + i + (n / 2 ** 32 | 0) | 0, m1 = (n, t, e, r, i) => (n >>> 0) + (t >>> 0) + (e >>> 0) + (r >>> 0) + (i >>> 0), S1 = (n, t, e, r, i, s) => t + e + r + i + s + (n / 2 ** 32 | 0) | 0, St = {
  fromBig: yg,
  split: bg,
  toBig: a1,
  shrSH: c1,
  shrSL: _1,
  rotrSH: l1,
  rotrSL: u1,
  rotrBH: f1,
  rotrBL: h1,
  rotr32H: p1,
  rotr32L: d1,
  rotlSH: Ag,
  rotlSL: mg,
  rotlBH: Sg,
  rotlBL: Eg,
  add: w1,
  add3L: g1,
  add3H: y1,
  add4L: b1,
  add4H: A1,
  add5H: S1,
  add5L: m1
}, [E1, R1] = St.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n) => BigInt(n))), jn = /* @__PURE__ */ new Uint32Array(80), Hn = /* @__PURE__ */ new Uint32Array(80);
class P1 extends wg {
  constructor() {
    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  // prettier-ignore
  get() {
    const { Ah: t, Al: e, Bh: r, Bl: i, Ch: s, Cl: a, Dh: c, Dl: _, Eh: p, El: f, Fh: d, Fl: y, Gh: b, Gl: v, Hh: R, Hl: M } = this;
    return [t, e, r, i, s, a, c, _, p, f, d, y, b, v, R, M];
  }
  // prettier-ignore
  set(t, e, r, i, s, a, c, _, p, f, d, y, b, v, R, M) {
    this.Ah = t | 0, this.Al = e | 0, this.Bh = r | 0, this.Bl = i | 0, this.Ch = s | 0, this.Cl = a | 0, this.Dh = c | 0, this.Dl = _ | 0, this.Eh = p | 0, this.El = f | 0, this.Fh = d | 0, this.Fl = y | 0, this.Gh = b | 0, this.Gl = v | 0, this.Hh = R | 0, this.Hl = M | 0;
  }
  process(t, e) {
    for (let N = 0; N < 16; N++, e += 4)
      jn[N] = t.getUint32(e), Hn[N] = t.getUint32(e += 4);
    for (let N = 16; N < 80; N++) {
      const G = jn[N - 15] | 0, D = Hn[N - 15] | 0, $ = St.rotrSH(G, D, 1) ^ St.rotrSH(G, D, 8) ^ St.shrSH(G, D, 7), X = St.rotrSL(G, D, 1) ^ St.rotrSL(G, D, 8) ^ St.shrSL(G, D, 7), V = jn[N - 2] | 0, nt = Hn[N - 2] | 0, ft = St.rotrSH(V, nt, 19) ^ St.rotrBH(V, nt, 61) ^ St.shrSH(V, nt, 6), pt = St.rotrSL(V, nt, 19) ^ St.rotrBL(V, nt, 61) ^ St.shrSL(V, nt, 6), At = St.add4L(X, pt, Hn[N - 7], Hn[N - 16]), Nt = St.add4H(At, $, ft, jn[N - 7], jn[N - 16]);
      jn[N] = Nt | 0, Hn[N] = At | 0;
    }
    let { Ah: r, Al: i, Bh: s, Bl: a, Ch: c, Cl: _, Dh: p, Dl: f, Eh: d, El: y, Fh: b, Fl: v, Gh: R, Gl: M, Hh: A, Hl: B } = this;
    for (let N = 0; N < 80; N++) {
      const G = St.rotrSH(d, y, 14) ^ St.rotrSH(d, y, 18) ^ St.rotrBH(d, y, 41), D = St.rotrSL(d, y, 14) ^ St.rotrSL(d, y, 18) ^ St.rotrBL(d, y, 41), $ = d & b ^ ~d & R, X = y & v ^ ~y & M, V = St.add5L(B, D, X, R1[N], Hn[N]), nt = St.add5H(V, A, G, $, E1[N], jn[N]), ft = V | 0, pt = St.rotrSH(r, i, 28) ^ St.rotrBH(r, i, 34) ^ St.rotrBH(r, i, 39), At = St.rotrSL(r, i, 28) ^ St.rotrBL(r, i, 34) ^ St.rotrBL(r, i, 39), Nt = r & s ^ r & c ^ s & c, kt = i & a ^ i & _ ^ a & _;
      A = R | 0, B = M | 0, R = b | 0, M = v | 0, b = d | 0, v = y | 0, { h: d, l: y } = St.add(p | 0, f | 0, nt | 0, ft | 0), p = c | 0, f = _ | 0, c = s | 0, _ = a | 0, s = r | 0, a = i | 0;
      const it = St.add3L(ft, At, kt);
      r = St.add3H(it, nt, pt, Nt), i = it | 0;
    }
    ({ h: r, l: i } = St.add(this.Ah | 0, this.Al | 0, r | 0, i | 0)), { h: s, l: a } = St.add(this.Bh | 0, this.Bl | 0, s | 0, a | 0), { h: c, l: _ } = St.add(this.Ch | 0, this.Cl | 0, c | 0, _ | 0), { h: p, l: f } = St.add(this.Dh | 0, this.Dl | 0, p | 0, f | 0), { h: d, l: y } = St.add(this.Eh | 0, this.El | 0, d | 0, y | 0), { h: b, l: v } = St.add(this.Fh | 0, this.Fl | 0, b | 0, v | 0), { h: R, l: M } = St.add(this.Gh | 0, this.Gl | 0, R | 0, M | 0), { h: A, l: B } = St.add(this.Hh | 0, this.Hl | 0, A | 0, B | 0), this.set(r, i, s, a, c, _, p, f, d, y, b, v, R, M, A, B);
  }
  roundClean() {
    jn.fill(0), Hn.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
const v1 = /* @__PURE__ */ zf(() => new P1());
function M1() {
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof ba < "u")
    return ba;
  throw new Error("unable to locate global object");
}
const xh = M1();
xh.crypto || xh.msCrypto;
function x1(n) {
  switch (n) {
    case "sha256":
      return gg.create();
    case "sha512":
      return v1.create();
  }
  T(!1, "invalid hashing algorithm name", "algorithm", n);
}
const [Rg, Pg, vg] = [[], [], []], B1 = /* @__PURE__ */ BigInt(0), Ga = /* @__PURE__ */ BigInt(1), C1 = /* @__PURE__ */ BigInt(2), I1 = /* @__PURE__ */ BigInt(7), N1 = /* @__PURE__ */ BigInt(256), O1 = /* @__PURE__ */ BigInt(113);
for (let n = 0, t = Ga, e = 1, r = 0; n < 24; n++) {
  [e, r] = [r, (2 * e + 3 * r) % 5], Rg.push(2 * (5 * r + e)), Pg.push((n + 1) * (n + 2) / 2 % 64);
  let i = B1;
  for (let s = 0; s < 7; s++)
    t = (t << Ga ^ (t >> I1) * O1) % N1, t & C1 && (i ^= Ga << (Ga << /* @__PURE__ */ BigInt(s)) - Ga);
  vg.push(i);
}
const [T1, z1] = /* @__PURE__ */ bg(vg, !0), Bh = (n, t, e) => e > 32 ? Sg(n, t, e) : Ag(n, t, e), Ch = (n, t, e) => e > 32 ? Eg(n, t, e) : mg(n, t, e);
function k1(n, t = 24) {
  const e = new Uint32Array(10);
  for (let r = 24 - t; r < 24; r++) {
    for (let a = 0; a < 10; a++)
      e[a] = n[a] ^ n[a + 10] ^ n[a + 20] ^ n[a + 30] ^ n[a + 40];
    for (let a = 0; a < 10; a += 2) {
      const c = (a + 8) % 10, _ = (a + 2) % 10, p = e[_], f = e[_ + 1], d = Bh(p, f, 1) ^ e[c], y = Ch(p, f, 1) ^ e[c + 1];
      for (let b = 0; b < 50; b += 10)
        n[a + b] ^= d, n[a + b + 1] ^= y;
    }
    let i = n[2], s = n[3];
    for (let a = 0; a < 24; a++) {
      const c = Pg[a], _ = Bh(i, s, c), p = Ch(i, s, c), f = Rg[a];
      i = n[f], s = n[f + 1], n[f] = _, n[f + 1] = p;
    }
    for (let a = 0; a < 50; a += 10) {
      for (let c = 0; c < 10; c++)
        e[c] = n[a + c];
      for (let c = 0; c < 10; c++)
        n[a + c] ^= ~e[(c + 2) % 10] & e[(c + 4) % 10];
    }
    n[0] ^= T1[r], n[1] ^= z1[r];
  }
  e.fill(0);
}
let U1 = class Mg extends Tf {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(t, e, r, i = !1, s = 24) {
    if (super(), this.blockLen = t, this.suffix = e, this.outputLen = r, this.enableXOF = i, this.rounds = s, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, w_(r), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = qb(this.state);
  }
  keccak() {
    k1(this.state32, this.rounds), this.posOut = 0, this.pos = 0;
  }
  update(t) {
    ma(this);
    const { blockLen: e, state: r } = this;
    t = Y_(t);
    const i = t.length;
    for (let s = 0; s < i; ) {
      const a = Math.min(e - this.pos, i - s);
      for (let c = 0; c < a; c++)
        r[this.pos++] ^= t[s++];
      this.pos === e && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: t, suffix: e, pos: r, blockLen: i } = this;
    t[r] ^= e, e & 128 && r === i - 1 && this.keccak(), t[i - 1] ^= 128, this.keccak();
  }
  writeInto(t) {
    ma(this, !1), Of(t), this.finish();
    const e = this.state, { blockLen: r } = this;
    for (let i = 0, s = t.length; i < s; ) {
      this.posOut >= r && this.keccak();
      const a = Math.min(r - this.posOut, s - i);
      t.set(e.subarray(this.posOut, this.posOut + a), i), this.posOut += a, i += a;
    }
    return t;
  }
  xofInto(t) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(t);
  }
  xof(t) {
    return w_(t), this.xofInto(new Uint8Array(t));
  }
  digestInto(t) {
    if (fg(t, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(t), this.destroy(), t;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(t) {
    const { blockLen: e, suffix: r, outputLen: i, rounds: s, enableXOF: a } = this;
    return t || (t = new Mg(e, r, i, a, s)), t.state32.set(this.state32), t.pos = this.pos, t.posOut = this.posOut, t.finished = this.finished, t.rounds = s, t.suffix = r, t.outputLen = i, t.enableXOF = a, t.destroyed = this.destroyed, t;
  }
};
const F1 = (n, t, e) => zf(() => new U1(t, n, e)), G1 = /* @__PURE__ */ F1(1, 136, 256 / 8);
let xg = !1;
const Bg = function(n) {
  return G1(n);
};
let Cg = Bg;
function ee(n) {
  const t = Tt(n, "data");
  return ut(Cg(t));
}
ee._ = Bg;
ee.lock = function() {
  xg = !0;
};
ee.register = function(n) {
  if (xg)
    throw new TypeError("keccak256 is locked");
  Cg = n;
};
Object.freeze(ee);
const Ig = function(n) {
  return x1("sha256").update(n).digest();
};
let Ng = Ig, Og = !1;
function Ia(n) {
  const t = Tt(n, "data");
  return ut(Ng(t));
}
Ia._ = Ig;
Ia.lock = function() {
  Og = !0;
};
Ia.register = function(n) {
  if (Og)
    throw new Error("sha256 is locked");
  Ng = n;
};
Object.freeze(Ia);
Object.freeze(Ia);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Tg = BigInt(0), Q_ = BigInt(1), L1 = BigInt(2), W_ = (n) => n instanceof Uint8Array, D1 = /* @__PURE__ */ Array.from({ length: 256 }, (n, t) => t.toString(16).padStart(2, "0"));
function Sa(n) {
  if (!W_(n))
    throw new Error("Uint8Array expected");
  let t = "";
  for (let e = 0; e < n.length; e++)
    t += D1[n[e]];
  return t;
}
function zg(n) {
  const t = n.toString(16);
  return t.length & 1 ? `0${t}` : t;
}
function kf(n) {
  if (typeof n != "string")
    throw new Error("hex string expected, got " + typeof n);
  return BigInt(n === "" ? "0" : `0x${n}`);
}
function Ea(n) {
  if (typeof n != "string")
    throw new Error("hex string expected, got " + typeof n);
  const t = n.length;
  if (t % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + t);
  const e = new Uint8Array(t / 2);
  for (let r = 0; r < e.length; r++) {
    const i = r * 2, s = n.slice(i, i + 2), a = Number.parseInt(s, 16);
    if (Number.isNaN(a) || a < 0)
      throw new Error("Invalid byte sequence");
    e[r] = a;
  }
  return e;
}
function as(n) {
  return kf(Sa(n));
}
function Uf(n) {
  if (!W_(n))
    throw new Error("Uint8Array expected");
  return kf(Sa(Uint8Array.from(n).reverse()));
}
function Ra(n, t) {
  return Ea(n.toString(16).padStart(t * 2, "0"));
}
function Ff(n, t) {
  return Ra(n, t).reverse();
}
function K1(n) {
  return Ea(zg(n));
}
function sr(n, t, e) {
  let r;
  if (typeof t == "string")
    try {
      r = Ea(t);
    } catch (s) {
      throw new Error(`${n} must be valid hex string, got "${t}". Cause: ${s}`);
    }
  else if (W_(t))
    r = Uint8Array.from(t);
  else
    throw new Error(`${n} must be hex string or Uint8Array`);
  const i = r.length;
  if (typeof e == "number" && i !== e)
    throw new Error(`${n} expected ${e} bytes, got ${i}`);
  return r;
}
function tc(...n) {
  const t = new Uint8Array(n.reduce((r, i) => r + i.length, 0));
  let e = 0;
  return n.forEach((r) => {
    if (!W_(r))
      throw new Error("Uint8Array expected");
    t.set(r, e), e += r.length;
  }), t;
}
function V1(n, t) {
  if (n.length !== t.length)
    return !1;
  for (let e = 0; e < n.length; e++)
    if (n[e] !== t[e])
      return !1;
  return !0;
}
function j1(n) {
  if (typeof n != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof n}`);
  return new Uint8Array(new TextEncoder().encode(n));
}
function H1(n) {
  let t;
  for (t = 0; n > Tg; n >>= Q_, t += 1)
    ;
  return t;
}
function Y1(n, t) {
  return n >> BigInt(t) & Q_;
}
const Q1 = (n, t, e) => n | (e ? Q_ : Tg) << BigInt(t), Gf = (n) => (L1 << BigInt(n - 1)) - Q_, tu = (n) => new Uint8Array(n), Ih = (n) => Uint8Array.from(n);
function kg(n, t, e) {
  if (typeof n != "number" || n < 2)
    throw new Error("hashLen must be a number");
  if (typeof t != "number" || t < 2)
    throw new Error("qByteLen must be a number");
  if (typeof e != "function")
    throw new Error("hmacFn must be a function");
  let r = tu(n), i = tu(n), s = 0;
  const a = () => {
    r.fill(1), i.fill(0), s = 0;
  }, c = (...d) => e(i, r, ...d), _ = (d = tu()) => {
    i = c(Ih([0]), d), r = c(), d.length !== 0 && (i = c(Ih([1]), d), r = c());
  }, p = () => {
    if (s++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let d = 0;
    const y = [];
    for (; d < t; ) {
      r = c();
      const b = r.slice();
      y.push(b), d += r.length;
    }
    return tc(...y);
  };
  return (d, y) => {
    a(), _(d);
    let b;
    for (; !(b = y(p())); )
      _();
    return a(), b;
  };
}
const W1 = {
  bigint: (n) => typeof n == "bigint",
  function: (n) => typeof n == "function",
  boolean: (n) => typeof n == "boolean",
  string: (n) => typeof n == "string",
  stringOrUint8Array: (n) => typeof n == "string" || n instanceof Uint8Array,
  isSafeInteger: (n) => Number.isSafeInteger(n),
  array: (n) => Array.isArray(n),
  field: (n, t) => t.Fp.isValid(n),
  hash: (n) => typeof n == "function" && Number.isSafeInteger(n.outputLen)
};
function Mc(n, t, e = {}) {
  const r = (i, s, a) => {
    const c = W1[s];
    if (typeof c != "function")
      throw new Error(`Invalid validator "${s}", expected function`);
    const _ = n[i];
    if (!(a && _ === void 0) && !c(_, n))
      throw new Error(`Invalid param ${String(i)}=${_} (${typeof _}), expected ${s}`);
  };
  for (const [i, s] of Object.entries(t))
    r(i, s, !1);
  for (const [i, s] of Object.entries(e))
    r(i, s, !0);
  return n;
}
const J1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bitGet: Y1,
  bitLen: H1,
  bitMask: Gf,
  bitSet: Q1,
  bytesToHex: Sa,
  bytesToNumberBE: as,
  bytesToNumberLE: Uf,
  concatBytes: tc,
  createHmacDrbg: kg,
  ensureBytes: sr,
  equalBytes: V1,
  hexToBytes: Ea,
  hexToNumber: kf,
  numberToBytesBE: Ra,
  numberToBytesLE: Ff,
  numberToHexUnpadded: zg,
  numberToVarBytesBE: K1,
  utf8ToBytes: j1,
  validateObject: Mc
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const ce = BigInt(0), qt = BigInt(1), Pi = BigInt(2), $1 = BigInt(3), Ku = BigInt(4), Nh = BigInt(5), Oh = BigInt(8);
BigInt(9);
BigInt(16);
function Me(n, t) {
  const e = n % t;
  return e >= ce ? e : t + e;
}
function q1(n, t, e) {
  if (e <= ce || t < ce)
    throw new Error("Expected power/modulo > 0");
  if (e === qt)
    return ce;
  let r = qt;
  for (; t > ce; )
    t & qt && (r = r * n % e), n = n * n % e, t >>= qt;
  return r;
}
function Le(n, t, e) {
  let r = n;
  for (; t-- > ce; )
    r *= r, r %= e;
  return r;
}
function Vu(n, t) {
  if (n === ce || t <= ce)
    throw new Error(`invert: expected positive integers, got n=${n} mod=${t}`);
  let e = Me(n, t), r = t, i = ce, s = qt;
  for (; e !== ce; ) {
    const c = r / e, _ = r % e, p = i - s * c;
    r = e, e = _, i = s, s = p;
  }
  if (r !== qt)
    throw new Error("invert: does not exist");
  return Me(i, t);
}
function Z1(n) {
  const t = (n - qt) / Pi;
  let e, r, i;
  for (e = n - qt, r = 0; e % Pi === ce; e /= Pi, r++)
    ;
  for (i = Pi; i < n && q1(i, t, n) !== n - qt; i++)
    ;
  if (r === 1) {
    const a = (n + qt) / Ku;
    return function(_, p) {
      const f = _.pow(p, a);
      if (!_.eql(_.sqr(f), p))
        throw new Error("Cannot find square root");
      return f;
    };
  }
  const s = (e + qt) / Pi;
  return function(c, _) {
    if (c.pow(_, t) === c.neg(c.ONE))
      throw new Error("Cannot find square root");
    let p = r, f = c.pow(c.mul(c.ONE, i), e), d = c.pow(_, s), y = c.pow(_, e);
    for (; !c.eql(y, c.ONE); ) {
      if (c.eql(y, c.ZERO))
        return c.ZERO;
      let b = 1;
      for (let R = c.sqr(y); b < p && !c.eql(R, c.ONE); b++)
        R = c.sqr(R);
      const v = c.pow(f, qt << BigInt(p - b - 1));
      f = c.sqr(v), d = c.mul(d, v), y = c.mul(y, f), p = b;
    }
    return d;
  };
}
function X1(n) {
  if (n % Ku === $1) {
    const t = (n + qt) / Ku;
    return function(r, i) {
      const s = r.pow(i, t);
      if (!r.eql(r.sqr(s), i))
        throw new Error("Cannot find square root");
      return s;
    };
  }
  if (n % Oh === Nh) {
    const t = (n - Nh) / Oh;
    return function(r, i) {
      const s = r.mul(i, Pi), a = r.pow(s, t), c = r.mul(i, a), _ = r.mul(r.mul(c, Pi), a), p = r.mul(c, r.sub(_, r.ONE));
      if (!r.eql(r.sqr(p), i))
        throw new Error("Cannot find square root");
      return p;
    };
  }
  return Z1(n);
}
const tA = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function eA(n) {
  const t = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, e = tA.reduce((r, i) => (r[i] = "function", r), t);
  return Mc(n, e);
}
function rA(n, t, e) {
  if (e < ce)
    throw new Error("Expected power > 0");
  if (e === ce)
    return n.ONE;
  if (e === qt)
    return t;
  let r = n.ONE, i = t;
  for (; e > ce; )
    e & qt && (r = n.mul(r, i)), i = n.sqr(i), e >>= qt;
  return r;
}
function nA(n, t) {
  const e = new Array(t.length), r = t.reduce((s, a, c) => n.is0(a) ? s : (e[c] = s, n.mul(s, a)), n.ONE), i = n.inv(r);
  return t.reduceRight((s, a, c) => n.is0(a) ? s : (e[c] = n.mul(s, e[c]), n.mul(s, a)), i), e;
}
function Ug(n, t) {
  const e = t !== void 0 ? t : n.toString(2).length, r = Math.ceil(e / 8);
  return { nBitLength: e, nByteLength: r };
}
function iA(n, t, e = !1, r = {}) {
  if (n <= ce)
    throw new Error(`Expected Field ORDER > 0, got ${n}`);
  const { nBitLength: i, nByteLength: s } = Ug(n, t);
  if (s > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const a = X1(n), c = Object.freeze({
    ORDER: n,
    BITS: i,
    BYTES: s,
    MASK: Gf(i),
    ZERO: ce,
    ONE: qt,
    create: (_) => Me(_, n),
    isValid: (_) => {
      if (typeof _ != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof _}`);
      return ce <= _ && _ < n;
    },
    is0: (_) => _ === ce,
    isOdd: (_) => (_ & qt) === qt,
    neg: (_) => Me(-_, n),
    eql: (_, p) => _ === p,
    sqr: (_) => Me(_ * _, n),
    add: (_, p) => Me(_ + p, n),
    sub: (_, p) => Me(_ - p, n),
    mul: (_, p) => Me(_ * p, n),
    pow: (_, p) => rA(c, _, p),
    div: (_, p) => Me(_ * Vu(p, n), n),
    // Same as above, but doesn't normalize
    sqrN: (_) => _ * _,
    addN: (_, p) => _ + p,
    subN: (_, p) => _ - p,
    mulN: (_, p) => _ * p,
    inv: (_) => Vu(_, n),
    sqrt: r.sqrt || ((_) => a(c, _)),
    invertBatch: (_) => nA(c, _),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (_, p, f) => f ? p : _,
    toBytes: (_) => e ? Ff(_, s) : Ra(_, s),
    fromBytes: (_) => {
      if (_.length !== s)
        throw new Error(`Fp.fromBytes: expected ${s}, got ${_.length}`);
      return e ? Uf(_) : as(_);
    }
  });
  return Object.freeze(c);
}
function Fg(n) {
  if (typeof n != "bigint")
    throw new Error("field order must be bigint");
  const t = n.toString(2).length;
  return Math.ceil(t / 8);
}
function Gg(n) {
  const t = Fg(n);
  return t + Math.ceil(t / 2);
}
function sA(n, t, e = !1) {
  const r = n.length, i = Fg(t), s = Gg(t);
  if (r < 16 || r < s || r > 1024)
    throw new Error(`expected ${s}-1024 bytes of input, got ${r}`);
  const a = e ? as(n) : Uf(n), c = Me(a, t - qt) + qt;
  return e ? Ff(c, i) : Ra(c, i);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const oA = BigInt(0), eu = BigInt(1);
function aA(n, t) {
  const e = (i, s) => {
    const a = s.negate();
    return i ? a : s;
  }, r = (i) => {
    const s = Math.ceil(t / i) + 1, a = 2 ** (i - 1);
    return { windows: s, windowSize: a };
  };
  return {
    constTimeNegate: e,
    // non-const time multiplication ladder
    unsafeLadder(i, s) {
      let a = n.ZERO, c = i;
      for (; s > oA; )
        s & eu && (a = a.add(c)), c = c.double(), s >>= eu;
      return a;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(i, s) {
      const { windows: a, windowSize: c } = r(s), _ = [];
      let p = i, f = p;
      for (let d = 0; d < a; d++) {
        f = p, _.push(f);
        for (let y = 1; y < c; y++)
          f = f.add(p), _.push(f);
        p = f.double();
      }
      return _;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(i, s, a) {
      const { windows: c, windowSize: _ } = r(i);
      let p = n.ZERO, f = n.BASE;
      const d = BigInt(2 ** i - 1), y = 2 ** i, b = BigInt(i);
      for (let v = 0; v < c; v++) {
        const R = v * _;
        let M = Number(a & d);
        a >>= b, M > _ && (M -= y, a += eu);
        const A = R, B = R + Math.abs(M) - 1, N = v % 2 !== 0, G = M < 0;
        M === 0 ? f = f.add(e(N, s[A])) : p = p.add(e(G, s[B]));
      }
      return { p, f };
    },
    wNAFCached(i, s, a, c) {
      const _ = i._WINDOW_SIZE || 1;
      let p = s.get(i);
      return p || (p = this.precomputeWindow(i, _), _ !== 1 && s.set(i, c(p))), this.wNAF(_, p, a);
    }
  };
}
function Lg(n) {
  return eA(n.Fp), Mc(n, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...Ug(n.n, n.nBitLength),
    ...n,
    p: n.Fp.ORDER
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function cA(n) {
  const t = Lg(n);
  Mc(t, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: e, Fp: r, a: i } = t;
  if (e) {
    if (!r.eql(i, r.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof e != "object" || typeof e.beta != "bigint" || typeof e.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...t });
}
const { bytesToNumberBE: _A, hexToBytes: lA } = J1, Ci = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(t = "") {
      super(t);
    }
  },
  _parseInt(n) {
    const { Err: t } = Ci;
    if (n.length < 2 || n[0] !== 2)
      throw new t("Invalid signature integer tag");
    const e = n[1], r = n.subarray(2, e + 2);
    if (!e || r.length !== e)
      throw new t("Invalid signature integer: wrong length");
    if (r[0] & 128)
      throw new t("Invalid signature integer: negative");
    if (r[0] === 0 && !(r[1] & 128))
      throw new t("Invalid signature integer: unnecessary leading zero");
    return { d: _A(r), l: n.subarray(e + 2) };
  },
  toSig(n) {
    const { Err: t } = Ci, e = typeof n == "string" ? lA(n) : n;
    if (!(e instanceof Uint8Array))
      throw new Error("ui8a expected");
    let r = e.length;
    if (r < 2 || e[0] != 48)
      throw new t("Invalid signature tag");
    if (e[1] !== r - 2)
      throw new t("Invalid signature: incorrect length");
    const { d: i, l: s } = Ci._parseInt(e.subarray(2)), { d: a, l: c } = Ci._parseInt(s);
    if (c.length)
      throw new t("Invalid signature: left bytes after parsing");
    return { r: i, s: a };
  },
  hexFromSig(n) {
    const t = (p) => Number.parseInt(p[0], 16) & 8 ? "00" + p : p, e = (p) => {
      const f = p.toString(16);
      return f.length & 1 ? `0${f}` : f;
    }, r = t(e(n.s)), i = t(e(n.r)), s = r.length / 2, a = i.length / 2, c = e(s), _ = e(a);
    return `30${e(a + s + 4)}02${_}${i}02${c}${r}`;
  }
}, Cn = BigInt(0), $e = BigInt(1);
BigInt(2);
const Th = BigInt(3);
BigInt(4);
function uA(n) {
  const t = cA(n), { Fp: e } = t, r = t.toBytes || ((v, R, M) => {
    const A = R.toAffine();
    return tc(Uint8Array.from([4]), e.toBytes(A.x), e.toBytes(A.y));
  }), i = t.fromBytes || ((v) => {
    const R = v.subarray(1), M = e.fromBytes(R.subarray(0, e.BYTES)), A = e.fromBytes(R.subarray(e.BYTES, 2 * e.BYTES));
    return { x: M, y: A };
  });
  function s(v) {
    const { a: R, b: M } = t, A = e.sqr(v), B = e.mul(A, v);
    return e.add(e.add(B, e.mul(v, R)), M);
  }
  if (!e.eql(e.sqr(t.Gy), s(t.Gx)))
    throw new Error("bad generator point: equation left != right");
  function a(v) {
    return typeof v == "bigint" && Cn < v && v < t.n;
  }
  function c(v) {
    if (!a(v))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function _(v) {
    const { allowedPrivateKeyLengths: R, nByteLength: M, wrapPrivateKey: A, n: B } = t;
    if (R && typeof v != "bigint") {
      if (v instanceof Uint8Array && (v = Sa(v)), typeof v != "string" || !R.includes(v.length))
        throw new Error("Invalid key");
      v = v.padStart(M * 2, "0");
    }
    let N;
    try {
      N = typeof v == "bigint" ? v : as(sr("private key", v, M));
    } catch {
      throw new Error(`private key must be ${M} bytes, hex or bigint, not ${typeof v}`);
    }
    return A && (N = Me(N, B)), c(N), N;
  }
  const p = /* @__PURE__ */ new Map();
  function f(v) {
    if (!(v instanceof d))
      throw new Error("ProjectivePoint expected");
  }
  class d {
    constructor(R, M, A) {
      if (this.px = R, this.py = M, this.pz = A, R == null || !e.isValid(R))
        throw new Error("x required");
      if (M == null || !e.isValid(M))
        throw new Error("y required");
      if (A == null || !e.isValid(A))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(R) {
      const { x: M, y: A } = R || {};
      if (!R || !e.isValid(M) || !e.isValid(A))
        throw new Error("invalid affine point");
      if (R instanceof d)
        throw new Error("projective point not allowed");
      const B = (N) => e.eql(N, e.ZERO);
      return B(M) && B(A) ? d.ZERO : new d(M, A, e.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(R) {
      const M = e.invertBatch(R.map((A) => A.pz));
      return R.map((A, B) => A.toAffine(M[B])).map(d.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(R) {
      const M = d.fromAffine(i(sr("pointHex", R)));
      return M.assertValidity(), M;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(R) {
      return d.BASE.multiply(_(R));
    }
    // "Private method", don't use it directly
    _setWindowSize(R) {
      this._WINDOW_SIZE = R, p.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (t.allowInfinityPoint && !e.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: R, y: M } = this.toAffine();
      if (!e.isValid(R) || !e.isValid(M))
        throw new Error("bad point: x or y not FE");
      const A = e.sqr(M), B = s(R);
      if (!e.eql(A, B))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: R } = this.toAffine();
      if (e.isOdd)
        return !e.isOdd(R);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(R) {
      f(R);
      const { px: M, py: A, pz: B } = this, { px: N, py: G, pz: D } = R, $ = e.eql(e.mul(M, D), e.mul(N, B)), X = e.eql(e.mul(A, D), e.mul(G, B));
      return $ && X;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new d(this.px, e.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: R, b: M } = t, A = e.mul(M, Th), { px: B, py: N, pz: G } = this;
      let D = e.ZERO, $ = e.ZERO, X = e.ZERO, V = e.mul(B, B), nt = e.mul(N, N), ft = e.mul(G, G), pt = e.mul(B, N);
      return pt = e.add(pt, pt), X = e.mul(B, G), X = e.add(X, X), D = e.mul(R, X), $ = e.mul(A, ft), $ = e.add(D, $), D = e.sub(nt, $), $ = e.add(nt, $), $ = e.mul(D, $), D = e.mul(pt, D), X = e.mul(A, X), ft = e.mul(R, ft), pt = e.sub(V, ft), pt = e.mul(R, pt), pt = e.add(pt, X), X = e.add(V, V), V = e.add(X, V), V = e.add(V, ft), V = e.mul(V, pt), $ = e.add($, V), ft = e.mul(N, G), ft = e.add(ft, ft), V = e.mul(ft, pt), D = e.sub(D, V), X = e.mul(ft, nt), X = e.add(X, X), X = e.add(X, X), new d(D, $, X);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(R) {
      f(R);
      const { px: M, py: A, pz: B } = this, { px: N, py: G, pz: D } = R;
      let $ = e.ZERO, X = e.ZERO, V = e.ZERO;
      const nt = t.a, ft = e.mul(t.b, Th);
      let pt = e.mul(M, N), At = e.mul(A, G), Nt = e.mul(B, D), kt = e.add(M, A), it = e.add(N, G);
      kt = e.mul(kt, it), it = e.add(pt, At), kt = e.sub(kt, it), it = e.add(M, B);
      let ot = e.add(N, D);
      return it = e.mul(it, ot), ot = e.add(pt, Nt), it = e.sub(it, ot), ot = e.add(A, B), $ = e.add(G, D), ot = e.mul(ot, $), $ = e.add(At, Nt), ot = e.sub(ot, $), V = e.mul(nt, it), $ = e.mul(ft, Nt), V = e.add($, V), $ = e.sub(At, V), V = e.add(At, V), X = e.mul($, V), At = e.add(pt, pt), At = e.add(At, pt), Nt = e.mul(nt, Nt), it = e.mul(ft, it), At = e.add(At, Nt), Nt = e.sub(pt, Nt), Nt = e.mul(nt, Nt), it = e.add(it, Nt), pt = e.mul(At, it), X = e.add(X, pt), pt = e.mul(ot, it), $ = e.mul(kt, $), $ = e.sub($, pt), pt = e.mul(kt, At), V = e.mul(ot, V), V = e.add(V, pt), new d($, X, V);
    }
    subtract(R) {
      return this.add(R.negate());
    }
    is0() {
      return this.equals(d.ZERO);
    }
    wNAF(R) {
      return b.wNAFCached(this, p, R, (M) => {
        const A = e.invertBatch(M.map((B) => B.pz));
        return M.map((B, N) => B.toAffine(A[N])).map(d.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(R) {
      const M = d.ZERO;
      if (R === Cn)
        return M;
      if (c(R), R === $e)
        return this;
      const { endo: A } = t;
      if (!A)
        return b.unsafeLadder(this, R);
      let { k1neg: B, k1: N, k2neg: G, k2: D } = A.splitScalar(R), $ = M, X = M, V = this;
      for (; N > Cn || D > Cn; )
        N & $e && ($ = $.add(V)), D & $e && (X = X.add(V)), V = V.double(), N >>= $e, D >>= $e;
      return B && ($ = $.negate()), G && (X = X.negate()), X = new d(e.mul(X.px, A.beta), X.py, X.pz), $.add(X);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(R) {
      c(R);
      let M = R, A, B;
      const { endo: N } = t;
      if (N) {
        const { k1neg: G, k1: D, k2neg: $, k2: X } = N.splitScalar(M);
        let { p: V, f: nt } = this.wNAF(D), { p: ft, f: pt } = this.wNAF(X);
        V = b.constTimeNegate(G, V), ft = b.constTimeNegate($, ft), ft = new d(e.mul(ft.px, N.beta), ft.py, ft.pz), A = V.add(ft), B = nt.add(pt);
      } else {
        const { p: G, f: D } = this.wNAF(M);
        A = G, B = D;
      }
      return d.normalizeZ([A, B])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(R, M, A) {
      const B = d.BASE, N = (D, $) => $ === Cn || $ === $e || !D.equals(B) ? D.multiplyUnsafe($) : D.multiply($), G = N(this, M).add(N(R, A));
      return G.is0() ? void 0 : G;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z) ∋ (x=x/z, y=y/z)
    toAffine(R) {
      const { px: M, py: A, pz: B } = this, N = this.is0();
      R == null && (R = N ? e.ONE : e.inv(B));
      const G = e.mul(M, R), D = e.mul(A, R), $ = e.mul(B, R);
      if (N)
        return { x: e.ZERO, y: e.ZERO };
      if (!e.eql($, e.ONE))
        throw new Error("invZ was invalid");
      return { x: G, y: D };
    }
    isTorsionFree() {
      const { h: R, isTorsionFree: M } = t;
      if (R === $e)
        return !0;
      if (M)
        return M(d, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: R, clearCofactor: M } = t;
      return R === $e ? this : M ? M(d, this) : this.multiplyUnsafe(t.h);
    }
    toRawBytes(R = !0) {
      return this.assertValidity(), r(d, this, R);
    }
    toHex(R = !0) {
      return Sa(this.toRawBytes(R));
    }
  }
  d.BASE = new d(t.Gx, t.Gy, e.ONE), d.ZERO = new d(e.ZERO, e.ONE, e.ZERO);
  const y = t.nBitLength, b = aA(d, t.endo ? Math.ceil(y / 2) : y);
  return {
    CURVE: t,
    ProjectivePoint: d,
    normPrivateKeyToScalar: _,
    weierstrassEquation: s,
    isWithinCurveOrder: a
  };
}
function fA(n) {
  const t = Lg(n);
  return Mc(t, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...t });
}
function hA(n) {
  const t = fA(n), { Fp: e, n: r } = t, i = e.BYTES + 1, s = 2 * e.BYTES + 1;
  function a(it) {
    return Cn < it && it < e.ORDER;
  }
  function c(it) {
    return Me(it, r);
  }
  function _(it) {
    return Vu(it, r);
  }
  const { ProjectivePoint: p, normPrivateKeyToScalar: f, weierstrassEquation: d, isWithinCurveOrder: y } = uA({
    ...t,
    toBytes(it, ot, dt) {
      const bt = ot.toAffine(), yt = e.toBytes(bt.x), It = tc;
      return dt ? It(Uint8Array.from([ot.hasEvenY() ? 2 : 3]), yt) : It(Uint8Array.from([4]), yt, e.toBytes(bt.y));
    },
    fromBytes(it) {
      const ot = it.length, dt = it[0], bt = it.subarray(1);
      if (ot === i && (dt === 2 || dt === 3)) {
        const yt = as(bt);
        if (!a(yt))
          throw new Error("Point is not on curve");
        const It = d(yt);
        let Dt = e.sqrt(It);
        const k = (Dt & $e) === $e;
        return (dt & 1) === 1 !== k && (Dt = e.neg(Dt)), { x: yt, y: Dt };
      } else if (ot === s && dt === 4) {
        const yt = e.fromBytes(bt.subarray(0, e.BYTES)), It = e.fromBytes(bt.subarray(e.BYTES, 2 * e.BYTES));
        return { x: yt, y: It };
      } else
        throw new Error(`Point of length ${ot} was invalid. Expected ${i} compressed bytes or ${s} uncompressed bytes`);
    }
  }), b = (it) => Sa(Ra(it, t.nByteLength));
  function v(it) {
    const ot = r >> $e;
    return it > ot;
  }
  function R(it) {
    return v(it) ? c(-it) : it;
  }
  const M = (it, ot, dt) => as(it.slice(ot, dt));
  class A {
    constructor(ot, dt, bt) {
      this.r = ot, this.s = dt, this.recovery = bt, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(ot) {
      const dt = t.nByteLength;
      return ot = sr("compactSignature", ot, dt * 2), new A(M(ot, 0, dt), M(ot, dt, 2 * dt));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(ot) {
      const { r: dt, s: bt } = Ci.toSig(sr("DER", ot));
      return new A(dt, bt);
    }
    assertValidity() {
      if (!y(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!y(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(ot) {
      return new A(this.r, this.s, ot);
    }
    recoverPublicKey(ot) {
      const { r: dt, s: bt, recovery: yt } = this, It = X(sr("msgHash", ot));
      if (yt == null || ![0, 1, 2, 3].includes(yt))
        throw new Error("recovery id invalid");
      const Dt = yt === 2 || yt === 3 ? dt + t.n : dt;
      if (Dt >= e.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const k = yt & 1 ? "03" : "02", Y = p.fromHex(k + b(Dt)), Q = _(Dt), _t = c(-It * Q), O = c(bt * Q), I = p.BASE.multiplyAndAddUnsafe(Y, _t, O);
      if (!I)
        throw new Error("point at infinify");
      return I.assertValidity(), I;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return v(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new A(this.r, c(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return Ea(this.toDERHex());
    }
    toDERHex() {
      return Ci.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return Ea(this.toCompactHex());
    }
    toCompactHex() {
      return b(this.r) + b(this.s);
    }
  }
  const B = {
    isValidPrivateKey(it) {
      try {
        return f(it), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: f,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const it = Gg(t.n);
      return sA(t.randomBytes(it), t.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(it = 8, ot = p.BASE) {
      return ot._setWindowSize(it), ot.multiply(BigInt(3)), ot;
    }
  };
  function N(it, ot = !0) {
    return p.fromPrivateKey(it).toRawBytes(ot);
  }
  function G(it) {
    const ot = it instanceof Uint8Array, dt = typeof it == "string", bt = (ot || dt) && it.length;
    return ot ? bt === i || bt === s : dt ? bt === 2 * i || bt === 2 * s : it instanceof p;
  }
  function D(it, ot, dt = !0) {
    if (G(it))
      throw new Error("first arg must be private key");
    if (!G(ot))
      throw new Error("second arg must be public key");
    return p.fromHex(ot).multiply(f(it)).toRawBytes(dt);
  }
  const $ = t.bits2int || function(it) {
    const ot = as(it), dt = it.length * 8 - t.nBitLength;
    return dt > 0 ? ot >> BigInt(dt) : ot;
  }, X = t.bits2int_modN || function(it) {
    return c($(it));
  }, V = Gf(t.nBitLength);
  function nt(it) {
    if (typeof it != "bigint")
      throw new Error("bigint expected");
    if (!(Cn <= it && it < V))
      throw new Error(`bigint expected < 2^${t.nBitLength}`);
    return Ra(it, t.nByteLength);
  }
  function ft(it, ot, dt = pt) {
    if (["recovered", "canonical"].some((rt) => rt in dt))
      throw new Error("sign() legacy options not supported");
    const { hash: bt, randomBytes: yt } = t;
    let { lowS: It, prehash: Dt, extraEntropy: k } = dt;
    It == null && (It = !0), it = sr("msgHash", it), Dt && (it = sr("prehashed msgHash", bt(it)));
    const Y = X(it), Q = f(ot), _t = [nt(Q), nt(Y)];
    if (k != null) {
      const rt = k === !0 ? yt(e.BYTES) : k;
      _t.push(sr("extraEntropy", rt));
    }
    const O = tc(..._t), I = Y;
    function H(rt) {
      const at = $(rt);
      if (!y(at))
        return;
      const m = _(at), E = p.BASE.multiply(at).toAffine(), J = c(E.x);
      if (J === Cn)
        return;
      const st = c(m * c(I + J * Q));
      if (st === Cn)
        return;
      let xt = (E.x === J ? 0 : 2) | Number(E.y & $e), wt = st;
      return It && v(st) && (wt = R(st), xt ^= 1), new A(J, wt, xt);
    }
    return { seed: O, k2sig: H };
  }
  const pt = { lowS: t.lowS, prehash: !1 }, At = { lowS: t.lowS, prehash: !1 };
  function Nt(it, ot, dt = pt) {
    const { seed: bt, k2sig: yt } = ft(it, ot, dt), It = t;
    return kg(It.hash.outputLen, It.nByteLength, It.hmac)(bt, yt);
  }
  p.BASE._setWindowSize(8);
  function kt(it, ot, dt, bt = At) {
    var E;
    const yt = it;
    if (ot = sr("msgHash", ot), dt = sr("publicKey", dt), "strict" in bt)
      throw new Error("options.strict was renamed to lowS");
    const { lowS: It, prehash: Dt } = bt;
    let k, Y;
    try {
      if (typeof yt == "string" || yt instanceof Uint8Array)
        try {
          k = A.fromDER(yt);
        } catch (J) {
          if (!(J instanceof Ci.Err))
            throw J;
          k = A.fromCompact(yt);
        }
      else if (typeof yt == "object" && typeof yt.r == "bigint" && typeof yt.s == "bigint") {
        const { r: J, s: st } = yt;
        k = new A(J, st);
      } else
        throw new Error("PARSE");
      Y = p.fromHex(dt);
    } catch (J) {
      if (J.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return !1;
    }
    if (It && k.hasHighS())
      return !1;
    Dt && (ot = t.hash(ot));
    const { r: Q, s: _t } = k, O = X(ot), I = _(_t), H = c(O * I), rt = c(Q * I), at = (E = p.BASE.multiplyAndAddUnsafe(Y, H, rt)) == null ? void 0 : E.toAffine();
    return at ? c(at.x) === Q : !1;
  }
  return {
    CURVE: t,
    getPublicKey: N,
    getSharedSecret: D,
    sign: Nt,
    verify: kt,
    ProjectivePoint: p,
    Signature: A,
    utils: B
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function pA(n) {
  return {
    hash: n,
    hmac: (t, ...e) => dg(n, t, t1(...e)),
    randomBytes: e1
  };
}
function dA(n, t) {
  const e = (r) => hA({ ...n, ...pA(r) });
  return Object.freeze({ ...e(t), create: e });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Dg = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), zh = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), wA = BigInt(1), ju = BigInt(2), kh = (n, t) => (n + t / ju) / t;
function gA(n) {
  const t = Dg, e = BigInt(3), r = BigInt(6), i = BigInt(11), s = BigInt(22), a = BigInt(23), c = BigInt(44), _ = BigInt(88), p = n * n * n % t, f = p * p * n % t, d = Le(f, e, t) * f % t, y = Le(d, e, t) * f % t, b = Le(y, ju, t) * p % t, v = Le(b, i, t) * b % t, R = Le(v, s, t) * v % t, M = Le(R, c, t) * R % t, A = Le(M, _, t) * M % t, B = Le(A, c, t) * R % t, N = Le(B, e, t) * f % t, G = Le(N, a, t) * v % t, D = Le(G, r, t) * p % t, $ = Le(D, ju, t);
  if (!Hu.eql(Hu.sqr($), n))
    throw new Error("Cannot find square root");
  return $;
}
const Hu = iA(Dg, void 0, void 0, { sqrt: gA }), Yn = dA({
  a: BigInt(0),
  b: BigInt(7),
  Fp: Hu,
  n: zh,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: !0,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (n) => {
      const t = zh, e = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), r = -wA * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), s = e, a = BigInt("0x100000000000000000000000000000000"), c = kh(s * n, t), _ = kh(-r * n, t);
      let p = Me(n - c * e - _ * i, t), f = Me(-c * r - _ * s, t);
      const d = p > a, y = f > a;
      if (d && (p = t - p), y && (f = t - f), p > a || f > a)
        throw new Error("splitScalar: Endomorphism failed, k=" + n);
      return { k1neg: d, k1: p, k2neg: y, k2: f };
    }
  }
}, gg);
BigInt(0);
Yn.ProjectivePoint;
const ec = "0x0000000000000000000000000000000000000000", Uh = "0x0000000000000000000000000000000000000000000000000000000000000000", Fh = BigInt(0), Gh = BigInt(1), Lh = BigInt(2), Dh = BigInt(27), Kh = BigInt(28), Kc = BigInt(35), Ps = {};
function Vh(n) {
  return fs(me(n), 32);
}
var Do, Ko, Vo, $i;
const ir = class ir {
  /**
   *  @private
   */
  constructor(t, e, r, i) {
    j(this, Do);
    j(this, Ko);
    j(this, Vo);
    j(this, $i);
    K_(t, Ps, "Signature"), P(this, Do, e), P(this, Ko, r), P(this, Vo, i), P(this, $i, null);
  }
  /**
   *  The ``r`` value for a signautre.
   *
   *  This represents the ``x`` coordinate of a "reference" or
   *  challenge point, from which the ``y`` can be computed.
   */
  get r() {
    return w(this, Do);
  }
  set r(t) {
    T(So(t) === 32, "invalid r", "value", t), P(this, Do, ut(t));
  }
  /**
   *  The ``s`` value for a signature.
   */
  get s() {
    return w(this, Ko);
  }
  set s(t) {
    T(So(t) === 32, "invalid s", "value", t);
    const e = ut(t);
    T(parseInt(e.substring(0, 3)) < 8, "non-canonical s", "value", e), P(this, Ko, e);
  }
  /**
   *  The ``v`` value for a signature.
   *
   *  Since a given ``x`` value for ``r`` has two possible values for
   *  its correspondin ``y``, the ``v`` indicates which of the two ``y``
   *  values to use.
   *
   *  It is normalized to the values ``27`` or ``28`` for legacy
   *  purposes.
   */
  get v() {
    return w(this, Vo);
  }
  set v(t) {
    const e = Rt(t, "value");
    T(e === 27 || e === 28, "invalid v", "v", t), P(this, Vo, e);
  }
  /**
   *  The EIP-155 ``v`` for legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get networkV() {
    return w(this, $i);
  }
  /**
   *  The chain ID for EIP-155 legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get legacyChainId() {
    const t = this.networkV;
    return t == null ? null : ir.getChainId(t);
  }
  /**
   *  The ``yParity`` for the signature.
   *
   *  See ``v`` for more details on how this value is used.
   */
  get yParity() {
    return this.v === 27 ? 0 : 1;
  }
  /**
   *  The [[link-eip-2098]] compact representation of the ``yParity``
   *  and ``s`` compacted into a single ``bytes32``.
   */
  get yParityAndS() {
    const t = Tt(this.s);
    return this.yParity && (t[0] |= 128), ut(t);
  }
  /**
   *  The [[link-eip-2098]] compact representation.
   */
  get compactSerialized() {
    return Xt([this.r, this.yParityAndS]);
  }
  /**
   *  The serialized representation.
   */
  get serialized() {
    return Xt([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`;
  }
  /**
   *  Returns a new identical [[Signature]].
   */
  clone() {
    const t = new ir(Ps, this.r, this.s, this.v);
    return this.networkV && P(t, $i, this.networkV), t;
  }
  /**
   *  Returns a representation that is compatible with ``JSON.stringify``.
   */
  toJSON() {
    const t = this.networkV;
    return {
      _type: "signature",
      networkV: t != null ? t.toString() : null,
      r: this.r,
      s: this.s,
      v: this.v
    };
  }
  /**
   *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.
   *
   *  @example:
   *    Signature.getChainId(45)
   *    //_result:
   *
   *    Signature.getChainId(46)
   *    //_result:
   */
  static getChainId(t) {
    const e = ht(t, "v");
    return e == Dh || e == Kh ? Fh : (T(e >= Kc, "invalid EIP-155 v", "v", t), (e - Kc) / Lh);
  }
  /**
   *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.
   *
   *  Legacy transactions which use [[link-eip-155]] hijack the ``v``
   *  property to include the chain ID.
   *
   *  @example:
   *    Signature.getChainIdV(5, 27)
   *    //_result:
   *
   *    Signature.getChainIdV(5, 28)
   *    //_result:
   *
   */
  static getChainIdV(t, e) {
    return ht(t) * Lh + BigInt(35 + e - 27);
  }
  /**
   *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,
   *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.
   *
   *  @example:
   *    // The values 0 and 1 imply v is actually yParity
   *    Signature.getNormalizedV(0)
   *    //_result:
   *
   *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)
   *    Signature.getNormalizedV(27)
   *    //_result:
   *
   *    // Legacy EIP-155 transaction (i.e. >= 35)
   *    Signature.getNormalizedV(46)
   *    //_result:
   *
   *    // Invalid values throw
   *    Signature.getNormalizedV(5)
   *    //_error:
   */
  static getNormalizedV(t) {
    const e = ht(t);
    return e === Fh || e === Dh ? 27 : e === Gh || e === Kh ? 28 : (T(e >= Kc, "invalid v", "v", t), e & Gh ? 27 : 28);
  }
  /**
   *  Creates a new [[Signature]].
   *
   *  If no %%sig%% is provided, a new [[Signature]] is created
   *  with default values.
   *
   *  If %%sig%% is a string, it is parsed.
   */
  static from(t) {
    function e(p, f) {
      T(p, f, "signature", t);
    }
    if (t == null)
      return new ir(Ps, Uh, Uh, 27);
    if (typeof t == "string") {
      const p = Tt(t, "signature");
      if (p.length === 64) {
        const f = ut(p.slice(0, 32)), d = p.slice(32, 64), y = d[0] & 128 ? 28 : 27;
        return d[0] &= 127, new ir(Ps, f, ut(d), y);
      }
      if (p.length === 65) {
        const f = ut(p.slice(0, 32)), d = p.slice(32, 64);
        e((d[0] & 128) === 0, "non-canonical s");
        const y = ir.getNormalizedV(p[64]);
        return new ir(Ps, f, ut(d), y);
      }
      e(!1, "invalid raw signature length");
    }
    if (t instanceof ir)
      return t.clone();
    const r = t.r;
    e(r != null, "missing r");
    const i = Vh(r), s = function(p, f) {
      if (p != null)
        return Vh(p);
      if (f != null) {
        e(jt(f, 32), "invalid yParityAndS");
        const d = Tt(f);
        return d[0] &= 127, ut(d);
      }
      e(!1, "missing s");
    }(t.s, t.yParityAndS);
    e((Tt(s)[0] & 128) == 0, "non-canonical s");
    const { networkV: a, v: c } = function(p, f, d) {
      if (p != null) {
        const y = ht(p);
        return {
          networkV: y >= Kc ? y : void 0,
          v: ir.getNormalizedV(y)
        };
      }
      if (f != null)
        return e(jt(f, 32), "invalid yParityAndS"), { v: Tt(f)[0] & 128 ? 28 : 27 };
      if (d != null) {
        switch (Rt(d, "sig.yParity")) {
          case 0:
            return { v: 27 };
          case 1:
            return { v: 28 };
        }
        e(!1, "invalid yParity");
      }
      e(!1, "missing v");
    }(t.v, t.yParityAndS, t.yParity), _ = new ir(Ps, i, s, c);
    return a && P(_, $i, a), e(t.yParity == null || Rt(t.yParity, "sig.yParity") === _.yParity, "yParity mismatch"), e(t.yParityAndS == null || t.yParityAndS === _.yParityAndS, "yParityAndS mismatch"), _;
  }
};
Do = new WeakMap(), Ko = new WeakMap(), Vo = new WeakMap(), $i = new WeakMap();
let ur = ir;
var mn;
const xi = class xi {
  /**
   *  Creates a new **SigningKey** for %%privateKey%%.
   */
  constructor(t) {
    j(this, mn);
    T(So(t) === 32, "invalid private key", "privateKey", "[REDACTED]"), P(this, mn, ut(t));
  }
  /**
   *  The private key.
   */
  get privateKey() {
    return w(this, mn);
  }
  /**
   *  The uncompressed public key.
   *
   * This will always begin with the prefix ``0x04`` and be 132
   * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).
   */
  get publicKey() {
    return xi.computePublicKey(w(this, mn));
  }
  /**
   *  The compressed public key.
   *
   *  This will always begin with either the prefix ``0x02`` or ``0x03``
   *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal
   *  nibbles)
   */
  get compressedPublicKey() {
    return xi.computePublicKey(w(this, mn), !0);
  }
  /**
   *  Return the signature of the signed %%digest%%.
   */
  sign(t) {
    T(So(t) === 32, "invalid digest length", "digest", t);
    const e = Yn.sign(Ae(t), Ae(w(this, mn)), {
      lowS: !0
    });
    return ur.from({
      r: di(e.r, 32),
      s: di(e.s, 32),
      v: e.recovery ? 28 : 27
    });
  }
  /**
   *  Returns the [[link-wiki-ecdh]] shared secret between this
   *  private key and the %%other%% key.
   *
   *  The %%other%% key may be any type of key, a raw public key,
   *  a compressed/uncompressed pubic key or aprivate key.
   *
   *  Best practice is usually to use a cryptographic hash on the
   *  returned value before using it as a symetric secret.
   *
   *  @example:
   *    sign1 = new SigningKey(id("some-secret-1"))
   *    sign2 = new SigningKey(id("some-secret-2"))
   *
   *    // Notice that privA.computeSharedSecret(pubB)...
   *    sign1.computeSharedSecret(sign2.publicKey)
   *    //_result:
   *
   *    // ...is equal to privB.computeSharedSecret(pubA).
   *    sign2.computeSharedSecret(sign1.publicKey)
   *    //_result:
   */
  computeSharedSecret(t) {
    const e = xi.computePublicKey(t);
    return ut(Yn.getSharedSecret(Ae(w(this, mn)), Tt(e), !1));
  }
  /**
   *  Compute the public key for %%key%%, optionally %%compressed%%.
   *
   *  The %%key%% may be any type of key, a raw public key, a
   *  compressed/uncompressed public key or private key.
   *
   *  @example:
   *    sign = new SigningKey(id("some-secret"));
   *
   *    // Compute the uncompressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey)
   *    //_result:
   *
   *    // Compute the compressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey, true)
   *    //_result:
   *
   *    // Compute the uncompressed public key
   *    SigningKey.computePublicKey(sign.publicKey, false);
   *    //_result:
   *
   *    // Compute the Compressed a public key
   *    SigningKey.computePublicKey(sign.publicKey, true);
   *    //_result:
   */
  static computePublicKey(t, e) {
    let r = Tt(t, "key");
    if (r.length === 32) {
      const s = Yn.getPublicKey(r, !!e);
      return ut(s);
    }
    if (r.length === 64) {
      const s = new Uint8Array(65);
      s[0] = 4, s.set(r, 1), r = s;
    }
    const i = Yn.ProjectivePoint.fromHex(r);
    return ut(i.toRawBytes(e));
  }
  /**
   *  Returns the public key for the private key which produced the
   *  %%signature%% for the given %%digest%%.
   *
   *  @example:
   *    key = new SigningKey(id("some-secret"))
   *    digest = id("hello world")
   *    sig = key.sign(digest)
   *
   *    // Notice the signer public key...
   *    key.publicKey
   *    //_result:
   *
   *    // ...is equal to the recovered public key
   *    SigningKey.recoverPublicKey(digest, sig)
   *    //_result:
   *
   */
  static recoverPublicKey(t, e) {
    T(So(t) === 32, "invalid digest length", "digest", t);
    const r = ur.from(e);
    let i = Yn.Signature.fromCompact(Ae(Xt([r.r, r.s])));
    i = i.addRecoveryBit(r.yParity);
    const s = i.recoverPublicKey(Ae(t));
    return T(s != null, "invalid signautre for digest", "signature", e), "0x" + s.toHex(!1);
  }
  /**
   *  Returns the point resulting from adding the ellipic curve points
   *  %%p0%% and %%p1%%.
   *
   *  This is not a common function most developers should require, but
   *  can be useful for certain privacy-specific techniques.
   *
   *  For example, it is used by [[HDNodeWallet]] to compute child
   *  addresses from parent public keys and chain codes.
   */
  static addPoints(t, e, r) {
    const i = Yn.ProjectivePoint.fromHex(xi.computePublicKey(t).substring(2)), s = Yn.ProjectivePoint.fromHex(xi.computePublicKey(e).substring(2));
    return "0x" + i.add(s).toHex(!!r);
  }
};
mn = new WeakMap();
let rc = xi;
const yA = BigInt(0), bA = BigInt(36);
function jh(n) {
  n = n.toLowerCase();
  const t = n.substring(2).split(""), e = new Uint8Array(40);
  for (let i = 0; i < 40; i++)
    e[i] = t[i].charCodeAt(0);
  const r = Tt(ee(e));
  for (let i = 0; i < 40; i += 2)
    r[i >> 1] >> 4 >= 8 && (t[i] = t[i].toUpperCase()), (r[i >> 1] & 15) >= 8 && (t[i + 1] = t[i + 1].toUpperCase());
  return "0x" + t.join("");
}
const Lf = {};
for (let n = 0; n < 10; n++)
  Lf[String(n)] = String(n);
for (let n = 0; n < 26; n++)
  Lf[String.fromCharCode(65 + n)] = String(10 + n);
const Hh = 15;
function AA(n) {
  n = n.toUpperCase(), n = n.substring(4) + n.substring(0, 2) + "00";
  let t = n.split("").map((r) => Lf[r]).join("");
  for (; t.length >= Hh; ) {
    let r = t.substring(0, Hh);
    t = parseInt(r, 10) % 97 + t.substring(r.length);
  }
  let e = String(98 - parseInt(t, 10) % 97);
  for (; e.length < 2; )
    e = "0" + e;
  return e;
}
const mA = function() {
  const n = {};
  for (let t = 0; t < 36; t++) {
    const e = "0123456789abcdefghijklmnopqrstuvwxyz"[t];
    n[e] = BigInt(t);
  }
  return n;
}();
function SA(n) {
  n = n.toLowerCase();
  let t = yA;
  for (let e = 0; e < n.length; e++)
    t = t * bA + mA[n[e]];
  return t;
}
function zt(n) {
  if (T(typeof n == "string", "invalid address", "address", n), n.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    n.startsWith("0x") || (n = "0x" + n);
    const t = jh(n);
    return T(!n.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || t === n, "bad address checksum", "address", n), t;
  }
  if (n.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    T(n.substring(2, 4) === AA(n), "bad icap checksum", "address", n);
    let t = SA(n.substring(4)).toString(16);
    for (; t.length < 40; )
      t = "0" + t;
    return jh("0x" + t);
  }
  T(!1, "invalid address", "address", n);
}
function EA(n) {
  const t = zt(n.from);
  let r = ht(n.nonce, "tx.nonce").toString(16);
  return r === "0" ? r = "0x" : r.length % 2 ? r = "0x0" + r : r = "0x" + r, zt(Jt(ee(hs([t, r])), 12));
}
function Kg(n) {
  return n && typeof n.getAddress == "function";
}
function Tn(n) {
  try {
    return zt(n), !0;
  } catch {
  }
  return !1;
}
async function ru(n, t) {
  const e = await t;
  return (e == null || e === "0x0000000000000000000000000000000000000000") && (et(typeof n != "string", "unconfigured name", "UNCONFIGURED_NAME", { value: n }), T(!1, "invalid AddressLike value; did not resolve to a value address", "target", n)), zt(e);
}
function Ee(n, t) {
  if (typeof n == "string")
    return n.match(/^0x[0-9a-f]{40}$/i) ? zt(n) : (et(t != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", { operation: "resolveName" }), ru(n, t.resolveName(n)));
  if (Kg(n))
    return ru(n, n.getAddress());
  if (n && typeof n.then == "function")
    return ru(n, n);
  T(!1, "unsupported addressable value", "target", n);
}
const hn = {};
function lt(n, t) {
  let e = !1;
  return t < 0 && (e = !0, t *= -1), new ge(hn, `${e ? "" : "u"}int${t}`, n, { signed: e, width: t });
}
function Ut(n, t) {
  return new ge(hn, `bytes${t || ""}`, n, { size: t });
}
const Yh = Symbol.for("_ethers_typed");
var qi;
const pn = class pn {
  /**
   *  @_ignore:
   */
  constructor(t, e, r, i) {
    /**
     *  The type, as a Solidity-compatible type.
     */
    U(this, "type");
    /**
     *  The actual value.
     */
    U(this, "value");
    j(this, qi);
    /**
     *  @_ignore:
     */
    U(this, "_typedSymbol");
    i == null && (i = null), K_(hn, t, "Typed"), gt(this, { _typedSymbol: Yh, type: e, value: r }), P(this, qi, i), this.format();
  }
  /**
   *  Format the type as a Human-Readable type.
   */
  format() {
    if (this.type === "array")
      throw new Error("");
    if (this.type === "dynamicArray")
      throw new Error("");
    return this.type === "tuple" ? `tuple(${this.value.map((t) => t.format()).join(",")})` : this.type;
  }
  /**
   *  The default value returned by this type.
   */
  defaultValue() {
    return 0;
  }
  /**
   *  The minimum value for numeric types.
   */
  minValue() {
    return 0;
  }
  /**
   *  The maximum value for numeric types.
   */
  maxValue() {
    return 0;
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].
   */
  isBigInt() {
    return !!this.type.match(/^u?int[0-9]+$/);
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedData]].
   */
  isData() {
    return this.type.startsWith("bytes");
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedString]].
   */
  isString() {
    return this.type === "string";
  }
  /**
   *  Returns the tuple name, if this is a tuple. Throws otherwise.
   */
  get tupleName() {
    if (this.type !== "tuple")
      throw TypeError("not a tuple");
    return w(this, qi);
  }
  // Returns the length of this type as an array
  // - `null` indicates the length is unforced, it could be dynamic
  // - `-1` indicates the length is dynamic
  // - any other value indicates it is a static array and is its length
  /**
   *  Returns the length of the array type or ``-1`` if it is dynamic.
   *
   *  Throws if the type is not an array.
   */
  get arrayLength() {
    if (this.type !== "array")
      throw TypeError("not an array");
    return w(this, qi) === !0 ? -1 : w(this, qi) === !1 ? this.value.length : null;
  }
  /**
   *  Returns a new **Typed** of %%type%% with the %%value%%.
   */
  static from(t, e) {
    return new pn(hn, t, e);
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static uint8(t) {
    return lt(t, 8);
  }
  /**
   *  Return a new ``uint16`` type for %%v%%.
   */
  static uint16(t) {
    return lt(t, 16);
  }
  /**
   *  Return a new ``uint24`` type for %%v%%.
   */
  static uint24(t) {
    return lt(t, 24);
  }
  /**
   *  Return a new ``uint32`` type for %%v%%.
   */
  static uint32(t) {
    return lt(t, 32);
  }
  /**
   *  Return a new ``uint40`` type for %%v%%.
   */
  static uint40(t) {
    return lt(t, 40);
  }
  /**
   *  Return a new ``uint48`` type for %%v%%.
   */
  static uint48(t) {
    return lt(t, 48);
  }
  /**
   *  Return a new ``uint56`` type for %%v%%.
   */
  static uint56(t) {
    return lt(t, 56);
  }
  /**
   *  Return a new ``uint64`` type for %%v%%.
   */
  static uint64(t) {
    return lt(t, 64);
  }
  /**
   *  Return a new ``uint72`` type for %%v%%.
   */
  static uint72(t) {
    return lt(t, 72);
  }
  /**
   *  Return a new ``uint80`` type for %%v%%.
   */
  static uint80(t) {
    return lt(t, 80);
  }
  /**
   *  Return a new ``uint88`` type for %%v%%.
   */
  static uint88(t) {
    return lt(t, 88);
  }
  /**
   *  Return a new ``uint96`` type for %%v%%.
   */
  static uint96(t) {
    return lt(t, 96);
  }
  /**
   *  Return a new ``uint104`` type for %%v%%.
   */
  static uint104(t) {
    return lt(t, 104);
  }
  /**
   *  Return a new ``uint112`` type for %%v%%.
   */
  static uint112(t) {
    return lt(t, 112);
  }
  /**
   *  Return a new ``uint120`` type for %%v%%.
   */
  static uint120(t) {
    return lt(t, 120);
  }
  /**
   *  Return a new ``uint128`` type for %%v%%.
   */
  static uint128(t) {
    return lt(t, 128);
  }
  /**
   *  Return a new ``uint136`` type for %%v%%.
   */
  static uint136(t) {
    return lt(t, 136);
  }
  /**
   *  Return a new ``uint144`` type for %%v%%.
   */
  static uint144(t) {
    return lt(t, 144);
  }
  /**
   *  Return a new ``uint152`` type for %%v%%.
   */
  static uint152(t) {
    return lt(t, 152);
  }
  /**
   *  Return a new ``uint160`` type for %%v%%.
   */
  static uint160(t) {
    return lt(t, 160);
  }
  /**
   *  Return a new ``uint168`` type for %%v%%.
   */
  static uint168(t) {
    return lt(t, 168);
  }
  /**
   *  Return a new ``uint176`` type for %%v%%.
   */
  static uint176(t) {
    return lt(t, 176);
  }
  /**
   *  Return a new ``uint184`` type for %%v%%.
   */
  static uint184(t) {
    return lt(t, 184);
  }
  /**
   *  Return a new ``uint192`` type for %%v%%.
   */
  static uint192(t) {
    return lt(t, 192);
  }
  /**
   *  Return a new ``uint200`` type for %%v%%.
   */
  static uint200(t) {
    return lt(t, 200);
  }
  /**
   *  Return a new ``uint208`` type for %%v%%.
   */
  static uint208(t) {
    return lt(t, 208);
  }
  /**
   *  Return a new ``uint216`` type for %%v%%.
   */
  static uint216(t) {
    return lt(t, 216);
  }
  /**
   *  Return a new ``uint224`` type for %%v%%.
   */
  static uint224(t) {
    return lt(t, 224);
  }
  /**
   *  Return a new ``uint232`` type for %%v%%.
   */
  static uint232(t) {
    return lt(t, 232);
  }
  /**
   *  Return a new ``uint240`` type for %%v%%.
   */
  static uint240(t) {
    return lt(t, 240);
  }
  /**
   *  Return a new ``uint248`` type for %%v%%.
   */
  static uint248(t) {
    return lt(t, 248);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint256(t) {
    return lt(t, 256);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint(t) {
    return lt(t, 256);
  }
  /**
   *  Return a new ``int8`` type for %%v%%.
   */
  static int8(t) {
    return lt(t, -8);
  }
  /**
   *  Return a new ``int16`` type for %%v%%.
   */
  static int16(t) {
    return lt(t, -16);
  }
  /**
   *  Return a new ``int24`` type for %%v%%.
   */
  static int24(t) {
    return lt(t, -24);
  }
  /**
   *  Return a new ``int32`` type for %%v%%.
   */
  static int32(t) {
    return lt(t, -32);
  }
  /**
   *  Return a new ``int40`` type for %%v%%.
   */
  static int40(t) {
    return lt(t, -40);
  }
  /**
   *  Return a new ``int48`` type for %%v%%.
   */
  static int48(t) {
    return lt(t, -48);
  }
  /**
   *  Return a new ``int56`` type for %%v%%.
   */
  static int56(t) {
    return lt(t, -56);
  }
  /**
   *  Return a new ``int64`` type for %%v%%.
   */
  static int64(t) {
    return lt(t, -64);
  }
  /**
   *  Return a new ``int72`` type for %%v%%.
   */
  static int72(t) {
    return lt(t, -72);
  }
  /**
   *  Return a new ``int80`` type for %%v%%.
   */
  static int80(t) {
    return lt(t, -80);
  }
  /**
   *  Return a new ``int88`` type for %%v%%.
   */
  static int88(t) {
    return lt(t, -88);
  }
  /**
   *  Return a new ``int96`` type for %%v%%.
   */
  static int96(t) {
    return lt(t, -96);
  }
  /**
   *  Return a new ``int104`` type for %%v%%.
   */
  static int104(t) {
    return lt(t, -104);
  }
  /**
   *  Return a new ``int112`` type for %%v%%.
   */
  static int112(t) {
    return lt(t, -112);
  }
  /**
   *  Return a new ``int120`` type for %%v%%.
   */
  static int120(t) {
    return lt(t, -120);
  }
  /**
   *  Return a new ``int128`` type for %%v%%.
   */
  static int128(t) {
    return lt(t, -128);
  }
  /**
   *  Return a new ``int136`` type for %%v%%.
   */
  static int136(t) {
    return lt(t, -136);
  }
  /**
   *  Return a new ``int144`` type for %%v%%.
   */
  static int144(t) {
    return lt(t, -144);
  }
  /**
   *  Return a new ``int52`` type for %%v%%.
   */
  static int152(t) {
    return lt(t, -152);
  }
  /**
   *  Return a new ``int160`` type for %%v%%.
   */
  static int160(t) {
    return lt(t, -160);
  }
  /**
   *  Return a new ``int168`` type for %%v%%.
   */
  static int168(t) {
    return lt(t, -168);
  }
  /**
   *  Return a new ``int176`` type for %%v%%.
   */
  static int176(t) {
    return lt(t, -176);
  }
  /**
   *  Return a new ``int184`` type for %%v%%.
   */
  static int184(t) {
    return lt(t, -184);
  }
  /**
   *  Return a new ``int92`` type for %%v%%.
   */
  static int192(t) {
    return lt(t, -192);
  }
  /**
   *  Return a new ``int200`` type for %%v%%.
   */
  static int200(t) {
    return lt(t, -200);
  }
  /**
   *  Return a new ``int208`` type for %%v%%.
   */
  static int208(t) {
    return lt(t, -208);
  }
  /**
   *  Return a new ``int216`` type for %%v%%.
   */
  static int216(t) {
    return lt(t, -216);
  }
  /**
   *  Return a new ``int224`` type for %%v%%.
   */
  static int224(t) {
    return lt(t, -224);
  }
  /**
   *  Return a new ``int232`` type for %%v%%.
   */
  static int232(t) {
    return lt(t, -232);
  }
  /**
   *  Return a new ``int240`` type for %%v%%.
   */
  static int240(t) {
    return lt(t, -240);
  }
  /**
   *  Return a new ``int248`` type for %%v%%.
   */
  static int248(t) {
    return lt(t, -248);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int256(t) {
    return lt(t, -256);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int(t) {
    return lt(t, -256);
  }
  /**
   *  Return a new ``bytes1`` type for %%v%%.
   */
  static bytes1(t) {
    return Ut(t, 1);
  }
  /**
   *  Return a new ``bytes2`` type for %%v%%.
   */
  static bytes2(t) {
    return Ut(t, 2);
  }
  /**
   *  Return a new ``bytes3`` type for %%v%%.
   */
  static bytes3(t) {
    return Ut(t, 3);
  }
  /**
   *  Return a new ``bytes4`` type for %%v%%.
   */
  static bytes4(t) {
    return Ut(t, 4);
  }
  /**
   *  Return a new ``bytes5`` type for %%v%%.
   */
  static bytes5(t) {
    return Ut(t, 5);
  }
  /**
   *  Return a new ``bytes6`` type for %%v%%.
   */
  static bytes6(t) {
    return Ut(t, 6);
  }
  /**
   *  Return a new ``bytes7`` type for %%v%%.
   */
  static bytes7(t) {
    return Ut(t, 7);
  }
  /**
   *  Return a new ``bytes8`` type for %%v%%.
   */
  static bytes8(t) {
    return Ut(t, 8);
  }
  /**
   *  Return a new ``bytes9`` type for %%v%%.
   */
  static bytes9(t) {
    return Ut(t, 9);
  }
  /**
   *  Return a new ``bytes10`` type for %%v%%.
   */
  static bytes10(t) {
    return Ut(t, 10);
  }
  /**
   *  Return a new ``bytes11`` type for %%v%%.
   */
  static bytes11(t) {
    return Ut(t, 11);
  }
  /**
   *  Return a new ``bytes12`` type for %%v%%.
   */
  static bytes12(t) {
    return Ut(t, 12);
  }
  /**
   *  Return a new ``bytes13`` type for %%v%%.
   */
  static bytes13(t) {
    return Ut(t, 13);
  }
  /**
   *  Return a new ``bytes14`` type for %%v%%.
   */
  static bytes14(t) {
    return Ut(t, 14);
  }
  /**
   *  Return a new ``bytes15`` type for %%v%%.
   */
  static bytes15(t) {
    return Ut(t, 15);
  }
  /**
   *  Return a new ``bytes16`` type for %%v%%.
   */
  static bytes16(t) {
    return Ut(t, 16);
  }
  /**
   *  Return a new ``bytes17`` type for %%v%%.
   */
  static bytes17(t) {
    return Ut(t, 17);
  }
  /**
   *  Return a new ``bytes18`` type for %%v%%.
   */
  static bytes18(t) {
    return Ut(t, 18);
  }
  /**
   *  Return a new ``bytes19`` type for %%v%%.
   */
  static bytes19(t) {
    return Ut(t, 19);
  }
  /**
   *  Return a new ``bytes20`` type for %%v%%.
   */
  static bytes20(t) {
    return Ut(t, 20);
  }
  /**
   *  Return a new ``bytes21`` type for %%v%%.
   */
  static bytes21(t) {
    return Ut(t, 21);
  }
  /**
   *  Return a new ``bytes22`` type for %%v%%.
   */
  static bytes22(t) {
    return Ut(t, 22);
  }
  /**
   *  Return a new ``bytes23`` type for %%v%%.
   */
  static bytes23(t) {
    return Ut(t, 23);
  }
  /**
   *  Return a new ``bytes24`` type for %%v%%.
   */
  static bytes24(t) {
    return Ut(t, 24);
  }
  /**
   *  Return a new ``bytes25`` type for %%v%%.
   */
  static bytes25(t) {
    return Ut(t, 25);
  }
  /**
   *  Return a new ``bytes26`` type for %%v%%.
   */
  static bytes26(t) {
    return Ut(t, 26);
  }
  /**
   *  Return a new ``bytes27`` type for %%v%%.
   */
  static bytes27(t) {
    return Ut(t, 27);
  }
  /**
   *  Return a new ``bytes28`` type for %%v%%.
   */
  static bytes28(t) {
    return Ut(t, 28);
  }
  /**
   *  Return a new ``bytes29`` type for %%v%%.
   */
  static bytes29(t) {
    return Ut(t, 29);
  }
  /**
   *  Return a new ``bytes30`` type for %%v%%.
   */
  static bytes30(t) {
    return Ut(t, 30);
  }
  /**
   *  Return a new ``bytes31`` type for %%v%%.
   */
  static bytes31(t) {
    return Ut(t, 31);
  }
  /**
   *  Return a new ``bytes32`` type for %%v%%.
   */
  static bytes32(t) {
    return Ut(t, 32);
  }
  /**
   *  Return a new ``address`` type for %%v%%.
   */
  static address(t) {
    return new pn(hn, "address", t);
  }
  /**
   *  Return a new ``bool`` type for %%v%%.
   */
  static bool(t) {
    return new pn(hn, "bool", !!t);
  }
  /**
   *  Return a new ``bytes`` type for %%v%%.
   */
  static bytes(t) {
    return new pn(hn, "bytes", t);
  }
  /**
   *  Return a new ``string`` type for %%v%%.
   */
  static string(t) {
    return new pn(hn, "string", t);
  }
  /**
   *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.
   */
  static array(t, e) {
    throw new Error("not implemented yet");
  }
  /**
   *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.
   */
  static tuple(t, e) {
    throw new Error("not implemented yet");
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static overrides(t) {
    return new pn(hn, "overrides", Object.assign({}, t));
  }
  /**
   *  Returns true only if %%value%% is a [[Typed]] instance.
   */
  static isTyped(t) {
    return t && typeof t == "object" && "_typedSymbol" in t && t._typedSymbol === Yh;
  }
  /**
   *  If the value is a [[Typed]] instance, validates the underlying value
   *  and returns it, otherwise returns value directly.
   *
   *  This is useful for functions that with to accept either a [[Typed]]
   *  object or values.
   */
  static dereference(t, e) {
    if (pn.isTyped(t)) {
      if (t.type !== e)
        throw new Error(`invalid type: expecetd ${e}, got ${t.type}`);
      return t.value;
    }
    return t;
  }
};
qi = new WeakMap();
let ge = pn;
class RA extends Ln {
  constructor(t) {
    super("address", "address", t, !1);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(t, e) {
    let r = ge.dereference(e, "string");
    try {
      r = zt(r);
    } catch (i) {
      return this._throwError(i.message, e);
    }
    return t.writeValue(r);
  }
  decode(t) {
    return zt(di(t.readValue(), 20));
  }
}
class PA extends Ln {
  constructor(e) {
    super(e.name, e.type, "_", e.dynamic);
    U(this, "coder");
    this.coder = e;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(e, r) {
    return this.coder.encode(e, r);
  }
  decode(e) {
    return this.coder.decode(e);
  }
}
function Vg(n, t, e) {
  let r = [];
  if (Array.isArray(e))
    r = e;
  else if (e && typeof e == "object") {
    let _ = {};
    r = t.map((p) => {
      const f = p.localName;
      return et(f, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", { argument: "values", info: { coder: p }, value: e }), et(!_[f], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", { argument: "values", info: { coder: p }, value: e }), _[f] = !0, e[f];
    });
  } else
    T(!1, "invalid tuple value", "tuple", e);
  T(t.length === r.length, "types/value length mismatch", "tuple", e);
  let i = new Fu(), s = new Fu(), a = [];
  t.forEach((_, p) => {
    let f = r[p];
    if (_.dynamic) {
      let d = s.length;
      _.encode(s, f);
      let y = i.writeUpdatableValue();
      a.push((b) => {
        y(b + d);
      });
    } else
      _.encode(i, f);
  }), a.forEach((_) => {
    _(i.length);
  });
  let c = n.appendWriter(i);
  return c += n.appendWriter(s), c;
}
function jg(n, t) {
  let e = [], r = [], i = n.subReader(0);
  return t.forEach((s) => {
    let a = null;
    if (s.dynamic) {
      let c = n.readIndex(), _ = i.subReader(c);
      try {
        a = s.decode(_);
      } catch (p) {
        if (fe(p, "BUFFER_OVERRUN"))
          throw p;
        a = p, a.baseType = s.name, a.name = s.localName, a.type = s.type;
      }
    } else
      try {
        a = s.decode(n);
      } catch (c) {
        if (fe(c, "BUFFER_OVERRUN"))
          throw c;
        a = c, a.baseType = s.name, a.name = s.localName, a.type = s.type;
      }
    if (a == null)
      throw new Error("investigate");
    e.push(a), r.push(s.localName || null);
  }), Aa.fromItems(e, r);
}
class vA extends Ln {
  constructor(e, r, i) {
    const s = e.type + "[" + (r >= 0 ? r : "") + "]", a = r === -1 || e.dynamic;
    super("array", s, i, a);
    U(this, "coder");
    U(this, "length");
    gt(this, { coder: e, length: r });
  }
  defaultValue() {
    const e = this.coder.defaultValue(), r = [];
    for (let i = 0; i < this.length; i++)
      r.push(e);
    return r;
  }
  encode(e, r) {
    const i = ge.dereference(r, "array");
    Array.isArray(i) || this._throwError("expected array value", i);
    let s = this.length;
    s === -1 && (s = i.length, e.writeValue(i.length)), Zw(i.length, s, "coder array" + (this.localName ? " " + this.localName : ""));
    let a = [];
    for (let c = 0; c < i.length; c++)
      a.push(this.coder);
    return Vg(e, a, i);
  }
  decode(e) {
    let r = this.length;
    r === -1 && (r = e.readIndex(), et(r * Se <= e.dataLength, "insufficient data length", "BUFFER_OVERRUN", { buffer: e.bytes, offset: r * Se, length: e.dataLength }));
    let i = [];
    for (let s = 0; s < r; s++)
      i.push(new PA(this.coder));
    return jg(e, i);
  }
}
class MA extends Ln {
  constructor(t) {
    super("bool", "bool", t, !1);
  }
  defaultValue() {
    return !1;
  }
  encode(t, e) {
    const r = ge.dereference(e, "bool");
    return t.writeValue(r ? 1 : 0);
  }
  decode(t) {
    return !!t.readValue();
  }
}
class Hg extends Ln {
  constructor(t, e) {
    super(t, t, e, !0);
  }
  defaultValue() {
    return "0x";
  }
  encode(t, e) {
    e = Ae(e);
    let r = t.writeValue(e.length);
    return r += t.writeBytes(e), r;
  }
  decode(t) {
    return t.readBytes(t.readIndex(), !0);
  }
}
class xA extends Hg {
  constructor(t) {
    super("bytes", t);
  }
  decode(t) {
    return ut(super.decode(t));
  }
}
class BA extends Ln {
  constructor(e, r) {
    let i = "bytes" + String(e);
    super(i, i, r, !1);
    U(this, "size");
    gt(this, { size: e }, { size: "number" });
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(e, r) {
    let i = Ae(ge.dereference(r, this.type));
    return i.length !== this.size && this._throwError("incorrect data length", r), e.writeBytes(i);
  }
  decode(e) {
    return ut(e.readBytes(this.size));
  }
}
const CA = new Uint8Array([]);
class IA extends Ln {
  constructor(t) {
    super("null", "", t, !1);
  }
  defaultValue() {
    return null;
  }
  encode(t, e) {
    return e != null && this._throwError("not null", e), t.writeBytes(CA);
  }
  decode(t) {
    return t.readBytes(0), null;
  }
}
const NA = BigInt(0), OA = BigInt(1), TA = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
class zA extends Ln {
  constructor(e, r, i) {
    const s = (r ? "int" : "uint") + e * 8;
    super(s, s, i, !1);
    U(this, "size");
    U(this, "signed");
    gt(this, { size: e, signed: r }, { size: "number", signed: "boolean" });
  }
  defaultValue() {
    return 0;
  }
  encode(e, r) {
    let i = ht(ge.dereference(r, this.type)), s = Da(TA, Se * 8);
    if (this.signed) {
      let a = Da(s, this.size * 8 - 1);
      (i > a || i < -(a + OA)) && this._throwError("value out-of-bounds", r), i = eg(i, 8 * Se);
    } else (i < NA || i > Da(s, this.size * 8)) && this._throwError("value out-of-bounds", r);
    return e.writeValue(i);
  }
  decode(e) {
    let r = Da(e.readValue(), this.size * 8);
    return this.signed && (r = Ib(r, this.size * 8)), r;
  }
}
class kA extends Hg {
  constructor(t) {
    super("string", t);
  }
  defaultValue() {
    return "";
  }
  encode(t, e) {
    return super.encode(t, On(ge.dereference(e, "string")));
  }
  decode(t) {
    return d_(super.decode(t));
  }
}
class Vc extends Ln {
  constructor(e, r) {
    let i = !1;
    const s = [];
    e.forEach((c) => {
      c.dynamic && (i = !0), s.push(c.type);
    });
    const a = "tuple(" + s.join(",") + ")";
    super("tuple", a, r, i);
    U(this, "coders");
    gt(this, { coders: Object.freeze(e.slice()) });
  }
  defaultValue() {
    const e = [];
    this.coders.forEach((i) => {
      e.push(i.defaultValue());
    });
    const r = this.coders.reduce((i, s) => {
      const a = s.localName;
      return a && (i[a] || (i[a] = 0), i[a]++), i;
    }, {});
    return this.coders.forEach((i, s) => {
      let a = i.localName;
      !a || r[a] !== 1 || (a === "length" && (a = "_length"), e[a] == null && (e[a] = e[s]));
    }), Object.freeze(e);
  }
  encode(e, r) {
    const i = ge.dereference(r, "tuple");
    return Vg(e, this.coders, i);
  }
  decode(e) {
    return jg(e, this.coders);
  }
}
function ps(n) {
  return ee(On(n));
}
var UA = "AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI";
const Qh = /* @__PURE__ */ new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]), Wh = 4;
function FA(n) {
  let t = 0;
  function e() {
    return n[t++] << 8 | n[t++];
  }
  let r = e(), i = 1, s = [0, 1];
  for (let D = 1; D < r; D++)
    s.push(i += e());
  let a = e(), c = t;
  t += a;
  let _ = 0, p = 0;
  function f() {
    return _ == 0 && (p = p << 8 | n[t++], _ = 8), p >> --_ & 1;
  }
  const d = 31, y = 2 ** d, b = y >>> 1, v = b >> 1, R = y - 1;
  let M = 0;
  for (let D = 0; D < d; D++) M = M << 1 | f();
  let A = [], B = 0, N = y;
  for (; ; ) {
    let D = Math.floor(((M - B + 1) * i - 1) / N), $ = 0, X = r;
    for (; X - $ > 1; ) {
      let ft = $ + X >>> 1;
      D < s[ft] ? X = ft : $ = ft;
    }
    if ($ == 0) break;
    A.push($);
    let V = B + Math.floor(N * s[$] / i), nt = B + Math.floor(N * s[$ + 1] / i) - 1;
    for (; !((V ^ nt) & b); )
      M = M << 1 & R | f(), V = V << 1 & R, nt = nt << 1 & R | 1;
    for (; V & ~nt & v; )
      M = M & b | M << 1 & R >>> 1 | f(), V = V << 1 ^ b, nt = (nt ^ b) << 1 | b | 1;
    B = V, N = 1 + nt - V;
  }
  let G = r - 4;
  return A.map((D) => {
    switch (D - G) {
      case 3:
        return G + 65792 + (n[c++] << 16 | n[c++] << 8 | n[c++]);
      case 2:
        return G + 256 + (n[c++] << 8 | n[c++]);
      case 1:
        return G + n[c++];
      default:
        return D - 1;
    }
  });
}
function GA(n) {
  let t = 0;
  return () => n[t++];
}
function Yg(n) {
  return GA(FA(LA(n)));
}
function LA(n) {
  let t = [];
  [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((i, s) => t[i.charCodeAt(0)] = s);
  let e = n.length, r = new Uint8Array(6 * e >> 3);
  for (let i = 0, s = 0, a = 0, c = 0; i < e; i++)
    c = c << 6 | t[n.charCodeAt(i)], a += 6, a >= 8 && (r[s++] = c >> (a -= 8));
  return r;
}
function DA(n) {
  return n & 1 ? ~n >> 1 : n >> 1;
}
function KA(n, t) {
  let e = Array(n);
  for (let r = 0, i = 0; r < n; r++) e[r] = i += DA(t());
  return e;
}
function nc(n, t = 0) {
  let e = [];
  for (; ; ) {
    let r = n(), i = n();
    if (!i) break;
    t += r;
    for (let s = 0; s < i; s++)
      e.push(t + s);
    t += i + 1;
  }
  return e;
}
function Qg(n) {
  return ic(() => {
    let t = nc(n);
    if (t.length) return t;
  });
}
function Wg(n) {
  let t = [];
  for (; ; ) {
    let e = n();
    if (e == 0) break;
    t.push(VA(e, n));
  }
  for (; ; ) {
    let e = n() - 1;
    if (e < 0) break;
    t.push(jA(e, n));
  }
  return t.flat();
}
function ic(n) {
  let t = [];
  for (; ; ) {
    let e = n(t.length);
    if (!e) break;
    t.push(e);
  }
  return t;
}
function Jg(n, t, e) {
  let r = Array(n).fill().map(() => []);
  for (let i = 0; i < t; i++)
    KA(n, e).forEach((s, a) => r[a].push(s));
  return r;
}
function VA(n, t) {
  let e = 1 + t(), r = t(), i = ic(t);
  return Jg(i.length, 1 + n, t).flatMap((a, c) => {
    let [_, ...p] = a;
    return Array(i[c]).fill().map((f, d) => {
      let y = d * r;
      return [_ + d * e, p.map((b) => b + y)];
    });
  });
}
function jA(n, t) {
  let e = 1 + t();
  return Jg(e, 1 + n, t).map((i) => [i[0], i.slice(1)]);
}
function HA(n) {
  let t = [], e = nc(n);
  return i(r([]), []), t;
  function r(s) {
    let a = n(), c = ic(() => {
      let _ = nc(n).map((p) => e[p]);
      if (_.length) return r(_);
    });
    return { S: a, B: c, Q: s };
  }
  function i({ S: s, B: a }, c, _) {
    if (!(s & 4 && _ === c[c.length - 1])) {
      s & 2 && (_ = c[c.length - 1]), s & 1 && t.push(c);
      for (let p of a)
        for (let f of p.Q)
          i(p, [...c, f], _);
    }
  }
}
function YA(n) {
  return n.toString(16).toUpperCase().padStart(2, "0");
}
function $g(n) {
  return `{${YA(n)}}`;
}
function QA(n) {
  let t = [];
  for (let e = 0, r = n.length; e < r; ) {
    let i = n.codePointAt(e);
    e += i < 65536 ? 1 : 2, t.push(i);
  }
  return t;
}
function Pa(n) {
  let e = n.length;
  if (e < 4096) return String.fromCodePoint(...n);
  let r = [];
  for (let i = 0; i < e; )
    r.push(String.fromCodePoint(...n.slice(i, i += 4096)));
  return r.join("");
}
function WA(n, t) {
  let e = n.length, r = e - t.length;
  for (let i = 0; r == 0 && i < e; i++) r = n[i] - t[i];
  return r;
}
var JA = "AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g";
const sc = 44032, g_ = 4352, y_ = 4449, b_ = 4519, qg = 19, Zg = 21, va = 28, A_ = Zg * va, $A = qg * A_, qA = sc + $A, ZA = g_ + qg, XA = y_ + Zg, tm = b_ + va;
function Va(n) {
  return n >> 24 & 255;
}
function Xg(n) {
  return n & 16777215;
}
let Yu, Jh, Qu, $c;
function em() {
  let n = Yg(JA);
  Yu = new Map(Qg(n).flatMap((t, e) => t.map((r) => [r, e + 1 << 24]))), Jh = new Set(nc(n)), Qu = /* @__PURE__ */ new Map(), $c = /* @__PURE__ */ new Map();
  for (let [t, e] of Wg(n)) {
    if (!Jh.has(t) && e.length == 2) {
      let [r, i] = e, s = $c.get(r);
      s || (s = /* @__PURE__ */ new Map(), $c.set(r, s)), s.set(i, t);
    }
    Qu.set(t, e.reverse());
  }
}
function t0(n) {
  return n >= sc && n < qA;
}
function rm(n, t) {
  if (n >= g_ && n < ZA && t >= y_ && t < XA)
    return sc + (n - g_) * A_ + (t - y_) * va;
  if (t0(n) && t > b_ && t < tm && (n - sc) % va == 0)
    return n + (t - b_);
  {
    let e = $c.get(n);
    return e && (e = e.get(t), e) ? e : -1;
  }
}
function e0(n) {
  Yu || em();
  let t = [], e = [], r = !1;
  function i(s) {
    let a = Yu.get(s);
    a && (r = !0, s |= a), t.push(s);
  }
  for (let s of n)
    for (; ; ) {
      if (s < 128)
        t.push(s);
      else if (t0(s)) {
        let a = s - sc, c = a / A_ | 0, _ = a % A_ / va | 0, p = a % va;
        i(g_ + c), i(y_ + _), p > 0 && i(b_ + p);
      } else {
        let a = Qu.get(s);
        a ? e.push(...a) : i(s);
      }
      if (!e.length) break;
      s = e.pop();
    }
  if (r && t.length > 1) {
    let s = Va(t[0]);
    for (let a = 1; a < t.length; a++) {
      let c = Va(t[a]);
      if (c == 0 || s <= c) {
        s = c;
        continue;
      }
      let _ = a - 1;
      for (; ; ) {
        let p = t[_ + 1];
        if (t[_ + 1] = t[_], t[_] = p, !_ || (s = Va(t[--_]), s <= c)) break;
      }
      s = Va(t[a]);
    }
  }
  return t;
}
function nm(n) {
  let t = [], e = [], r = -1, i = 0;
  for (let s of n) {
    let a = Va(s), c = Xg(s);
    if (r == -1)
      a == 0 ? r = c : t.push(c);
    else if (i > 0 && i >= a)
      a == 0 ? (t.push(r, ...e), e.length = 0, r = c) : e.push(c), i = a;
    else {
      let _ = rm(r, c);
      _ >= 0 ? r = _ : i == 0 && a == 0 ? (t.push(r), r = c) : (e.push(c), i = a);
    }
  }
  return r >= 0 && t.push(r, ...e), t;
}
function r0(n) {
  return e0(n).map(Xg);
}
function im(n) {
  return nm(e0(n));
}
const $h = 45, n0 = ".", i0 = 65039, s0 = 1, m_ = (n) => Array.from(n);
function oc(n, t) {
  return n.P.has(t) || n.Q.has(t);
}
class sm extends Array {
  get is_emoji() {
    return !0;
  }
  // free tagging system
}
let Wu, o0, Ii, Ju, a0, Eo, nu, Is, Si, qh, $u;
function Df() {
  if (Wu) return;
  let n = Yg(UA);
  const t = () => nc(n), e = () => new Set(t()), r = (f, d) => d.forEach((y) => f.add(y));
  Wu = new Map(Wg(n)), o0 = e(), Ii = t(), Ju = new Set(t().map((f) => Ii[f])), Ii = new Set(Ii), a0 = e(), e();
  let i = Qg(n), s = n();
  const a = () => {
    let f = /* @__PURE__ */ new Set();
    return t().forEach((d) => r(f, i[d])), r(f, t()), f;
  };
  Eo = ic((f) => {
    let d = ic(n).map((y) => y + 96);
    if (d.length) {
      let y = f >= s;
      d[0] -= 32, d = Pa(d), y && (d = `Restricted[${d}]`);
      let b = a(), v = a(), R = !n();
      return { N: d, P: b, Q: v, M: R, R: y };
    }
  }), nu = e(), Is = /* @__PURE__ */ new Map();
  let c = t().concat(m_(nu)).sort((f, d) => f - d);
  c.forEach((f, d) => {
    let y = n(), b = c[d] = y ? c[d - y] : { V: [], M: /* @__PURE__ */ new Map() };
    b.V.push(f), nu.has(f) || Is.set(f, b);
  });
  for (let { V: f, M: d } of new Set(Is.values())) {
    let y = [];
    for (let v of f) {
      let R = Eo.filter((A) => oc(A, v)), M = y.find(({ G: A }) => R.some((B) => A.has(B)));
      M || (M = { G: /* @__PURE__ */ new Set(), V: [] }, y.push(M)), M.V.push(v), r(M.G, R);
    }
    let b = y.flatMap((v) => m_(v.G));
    for (let { G: v, V: R } of y) {
      let M = new Set(b.filter((A) => !v.has(A)));
      for (let A of R)
        d.set(A, M);
    }
  }
  Si = /* @__PURE__ */ new Set();
  let _ = /* @__PURE__ */ new Set();
  const p = (f) => Si.has(f) ? _.add(f) : Si.add(f);
  for (let f of Eo) {
    for (let d of f.P) p(d);
    for (let d of f.Q) p(d);
  }
  for (let f of Si)
    !Is.has(f) && !_.has(f) && Is.set(f, s0);
  r(Si, r0(Si)), qh = HA(n).map((f) => sm.from(f)).sort(WA), $u = /* @__PURE__ */ new Map();
  for (let f of qh) {
    let d = [$u];
    for (let y of f) {
      let b = d.map((v) => {
        let R = v.get(y);
        return R || (R = /* @__PURE__ */ new Map(), v.set(y, R)), R;
      });
      y === i0 ? d.push(...b) : d = b;
    }
    for (let y of d)
      y.V = f;
  }
}
function Kf(n) {
  return (c0(n) ? "" : `${Vf(J_([n]))} `) + $g(n);
}
function Vf(n) {
  return `"${n}"‎`;
}
function om(n) {
  if (n.length >= 4 && n[2] == $h && n[3] == $h)
    throw new Error(`invalid label extension: "${Pa(n.slice(0, 4))}"`);
}
function am(n) {
  for (let e = n.lastIndexOf(95); e > 0; )
    if (n[--e] !== 95)
      throw new Error("underscore allowed only at start");
}
function cm(n) {
  let t = n[0], e = Qh.get(t);
  if (e) throw qa(`leading ${e}`);
  let r = n.length, i = -1;
  for (let s = 1; s < r; s++) {
    t = n[s];
    let a = Qh.get(t);
    if (a) {
      if (i == s) throw qa(`${e} + ${a}`);
      i = s + 1, e = a;
    }
  }
  if (i == r) throw qa(`trailing ${e}`);
}
function J_(n, t = 1 / 0, e = $g) {
  let r = [];
  _m(n[0]) && r.push("◌"), n.length > t && (t >>= 1, n = [...n.slice(0, t), 8230, ...n.slice(-t)]);
  let i = 0, s = n.length;
  for (let a = 0; a < s; a++) {
    let c = n[a];
    c0(c) && (r.push(Pa(n.slice(i, a))), r.push(e(c)), i = a + 1);
  }
  return r.push(Pa(n.slice(i, s))), r.join("");
}
function _m(n) {
  return Df(), Ii.has(n);
}
function c0(n) {
  return Df(), a0.has(n);
}
function lm(n) {
  return pm(um(n, im, gm));
}
function um(n, t, e) {
  if (!n) return [];
  Df();
  let r = 0;
  return n.split(n0).map((i) => {
    let s = QA(i), a = {
      input: s,
      offset: r
      // codepoint, not substring!
    };
    r += s.length + 1;
    try {
      let c = a.tokens = wm(s, t, e), _ = c.length, p;
      if (!_)
        throw new Error("empty label");
      let f = a.output = c.flat();
      if (am(f), !(a.emoji = _ > 1 || c[0].is_emoji) && f.every((y) => y < 128))
        om(f), p = "ASCII";
      else {
        let y = c.flatMap((b) => b.is_emoji ? [] : b);
        if (!y.length)
          p = "Emoji";
        else {
          if (Ii.has(f[0])) throw qa("leading combining mark");
          for (let R = 1; R < _; R++) {
            let M = c[R];
            if (!M.is_emoji && Ii.has(M[0]))
              throw qa(`emoji + combining mark: "${Pa(c[R - 1])} + ${J_([M[0]])}"`);
          }
          cm(f);
          let b = m_(new Set(y)), [v] = hm(b);
          dm(v, y), fm(v, b), p = v.N;
        }
      }
      a.type = p;
    } catch (c) {
      a.error = c;
    }
    return a;
  });
}
function fm(n, t) {
  let e, r = [];
  for (let i of t) {
    let s = Is.get(i);
    if (s === s0) return;
    if (s) {
      let a = s.M.get(i);
      if (e = e ? e.filter((c) => a.has(c)) : m_(a), !e.length) return;
    } else
      r.push(i);
  }
  if (e) {
    for (let i of e)
      if (r.every((s) => oc(i, s)))
        throw new Error(`whole-script confusable: ${n.N}/${i.N}`);
  }
}
function hm(n) {
  let t = Eo;
  for (let e of n) {
    let r = t.filter((i) => oc(i, e));
    if (!r.length)
      throw Eo.some((i) => oc(i, e)) ? l0(t[0], e) : _0(e);
    if (t = r, r.length == 1) break;
  }
  return t;
}
function pm(n) {
  return n.map(({ input: t, error: e, output: r }) => {
    if (e) {
      let i = e.message;
      throw new Error(n.length == 1 ? i : `Invalid label ${Vf(J_(t, 63))}: ${i}`);
    }
    return Pa(r);
  }).join(n0);
}
function _0(n) {
  return new Error(`disallowed character: ${Kf(n)}`);
}
function l0(n, t) {
  let e = Kf(t), r = Eo.find((i) => i.P.has(t));
  return r && (e = `${r.N} ${e}`), new Error(`illegal mixture: ${n.N} + ${e}`);
}
function qa(n) {
  return new Error(`illegal placement: ${n}`);
}
function dm(n, t) {
  for (let e of t)
    if (!oc(n, e))
      throw l0(n, e);
  if (n.M) {
    let e = r0(t);
    for (let r = 1, i = e.length; r < i; r++)
      if (Ju.has(e[r])) {
        let s = r + 1;
        for (let a; s < i && Ju.has(a = e[s]); s++)
          for (let c = r; c < s; c++)
            if (e[c] == a)
              throw new Error(`duplicate non-spacing marks: ${Kf(a)}`);
        if (s - r > Wh)
          throw new Error(`excessive non-spacing marks: ${Vf(J_(e.slice(r - 1, s)))} (${s - r}/${Wh})`);
        r = s;
      }
  }
}
function wm(n, t, e) {
  let r = [], i = [];
  for (n = n.slice().reverse(); n.length; ) {
    let s = ym(n);
    if (s)
      i.length && (r.push(t(i)), i = []), r.push(e(s));
    else {
      let a = n.pop();
      if (Si.has(a))
        i.push(a);
      else {
        let c = Wu.get(a);
        if (c)
          i.push(...c);
        else if (!o0.has(a))
          throw _0(a);
      }
    }
  }
  return i.length && r.push(t(i)), r;
}
function gm(n) {
  return n.filter((t) => t != i0);
}
function ym(n, t) {
  let e = $u, r, i = n.length;
  for (; i && (e = e.get(n[--i]), !!e); ) {
    let { V: s } = e;
    s && (r = s, n.length = i);
  }
  return r;
}
const u0 = new Uint8Array(32);
u0.fill(0);
function Zh(n) {
  return T(n.length !== 0, "invalid ENS name; empty component", "comp", n), n;
}
function f0(n) {
  const t = On(bm(n)), e = [];
  if (n.length === 0)
    return e;
  let r = 0;
  for (let i = 0; i < t.length; i++)
    t[i] === 46 && (e.push(Zh(t.slice(r, i))), r = i + 1);
  return T(r < t.length, "invalid ENS name; empty component", "name", n), e.push(Zh(t.slice(r))), e;
}
function bm(n) {
  try {
    if (n.length === 0)
      throw new Error("empty label");
    return lm(n);
  } catch (t) {
    T(!1, `invalid ENS name (${t.message})`, "name", n);
  }
}
function qu(n) {
  T(typeof n == "string", "invalid ENS name; not a string", "name", n), T(n.length, "invalid ENS name (empty label)", "name", n);
  let t = u0;
  const e = f0(n);
  for (; e.length; )
    t = ee(Xt([t, ee(e.pop())]));
  return ut(t);
}
function Am(n, t) {
  const e = t;
  return T(e <= 255, "DNS encoded label cannot exceed 255", "length", e), ut(Xt(f0(n).map((r) => {
    T(r.length <= e, `label ${JSON.stringify(n)} exceeds ${e} bytes`, "name", n);
    const i = new Uint8Array(r.length + 1);
    return i.set(r, 1), i[0] = i.length - 1, i;
  }))) + "00";
}
function iu(n, t) {
  return {
    address: zt(n),
    storageKeys: t.map((e, r) => (T(jt(e, 32), "invalid slot", `storageKeys[${r}]`, e), e.toLowerCase()))
  };
}
function ms(n) {
  if (Array.isArray(n))
    return n.map((e, r) => Array.isArray(e) ? (T(e.length === 2, "invalid slot set", `value[${r}]`, e), iu(e[0], e[1])) : (T(e != null && typeof e == "object", "invalid address-slot set", "value", n), iu(e.address, e.storageKeys)));
  T(n != null && typeof n == "object", "invalid access list", "value", n);
  const t = Object.keys(n).map((e) => {
    const r = n[e].reduce((i, s) => (i[s] = !0, i), {});
    return iu(e, Object.keys(r).sort());
  });
  return t.sort((e, r) => e.address.localeCompare(r.address)), t;
}
function mm(n) {
  let t;
  return typeof n == "string" ? t = rc.computePublicKey(n, !1) : t = n.publicKey, zt(ee("0x" + t.substring(4)).substring(26));
}
function Sm(n, t) {
  return mm(rc.recoverPublicKey(n, t));
}
const ae = BigInt(0), Em = BigInt(2), Rm = BigInt(27), Pm = BigInt(28), vm = BigInt(35), Mm = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), su = 4096 * 32;
function Xh(n, t) {
  let e = n.toString(16);
  for (; e.length < 2; )
    e = "0" + e;
  return e += Ia(t).substring(4), "0x" + e;
}
function $_(n) {
  return n === "0x" ? null : zt(n);
}
function jf(n, t) {
  try {
    return ms(n);
  } catch (e) {
    T(!1, e.message, t, n);
  }
}
function xc(n, t) {
  return n === "0x" ? 0 : Rt(n, t);
}
function Zt(n, t) {
  if (n === "0x")
    return ae;
  const e = ht(n, t);
  return T(e <= Mm, "value exceeds uint size", t, e), e;
}
function Ht(n, t) {
  const e = ht(n, "value"), r = me(e);
  return T(r.length <= 32, "value too large", `tx.${t}`, e), r;
}
function Hf(n) {
  return ms(n).map((t) => [t.address, t.storageKeys]);
}
function xm(n, t) {
  T(Array.isArray(n), `invalid ${t}`, "value", n);
  for (let e = 0; e < n.length; e++)
    T(jt(n[e], 32), "invalid ${ param } hash", `value[${e}]`, n[e]);
  return n;
}
function Bm(n) {
  const t = H_(n);
  T(Array.isArray(t) && (t.length === 9 || t.length === 6), "invalid field count for legacy transaction", "data", n);
  const e = {
    type: 0,
    nonce: xc(t[0], "nonce"),
    gasPrice: Zt(t[1], "gasPrice"),
    gasLimit: Zt(t[2], "gasLimit"),
    to: $_(t[3]),
    value: Zt(t[4], "value"),
    data: ut(t[5]),
    chainId: ae
  };
  if (t.length === 6)
    return e;
  const r = Zt(t[6], "v"), i = Zt(t[7], "r"), s = Zt(t[8], "s");
  if (i === ae && s === ae)
    e.chainId = r;
  else {
    let a = (r - vm) / Em;
    a < ae && (a = ae), e.chainId = a, T(a !== ae || r === Rm || r === Pm, "non-canonical legacy v", "v", t[6]), e.signature = ur.from({
      r: fs(t[7], 32),
      s: fs(t[8], 32),
      v: r
    });
  }
  return e;
}
function Cm(n, t) {
  const e = [
    Ht(n.nonce, "nonce"),
    Ht(n.gasPrice || 0, "gasPrice"),
    Ht(n.gasLimit, "gasLimit"),
    n.to || "0x",
    Ht(n.value, "value"),
    n.data
  ];
  let r = ae;
  if (n.chainId != ae)
    r = ht(n.chainId, "tx.chainId"), T(!t || t.networkV == null || t.legacyChainId === r, "tx.chainId/sig.v mismatch", "sig", t);
  else if (n.signature) {
    const s = n.signature.legacyChainId;
    s != null && (r = s);
  }
  if (!t)
    return r !== ae && (e.push(me(r)), e.push("0x"), e.push("0x")), hs(e);
  let i = BigInt(27 + t.yParity);
  return r !== ae ? i = ur.getChainIdV(r, t.v) : BigInt(t.v) !== i && T(!1, "tx.chainId/sig.v mismatch", "sig", t), e.push(me(i)), e.push(me(t.r)), e.push(me(t.s)), hs(e);
}
function Yf(n, t) {
  let e;
  try {
    if (e = xc(t[0], "yParity"), e !== 0 && e !== 1)
      throw new Error("bad yParity");
  } catch {
    T(!1, "invalid yParity", "yParity", t[0]);
  }
  const r = fs(t[1], 32), i = fs(t[2], 32), s = ur.from({ r, s: i, yParity: e });
  n.signature = s;
}
function Im(n) {
  const t = H_(Tt(n).slice(1));
  T(Array.isArray(t) && (t.length === 9 || t.length === 12), "invalid field count for transaction type: 2", "data", ut(n));
  const e = {
    type: 2,
    chainId: Zt(t[0], "chainId"),
    nonce: xc(t[1], "nonce"),
    maxPriorityFeePerGas: Zt(t[2], "maxPriorityFeePerGas"),
    maxFeePerGas: Zt(t[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: Zt(t[4], "gasLimit"),
    to: $_(t[5]),
    value: Zt(t[6], "value"),
    data: ut(t[7]),
    accessList: jf(t[8], "accessList")
  };
  return t.length === 9 || Yf(e, t.slice(9)), e;
}
function Nm(n, t) {
  const e = [
    Ht(n.chainId, "chainId"),
    Ht(n.nonce, "nonce"),
    Ht(n.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    Ht(n.maxFeePerGas || 0, "maxFeePerGas"),
    Ht(n.gasLimit, "gasLimit"),
    n.to || "0x",
    Ht(n.value, "value"),
    n.data,
    Hf(n.accessList || [])
  ];
  return t && (e.push(Ht(t.yParity, "yParity")), e.push(me(t.r)), e.push(me(t.s))), Xt(["0x02", hs(e)]);
}
function Om(n) {
  const t = H_(Tt(n).slice(1));
  T(Array.isArray(t) && (t.length === 8 || t.length === 11), "invalid field count for transaction type: 1", "data", ut(n));
  const e = {
    type: 1,
    chainId: Zt(t[0], "chainId"),
    nonce: xc(t[1], "nonce"),
    gasPrice: Zt(t[2], "gasPrice"),
    gasLimit: Zt(t[3], "gasLimit"),
    to: $_(t[4]),
    value: Zt(t[5], "value"),
    data: ut(t[6]),
    accessList: jf(t[7], "accessList")
  };
  return t.length === 8 || Yf(e, t.slice(8)), e;
}
function Tm(n, t) {
  const e = [
    Ht(n.chainId, "chainId"),
    Ht(n.nonce, "nonce"),
    Ht(n.gasPrice || 0, "gasPrice"),
    Ht(n.gasLimit, "gasLimit"),
    n.to || "0x",
    Ht(n.value, "value"),
    n.data,
    Hf(n.accessList || [])
  ];
  return t && (e.push(Ht(t.yParity, "recoveryParam")), e.push(me(t.r)), e.push(me(t.s))), Xt(["0x01", hs(e)]);
}
function zm(n) {
  let t = H_(Tt(n).slice(1)), e = "3", r = null;
  if (t.length === 4 && Array.isArray(t[0])) {
    e = "3 (network format)";
    const s = t[1], a = t[2], c = t[3];
    T(Array.isArray(s), "invalid network format: blobs not an array", "fields[1]", s), T(Array.isArray(a), "invalid network format: commitments not an array", "fields[2]", a), T(Array.isArray(c), "invalid network format: proofs not an array", "fields[3]", c), T(s.length === a.length, "invalid network format: blobs/commitments length mismatch", "fields", t), T(s.length === c.length, "invalid network format: blobs/proofs length mismatch", "fields", t), r = [];
    for (let _ = 0; _ < t[1].length; _++)
      r.push({
        data: s[_],
        commitment: a[_],
        proof: c[_]
      });
    t = t[0];
  }
  T(Array.isArray(t) && (t.length === 11 || t.length === 14), `invalid field count for transaction type: ${e}`, "data", ut(n));
  const i = {
    type: 3,
    chainId: Zt(t[0], "chainId"),
    nonce: xc(t[1], "nonce"),
    maxPriorityFeePerGas: Zt(t[2], "maxPriorityFeePerGas"),
    maxFeePerGas: Zt(t[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: Zt(t[4], "gasLimit"),
    to: $_(t[5]),
    value: Zt(t[6], "value"),
    data: ut(t[7]),
    accessList: jf(t[8], "accessList"),
    maxFeePerBlobGas: Zt(t[9], "maxFeePerBlobGas"),
    blobVersionedHashes: t[10]
  };
  r && (i.blobs = r), T(i.to != null, `invalid address for transaction type: ${e}`, "data", n), T(Array.isArray(i.blobVersionedHashes), "invalid blobVersionedHashes: must be an array", "data", n);
  for (let s = 0; s < i.blobVersionedHashes.length; s++)
    T(jt(i.blobVersionedHashes[s], 32), `invalid blobVersionedHash at index ${s}: must be length 32`, "data", n);
  return t.length === 11 || Yf(i, t.slice(11)), i;
}
function km(n, t, e) {
  const r = [
    Ht(n.chainId, "chainId"),
    Ht(n.nonce, "nonce"),
    Ht(n.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    Ht(n.maxFeePerGas || 0, "maxFeePerGas"),
    Ht(n.gasLimit, "gasLimit"),
    n.to || ec,
    Ht(n.value, "value"),
    n.data,
    Hf(n.accessList || []),
    Ht(n.maxFeePerBlobGas || 0, "maxFeePerBlobGas"),
    xm(n.blobVersionedHashes || [], "blobVersionedHashes")
  ];
  return t && (r.push(Ht(t.yParity, "yParity")), r.push(me(t.r)), r.push(me(t.s)), e) ? Xt([
    "0x03",
    hs([
      r,
      e.map((i) => i.data),
      e.map((i) => i.commitment),
      e.map((i) => i.proof)
    ])
  ]) : Xt(["0x03", hs(r)]);
}
var Er, jo, Ho, Yo, Qo, Wo, Jo, $o, qo, Zo, Xo, ta, Zi, Zn, Sn, Xn, ea, qc;
const dn = class dn {
  /**
   *  Creates a new Transaction with default values.
   */
  constructor() {
    j(this, ea);
    j(this, Er);
    j(this, jo);
    j(this, Ho);
    j(this, Yo);
    j(this, Qo);
    j(this, Wo);
    j(this, Jo);
    j(this, $o);
    j(this, qo);
    j(this, Zo);
    j(this, Xo);
    j(this, ta);
    j(this, Zi);
    j(this, Zn);
    j(this, Sn);
    j(this, Xn);
    P(this, Er, null), P(this, jo, null), P(this, Yo, 0), P(this, Qo, ae), P(this, Wo, null), P(this, Jo, null), P(this, $o, null), P(this, Ho, "0x"), P(this, qo, ae), P(this, Zo, ae), P(this, Xo, null), P(this, ta, null), P(this, Zi, null), P(this, Zn, null), P(this, Xn, null), P(this, Sn, null);
  }
  /**
   *  The transaction type.
   *
   *  If null, the type will be automatically inferred based on
   *  explicit properties.
   */
  get type() {
    return w(this, Er);
  }
  set type(t) {
    switch (t) {
      case null:
        P(this, Er, null);
        break;
      case 0:
      case "legacy":
        P(this, Er, 0);
        break;
      case 1:
      case "berlin":
      case "eip-2930":
        P(this, Er, 1);
        break;
      case 2:
      case "london":
      case "eip-1559":
        P(this, Er, 2);
        break;
      case 3:
      case "cancun":
      case "eip-4844":
        P(this, Er, 3);
        break;
      default:
        T(!1, "unsupported transaction type", "type", t);
    }
  }
  /**
   *  The name of the transaction type.
   */
  get typeName() {
    switch (this.type) {
      case 0:
        return "legacy";
      case 1:
        return "eip-2930";
      case 2:
        return "eip-1559";
      case 3:
        return "eip-4844";
    }
    return null;
  }
  /**
   *  The ``to`` address for the transaction or ``null`` if the
   *  transaction is an ``init`` transaction.
   */
  get to() {
    const t = w(this, jo);
    return t == null && this.type === 3 ? ec : t;
  }
  set to(t) {
    P(this, jo, t == null ? null : zt(t));
  }
  /**
   *  The transaction nonce.
   */
  get nonce() {
    return w(this, Yo);
  }
  set nonce(t) {
    P(this, Yo, Rt(t, "value"));
  }
  /**
   *  The gas limit.
   */
  get gasLimit() {
    return w(this, Qo);
  }
  set gasLimit(t) {
    P(this, Qo, ht(t));
  }
  /**
   *  The gas price.
   *
   *  On legacy networks this defines the fee that will be paid. On
   *  EIP-1559 networks, this should be ``null``.
   */
  get gasPrice() {
    const t = w(this, Wo);
    return t == null && (this.type === 0 || this.type === 1) ? ae : t;
  }
  set gasPrice(t) {
    P(this, Wo, t == null ? null : ht(t, "gasPrice"));
  }
  /**
   *  The maximum priority fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxPriorityFeePerGas() {
    const t = w(this, Jo);
    return t ?? (this.type === 2 || this.type === 3 ? ae : null);
  }
  set maxPriorityFeePerGas(t) {
    P(this, Jo, t == null ? null : ht(t, "maxPriorityFeePerGas"));
  }
  /**
   *  The maximum total fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxFeePerGas() {
    const t = w(this, $o);
    return t ?? (this.type === 2 || this.type === 3 ? ae : null);
  }
  set maxFeePerGas(t) {
    P(this, $o, t == null ? null : ht(t, "maxFeePerGas"));
  }
  /**
   *  The transaction data. For ``init`` transactions this is the
   *  deployment code.
   */
  get data() {
    return w(this, Ho);
  }
  set data(t) {
    P(this, Ho, ut(t));
  }
  /**
   *  The amount of ether (in wei) to send in this transactions.
   */
  get value() {
    return w(this, qo);
  }
  set value(t) {
    P(this, qo, ht(t, "value"));
  }
  /**
   *  The chain ID this transaction is valid on.
   */
  get chainId() {
    return w(this, Zo);
  }
  set chainId(t) {
    P(this, Zo, ht(t));
  }
  /**
   *  If signed, the signature for this transaction.
   */
  get signature() {
    return w(this, Xo) || null;
  }
  set signature(t) {
    P(this, Xo, t == null ? null : ur.from(t));
  }
  /**
   *  The access list.
   *
   *  An access list permits discounted (but pre-paid) access to
   *  bytecode and state variable access within contract execution.
   */
  get accessList() {
    const t = w(this, ta) || null;
    return t ?? (this.type === 1 || this.type === 2 || this.type === 3 ? [] : null);
  }
  set accessList(t) {
    P(this, ta, t == null ? null : ms(t));
  }
  /**
   *  The max fee per blob gas for Cancun transactions.
   */
  get maxFeePerBlobGas() {
    const t = w(this, Zi);
    return t == null && this.type === 3 ? ae : t;
  }
  set maxFeePerBlobGas(t) {
    P(this, Zi, t == null ? null : ht(t, "maxFeePerBlobGas"));
  }
  /**
   *  The BLOb versioned hashes for Cancun transactions.
   */
  get blobVersionedHashes() {
    let t = w(this, Zn);
    return t == null && this.type === 3 ? [] : t;
  }
  set blobVersionedHashes(t) {
    if (t != null) {
      T(Array.isArray(t), "blobVersionedHashes must be an Array", "value", t), t = t.slice();
      for (let e = 0; e < t.length; e++)
        T(jt(t[e], 32), "invalid blobVersionedHash", `value[${e}]`, t[e]);
    }
    P(this, Zn, t);
  }
  /**
   *  The BLObs for the Transaction, if any.
   *
   *  If ``blobs`` is non-``null``, then the [[seriailized]]
   *  will return the network formatted sidecar, otherwise it
   *  will return the standard [[link-eip-2718]] payload. The
   *  [[unsignedSerialized]] is unaffected regardless.
   *
   *  When setting ``blobs``, either fully valid [[Blob]] objects
   *  may be specified (i.e. correctly padded, with correct
   *  committments and proofs) or a raw [[BytesLike]] may
   *  be provided.
   *
   *  If raw [[BytesLike]] are provided, the [[kzg]] property **must**
   *  be already set. The blob will be correctly padded and the
   *  [[KzgLibrary]] will be used to compute the committment and
   *  proof for the blob.
   *
   *  A BLOb is a sequence of field elements, each of which must
   *  be within the BLS field modulo, so some additional processing
   *  may be required to encode arbitrary data to ensure each 32 byte
   *  field is within the valid range.
   *
   *  Setting this automatically populates [[blobVersionedHashes]],
   *  overwriting any existing values. Setting this to ``null``
   *  does **not** remove the [[blobVersionedHashes]], leaving them
   *  present.
   */
  get blobs() {
    return w(this, Xn) == null ? null : w(this, Xn).map((t) => Object.assign({}, t));
  }
  set blobs(t) {
    if (t == null) {
      P(this, Xn, null);
      return;
    }
    const e = [], r = [];
    for (let i = 0; i < t.length; i++) {
      const s = t[i];
      if (If(s)) {
        et(w(this, Sn), "adding a raw blob requires a KZG library", "UNSUPPORTED_OPERATION", {
          operation: "set blobs()"
        });
        let a = Tt(s);
        if (T(a.length <= su, "blob is too large", `blobs[${i}]`, s), a.length !== su) {
          const p = new Uint8Array(su);
          p.set(a), a = p;
        }
        const c = w(this, Sn).blobToKzgCommitment(a), _ = ut(w(this, Sn).computeBlobKzgProof(a, c));
        e.push({
          data: ut(a),
          commitment: ut(c),
          proof: _
        }), r.push(Xh(1, c));
      } else {
        const a = ut(s.commitment);
        e.push({
          data: ut(s.data),
          commitment: a,
          proof: ut(s.proof)
        }), r.push(Xh(1, a));
      }
    }
    P(this, Xn, e), P(this, Zn, r);
  }
  get kzg() {
    return w(this, Sn);
  }
  set kzg(t) {
    P(this, Sn, t);
  }
  /**
   *  The transaction hash, if signed. Otherwise, ``null``.
   */
  get hash() {
    return this.signature == null ? null : ee(ct(this, ea, qc).call(this, !0, !1));
  }
  /**
   *  The pre-image hash of this transaction.
   *
   *  This is the digest that a [[Signer]] must sign to authorize
   *  this transaction.
   */
  get unsignedHash() {
    return ee(this.unsignedSerialized);
  }
  /**
   *  The sending address, if signed. Otherwise, ``null``.
   */
  get from() {
    return this.signature == null ? null : Sm(this.unsignedHash, this.signature);
  }
  /**
   *  The public key of the sender, if signed. Otherwise, ``null``.
   */
  get fromPublicKey() {
    return this.signature == null ? null : rc.recoverPublicKey(this.unsignedHash, this.signature);
  }
  /**
   *  Returns true if signed.
   *
   *  This provides a Type Guard that properties requiring a signed
   *  transaction are non-null.
   */
  isSigned() {
    return this.signature != null;
  }
  /**
   *  The serialized transaction.
   *
   *  This throws if the transaction is unsigned. For the pre-image,
   *  use [[unsignedSerialized]].
   */
  get serialized() {
    return ct(this, ea, qc).call(this, !0, !0);
  }
  /**
   *  The transaction pre-image.
   *
   *  The hash of this is the digest which needs to be signed to
   *  authorize this transaction.
   */
  get unsignedSerialized() {
    return ct(this, ea, qc).call(this, !1, !1);
  }
  /**
   *  Return the most "likely" type; currently the highest
   *  supported transaction type.
   */
  inferType() {
    const t = this.inferTypes();
    return t.indexOf(2) >= 0 ? 2 : t.pop();
  }
  /**
   *  Validates the explicit properties and returns a list of compatible
   *  transaction types.
   */
  inferTypes() {
    const t = this.gasPrice != null, e = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null, r = this.accessList != null, i = w(this, Zi) != null || w(this, Zn);
    this.maxFeePerGas != null && this.maxPriorityFeePerGas != null && et(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", { value: this }), et(!e || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", { value: this }), et(this.type !== 0 || !r, "legacy transaction cannot have accessList", "BAD_DATA", { value: this });
    const s = [];
    return this.type != null ? s.push(this.type) : e ? s.push(2) : t ? (s.push(1), r || s.push(0)) : r ? (s.push(1), s.push(2)) : (i && this.to || (s.push(0), s.push(1), s.push(2)), s.push(3)), s.sort(), s;
  }
  /**
   *  Returns true if this transaction is a legacy transaction (i.e.
   *  ``type === 0``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if this transaction is berlin hardform transaction (i.e.
   *  ``type === 1``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if this transaction is london hardform transaction (i.e.
   *  ``type === 2``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if this transaction is an [[link-eip-4844]] BLOB
   *  transaction.
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Create a copy of this transaciton.
   */
  clone() {
    return dn.from(this);
  }
  /**
   *  Return a JSON-friendly object.
   */
  toJSON() {
    const t = (e) => e == null ? null : e.toString();
    return {
      type: this.type,
      to: this.to,
      //            from: this.from,
      data: this.data,
      nonce: this.nonce,
      gasLimit: t(this.gasLimit),
      gasPrice: t(this.gasPrice),
      maxPriorityFeePerGas: t(this.maxPriorityFeePerGas),
      maxFeePerGas: t(this.maxFeePerGas),
      value: t(this.value),
      chainId: t(this.chainId),
      sig: this.signature ? this.signature.toJSON() : null,
      accessList: this.accessList
    };
  }
  /**
   *  Create a **Transaction** from a serialized transaction or a
   *  Transaction-like object.
   */
  static from(t) {
    if (t == null)
      return new dn();
    if (typeof t == "string") {
      const r = Tt(t);
      if (r[0] >= 127)
        return dn.from(Bm(r));
      switch (r[0]) {
        case 1:
          return dn.from(Om(r));
        case 2:
          return dn.from(Im(r));
        case 3:
          return dn.from(zm(r));
      }
      et(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: "from" });
    }
    const e = new dn();
    return t.type != null && (e.type = t.type), t.to != null && (e.to = t.to), t.nonce != null && (e.nonce = t.nonce), t.gasLimit != null && (e.gasLimit = t.gasLimit), t.gasPrice != null && (e.gasPrice = t.gasPrice), t.maxPriorityFeePerGas != null && (e.maxPriorityFeePerGas = t.maxPriorityFeePerGas), t.maxFeePerGas != null && (e.maxFeePerGas = t.maxFeePerGas), t.maxFeePerBlobGas != null && (e.maxFeePerBlobGas = t.maxFeePerBlobGas), t.data != null && (e.data = t.data), t.value != null && (e.value = t.value), t.chainId != null && (e.chainId = t.chainId), t.signature != null && (e.signature = ur.from(t.signature)), t.accessList != null && (e.accessList = t.accessList), t.blobVersionedHashes != null && (e.blobVersionedHashes = t.blobVersionedHashes), t.kzg != null && (e.kzg = t.kzg), t.blobs != null && (e.blobs = t.blobs), t.hash != null && (T(e.isSigned(), "unsigned transaction cannot define '.hash'", "tx", t), T(e.hash === t.hash, "hash mismatch", "tx", t)), t.from != null && (T(e.isSigned(), "unsigned transaction cannot define '.from'", "tx", t), T(e.from.toLowerCase() === (t.from || "").toLowerCase(), "from mismatch", "tx", t)), e;
  }
};
Er = new WeakMap(), jo = new WeakMap(), Ho = new WeakMap(), Yo = new WeakMap(), Qo = new WeakMap(), Wo = new WeakMap(), Jo = new WeakMap(), $o = new WeakMap(), qo = new WeakMap(), Zo = new WeakMap(), Xo = new WeakMap(), ta = new WeakMap(), Zi = new WeakMap(), Zn = new WeakMap(), Sn = new WeakMap(), Xn = new WeakMap(), ea = new WeakSet(), qc = function(t, e) {
  et(!t || this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
  const r = t ? this.signature : null;
  switch (this.inferType()) {
    case 0:
      return Cm(this, r);
    case 1:
      return Tm(this, r);
    case 2:
      return Nm(this, r);
    case 3:
      return km(this, r, e ? this.blobs : null);
  }
  et(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
};
let S_ = dn;
const h0 = new Uint8Array(32);
h0.fill(0);
const Um = BigInt(-1), p0 = BigInt(0), d0 = BigInt(1), Fm = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function Gm(n) {
  const t = Tt(n), e = t.length % 32;
  return e ? Xt([t, h0.slice(e)]) : ut(t);
}
const Lm = di(d0, 32), Dm = di(p0, 32), tp = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
}, ou = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function ep(n) {
  return function(t) {
    return T(typeof t == "string", `invalid domain value for ${JSON.stringify(n)}`, `domain.${n}`, t), t;
  };
}
const Km = {
  name: ep("name"),
  version: ep("version"),
  chainId: function(n) {
    const t = ht(n, "domain.chainId");
    return T(t >= 0, "invalid chain ID", "domain.chainId", n), Number.isSafeInteger(t) ? Number(t) : Us(t);
  },
  verifyingContract: function(n) {
    try {
      return zt(n).toLowerCase();
    } catch {
    }
    T(!1, 'invalid domain value "verifyingContract"', "domain.verifyingContract", n);
  },
  salt: function(n) {
    const t = Tt(n, "domain.salt");
    return T(t.length === 32, 'invalid domain value "salt"', "domain.salt", n), ut(t);
  }
};
function au(n) {
  {
    const t = n.match(/^(u?)int(\d+)$/);
    if (t) {
      const e = t[1] === "", r = parseInt(t[2]);
      T(r % 8 === 0 && r !== 0 && r <= 256 && t[2] === String(r), "invalid numeric width", "type", n);
      const i = Da(Fm, e ? r - 1 : r), s = e ? (i + d0) * Um : p0;
      return function(a) {
        const c = ht(a, "value");
        return T(c >= s && c <= i, `value out-of-bounds for ${n}`, "value", c), di(e ? eg(c, 256) : c, 32);
      };
    }
  }
  {
    const t = n.match(/^bytes(\d+)$/);
    if (t) {
      const e = parseInt(t[1]);
      return T(e !== 0 && e <= 32 && t[1] === String(e), "invalid bytes width", "type", n), function(r) {
        const i = Tt(r);
        return T(i.length === e, `invalid length for ${n}`, "value", r), Gm(r);
      };
    }
  }
  switch (n) {
    case "address":
      return function(t) {
        return fs(zt(t), 32);
      };
    case "bool":
      return function(t) {
        return t ? Lm : Dm;
      };
    case "bytes":
      return function(t) {
        return ee(t);
      };
    case "string":
      return function(t) {
        return ps(t);
      };
  }
  return null;
}
function rp(n, t) {
  return `${n}(${t.map(({ name: e, type: r }) => r + " " + e).join(",")})`;
}
function jc(n) {
  const t = n.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
  return t ? {
    base: t[1],
    index: t[2] + t[4],
    array: {
      base: t[1],
      prefix: t[1] + t[2],
      count: t[5] ? parseInt(t[5]) : -1
    }
  } : { base: n };
}
var yc, En, ra, z_, w0;
const Ke = class Ke {
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   *
   *  This performs all necessary checking that types are valid and
   *  do not violate the [[link-eip-712]] structural constraints as
   *  well as computes the [[primaryType]].
   */
  constructor(t) {
    j(this, z_);
    /**
     *  The primary type for the structured [[types]].
     *
     *  This is derived automatically from the [[types]], since no
     *  recursion is possible, once the DAG for the types is consturcted
     *  internally, the primary type must be the only remaining type with
     *  no parent nodes.
     */
    U(this, "primaryType");
    j(this, yc);
    j(this, En);
    j(this, ra);
    P(this, En, /* @__PURE__ */ new Map()), P(this, ra, /* @__PURE__ */ new Map());
    const e = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), s = {};
    Object.keys(t).forEach((_) => {
      s[_] = t[_].map(({ name: p, type: f }) => {
        let { base: d, index: y } = jc(f);
        return d === "int" && !t.int && (d = "int256"), d === "uint" && !t.uint && (d = "uint256"), { name: p, type: d + (y || "") };
      }), e.set(_, /* @__PURE__ */ new Set()), r.set(_, []), i.set(_, /* @__PURE__ */ new Set());
    }), P(this, yc, JSON.stringify(s));
    for (const _ in s) {
      const p = /* @__PURE__ */ new Set();
      for (const f of s[_]) {
        T(!p.has(f.name), `duplicate variable name ${JSON.stringify(f.name)} in ${JSON.stringify(_)}`, "types", t), p.add(f.name);
        const d = jc(f.type).base;
        T(d !== _, `circular type reference to ${JSON.stringify(d)}`, "types", t), !au(d) && (T(r.has(d), `unknown type ${JSON.stringify(d)}`, "types", t), r.get(d).push(_), e.get(_).add(d));
      }
    }
    const a = Array.from(r.keys()).filter((_) => r.get(_).length === 0);
    T(a.length !== 0, "missing primary type", "types", t), T(a.length === 1, `ambiguous primary types or unused types: ${a.map((_) => JSON.stringify(_)).join(", ")}`, "types", t), gt(this, { primaryType: a[0] });
    function c(_, p) {
      T(!p.has(_), `circular type reference to ${JSON.stringify(_)}`, "types", t), p.add(_);
      for (const f of e.get(_))
        if (r.has(f)) {
          c(f, p);
          for (const d of p)
            i.get(d).add(f);
        }
      p.delete(_);
    }
    c(this.primaryType, /* @__PURE__ */ new Set());
    for (const [_, p] of i) {
      const f = Array.from(p);
      f.sort(), w(this, En).set(_, rp(_, s[_]) + f.map((d) => rp(d, s[d])).join(""));
    }
  }
  /**
   *  The types.
   */
  get types() {
    return JSON.parse(w(this, yc));
  }
  /**
   *  Returnthe encoder for the specific %%type%%.
   */
  getEncoder(t) {
    let e = w(this, ra).get(t);
    return e || (e = ct(this, z_, w0).call(this, t), w(this, ra).set(t, e)), e;
  }
  /**
   *  Return the full type for %%name%%.
   */
  encodeType(t) {
    const e = w(this, En).get(t);
    return T(e, `unknown type: ${JSON.stringify(t)}`, "name", t), e;
  }
  /**
   *  Return the encoded %%value%% for the %%type%%.
   */
  encodeData(t, e) {
    return this.getEncoder(t)(e);
  }
  /**
   *  Returns the hash of %%value%% for the type of %%name%%.
   */
  hashStruct(t, e) {
    return ee(this.encodeData(t, e));
  }
  /**
   *  Return the fulled encoded %%value%% for the [[types]].
   */
  encode(t) {
    return this.encodeData(this.primaryType, t);
  }
  /**
   *  Return the hash of the fully encoded %%value%% for the [[types]].
   */
  hash(t) {
    return this.hashStruct(this.primaryType, t);
  }
  /**
   *  @_ignore:
   */
  _visit(t, e, r) {
    if (au(t))
      return r(t, e);
    const i = jc(t).array;
    if (i)
      return T(i.count === -1 || i.count === e.length, `array length mismatch; expected length ${i.count}`, "value", e), e.map((a) => this._visit(i.prefix, a, r));
    const s = this.types[t];
    if (s)
      return s.reduce((a, { name: c, type: _ }) => (a[c] = this._visit(_, e[c], r), a), {});
    T(!1, `unknown type: ${t}`, "type", t);
  }
  /**
   *  Call %%calback%% for each value in %%value%%, passing the type and
   *  component within %%value%%.
   *
   *  This is useful for replacing addresses or other transformation that
   *  may be desired on each component, based on its type.
   */
  visit(t, e) {
    return this._visit(this.primaryType, t, e);
  }
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   */
  static from(t) {
    return new Ke(t);
  }
  /**
   *  Return the primary type for %%types%%.
   */
  static getPrimaryType(t) {
    return Ke.from(t).primaryType;
  }
  /**
   *  Return the hashed struct for %%value%% using %%types%% and %%name%%.
   */
  static hashStruct(t, e, r) {
    return Ke.from(e).hashStruct(t, r);
  }
  /**
   *  Return the domain hash for %%domain%%.
   */
  static hashDomain(t) {
    const e = [];
    for (const r in t) {
      if (t[r] == null)
        continue;
      const i = tp[r];
      T(i, `invalid typed-data domain key: ${JSON.stringify(r)}`, "domain", t), e.push({ name: r, type: i });
    }
    return e.sort((r, i) => ou.indexOf(r.name) - ou.indexOf(i.name)), Ke.hashStruct("EIP712Domain", { EIP712Domain: e }, t);
  }
  /**
   *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static encode(t, e, r) {
    return Xt([
      "0x1901",
      Ke.hashDomain(t),
      Ke.from(e).hash(r)
    ]);
  }
  /**
   *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static hash(t, e, r) {
    return ee(Ke.encode(t, e, r));
  }
  // Replaces all address types with ENS names with their looked up address
  /**
   * Resolves to the value from resolving all addresses in %%value%% for
   * %%types%% and the %%domain%%.
   */
  static async resolveNames(t, e, r, i) {
    t = Object.assign({}, t);
    for (const c in t)
      t[c] == null && delete t[c];
    const s = {};
    t.verifyingContract && !jt(t.verifyingContract, 20) && (s[t.verifyingContract] = "0x");
    const a = Ke.from(e);
    a.visit(r, (c, _) => (c === "address" && !jt(_, 20) && (s[_] = "0x"), _));
    for (const c in s)
      s[c] = await i(c);
    return t.verifyingContract && s[t.verifyingContract] && (t.verifyingContract = s[t.verifyingContract]), r = a.visit(r, (c, _) => c === "address" && s[_] ? s[_] : _), { domain: t, value: r };
  }
  /**
   *  Returns the JSON-encoded payload expected by nodes which implement
   *  the JSON-RPC [[link-eip-712]] method.
   */
  static getPayload(t, e, r) {
    Ke.hashDomain(t);
    const i = {}, s = [];
    ou.forEach((_) => {
      const p = t[_];
      p != null && (i[_] = Km[_](p), s.push({ name: _, type: tp[_] }));
    });
    const a = Ke.from(e);
    e = a.types;
    const c = Object.assign({}, e);
    return T(c.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", e), c.EIP712Domain = s, a.encode(r), {
      types: c,
      domain: i,
      primaryType: a.primaryType,
      message: a.visit(r, (_, p) => {
        if (_.match(/^bytes(\d*)/))
          return ut(Tt(p));
        if (_.match(/^u?int/))
          return ht(p).toString();
        switch (_) {
          case "address":
            return p.toLowerCase();
          case "bool":
            return !!p;
          case "string":
            return T(typeof p == "string", "invalid string", "value", p), p;
        }
        T(!1, "unsupported type", "type", _);
      })
    };
  }
};
yc = new WeakMap(), En = new WeakMap(), ra = new WeakMap(), z_ = new WeakSet(), w0 = function(t) {
  {
    const i = au(t);
    if (i)
      return i;
  }
  const e = jc(t).array;
  if (e) {
    const i = e.prefix, s = this.getEncoder(i);
    return (a) => {
      T(e.count === -1 || e.count === a.length, `array length mismatch; expected length ${e.count}`, "value", a);
      let c = a.map(s);
      return w(this, En).has(i) && (c = c.map(ee)), ee(Xt(c));
    };
  }
  const r = this.types[t];
  if (r) {
    const i = ps(w(this, En).get(t));
    return (s) => {
      const a = r.map(({ name: c, type: _ }) => {
        const p = this.getEncoder(_)(s[c]);
        return w(this, En).has(_) ? ee(p) : p;
      });
      return a.unshift(i), Xt(a);
    };
  }
  T(!1, `unknown type: ${t}`, "type", t);
};
let E_ = Ke;
function Re(n) {
  const t = /* @__PURE__ */ new Set();
  return n.forEach((e) => t.add(e)), Object.freeze(t);
}
const Vm = "external public payable override", jm = Re(Vm.split(" ")), g0 = "constant external internal payable private public pure view override", Hm = Re(g0.split(" ")), y0 = "constructor error event fallback function receive struct", b0 = Re(y0.split(" ")), A0 = "calldata memory storage payable indexed", Ym = Re(A0.split(" ")), Qm = "tuple returns", Wm = [y0, A0, Qm, g0].join(" "), Jm = Re(Wm.split(" ")), $m = {
  "(": "OPEN_PAREN",
  ")": "CLOSE_PAREN",
  "[": "OPEN_BRACKET",
  "]": "CLOSE_BRACKET",
  ",": "COMMA",
  "@": "AT"
}, qm = new RegExp("^(\\s*)"), Zm = new RegExp("^([0-9]+)"), Xm = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)"), m0 = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$"), S0 = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
var le, cr, bc, Zu;
const k_ = class k_ {
  constructor(t) {
    j(this, bc);
    j(this, le);
    j(this, cr);
    P(this, le, 0), P(this, cr, t.slice());
  }
  get offset() {
    return w(this, le);
  }
  get length() {
    return w(this, cr).length - w(this, le);
  }
  clone() {
    return new k_(w(this, cr));
  }
  reset() {
    P(this, le, 0);
  }
  // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens
  popKeyword(t) {
    const e = this.peek();
    if (e.type !== "KEYWORD" || !t.has(e.text))
      throw new Error(`expected keyword ${e.text}`);
    return this.pop().text;
  }
  // Pops and returns the value of the next token if it is `type`; throws if out of tokens
  popType(t) {
    if (this.peek().type !== t) {
      const e = this.peek();
      throw new Error(`expected ${t}; got ${e.type} ${JSON.stringify(e.text)}`);
    }
    return this.pop().text;
  }
  // Pops and returns a "(" TOKENS ")"
  popParen() {
    const t = this.peek();
    if (t.type !== "OPEN_PAREN")
      throw new Error("bad start");
    const e = ct(this, bc, Zu).call(this, w(this, le) + 1, t.match + 1);
    return P(this, le, t.match + 1), e;
  }
  // Pops and returns the items within "(" ITEM1 "," ITEM2 "," ... ")"
  popParams() {
    const t = this.peek();
    if (t.type !== "OPEN_PAREN")
      throw new Error("bad start");
    const e = [];
    for (; w(this, le) < t.match - 1; ) {
      const r = this.peek().linkNext;
      e.push(ct(this, bc, Zu).call(this, w(this, le) + 1, r)), P(this, le, r);
    }
    return P(this, le, t.match + 1), e;
  }
  // Returns the top Token, throwing if out of tokens
  peek() {
    if (w(this, le) >= w(this, cr).length)
      throw new Error("out-of-bounds");
    return w(this, cr)[w(this, le)];
  }
  // Returns the next value, if it is a keyword in `allowed`
  peekKeyword(t) {
    const e = this.peekType("KEYWORD");
    return e != null && t.has(e) ? e : null;
  }
  // Returns the value of the next token if it is `type`
  peekType(t) {
    if (this.length === 0)
      return null;
    const e = this.peek();
    return e.type === t ? e.text : null;
  }
  // Returns the next token; throws if out of tokens
  pop() {
    const t = this.peek();
    return Ua(this, le)._++, t;
  }
  toString() {
    const t = [];
    for (let e = w(this, le); e < w(this, cr).length; e++) {
      const r = w(this, cr)[e];
      t.push(`${r.type}:${r.text}`);
    }
    return `<TokenString ${t.join(" ")}>`;
  }
};
le = new WeakMap(), cr = new WeakMap(), bc = new WeakSet(), Zu = function(t = 0, e = 0) {
  return new k_(w(this, cr).slice(t, e).map((r) => Object.freeze(Object.assign({}, r, {
    match: r.match - t,
    linkBack: r.linkBack - t,
    linkNext: r.linkNext - t
  }))));
};
let fr = k_;
function gi(n) {
  const t = [], e = (a) => {
    const c = s < n.length ? JSON.stringify(n[s]) : "$EOI";
    throw new Error(`invalid token ${c} at ${s}: ${a}`);
  };
  let r = [], i = [], s = 0;
  for (; s < n.length; ) {
    let a = n.substring(s), c = a.match(qm);
    c && (s += c[1].length, a = n.substring(s));
    const _ = { depth: r.length, linkBack: -1, linkNext: -1, match: -1, type: "", text: "", offset: s, value: -1 };
    t.push(_);
    let p = $m[a[0]] || "";
    if (p) {
      if (_.type = p, _.text = a[0], s++, p === "OPEN_PAREN")
        r.push(t.length - 1), i.push(t.length - 1);
      else if (p == "CLOSE_PAREN")
        r.length === 0 && e("no matching open bracket"), _.match = r.pop(), t[_.match].match = t.length - 1, _.depth--, _.linkBack = i.pop(), t[_.linkBack].linkNext = t.length - 1;
      else if (p === "COMMA")
        _.linkBack = i.pop(), t[_.linkBack].linkNext = t.length - 1, i.push(t.length - 1);
      else if (p === "OPEN_BRACKET")
        _.type = "BRACKET";
      else if (p === "CLOSE_BRACKET") {
        let f = t.pop().text;
        if (t.length > 0 && t[t.length - 1].type === "NUMBER") {
          const d = t.pop().text;
          f = d + f, t[t.length - 1].value = Rt(d);
        }
        if (t.length === 0 || t[t.length - 1].type !== "BRACKET")
          throw new Error("missing opening bracket");
        t[t.length - 1].text += f;
      }
      continue;
    }
    if (c = a.match(Xm), c) {
      if (_.text = c[1], s += _.text.length, Jm.has(_.text)) {
        _.type = "KEYWORD";
        continue;
      }
      if (_.text.match(S0)) {
        _.type = "TYPE";
        continue;
      }
      _.type = "ID";
      continue;
    }
    if (c = a.match(Zm), c) {
      _.text = c[1], _.type = "NUMBER", s += _.text.length;
      continue;
    }
    throw new Error(`unexpected token ${JSON.stringify(a[0])} at position ${s}`);
  }
  return new fr(t.map((a) => Object.freeze(a)));
}
function np(n, t) {
  let e = [];
  for (const r in t.keys())
    n.has(r) && e.push(r);
  if (e.length > 1)
    throw new Error(`conflicting types: ${e.join(", ")}`);
}
function q_(n, t) {
  if (t.peekKeyword(b0)) {
    const e = t.pop().text;
    if (e !== n)
      throw new Error(`expected ${n}, got ${e}`);
  }
  return t.popType("ID");
}
function Un(n, t) {
  const e = /* @__PURE__ */ new Set();
  for (; ; ) {
    const r = n.peekType("KEYWORD");
    if (r == null || t && !t.has(r))
      break;
    if (n.pop(), e.has(r))
      throw new Error(`duplicate keywords: ${JSON.stringify(r)}`);
    e.add(r);
  }
  return Object.freeze(e);
}
function E0(n) {
  let t = Un(n, Hm);
  return np(t, Re("constant payable nonpayable".split(" "))), np(t, Re("pure view payable nonpayable".split(" "))), t.has("view") ? "view" : t.has("pure") ? "pure" : t.has("payable") ? "payable" : t.has("nonpayable") ? "nonpayable" : t.has("constant") ? "view" : "nonpayable";
}
function zn(n, t) {
  return n.popParams().map((e) => he.from(e, t));
}
function R0(n) {
  if (n.peekType("AT")) {
    if (n.pop(), n.peekType("NUMBER"))
      return ht(n.pop().text);
    throw new Error("invalid gas");
  }
  return null;
}
function ds(n) {
  if (n.length)
    throw new Error(`unexpected tokens at offset ${n.offset}: ${n.toString()}`);
}
const tS = new RegExp(/^(.*)\[([0-9]*)\]$/);
function ip(n) {
  const t = n.match(S0);
  if (T(t, "invalid type", "type", n), n === "uint")
    return "uint256";
  if (n === "int")
    return "int256";
  if (t[2]) {
    const e = parseInt(t[2]);
    T(e !== 0 && e <= 32, "invalid bytes length", "type", n);
  } else if (t[3]) {
    const e = parseInt(t[3]);
    T(e !== 0 && e <= 256 && e % 8 === 0, "invalid numeric width", "type", n);
  }
  return n;
}
const Yt = {}, Be = Symbol.for("_ethers_internal"), sp = "_ParamTypeInternal", op = "_ErrorInternal", ap = "_EventInternal", cp = "_ConstructorInternal", _p = "_FallbackInternal", lp = "_FunctionInternal", up = "_StructInternal";
var na, Zc;
const Ve = class Ve {
  /**
   *  @private
   */
  constructor(t, e, r, i, s, a, c, _) {
    j(this, na);
    /**
     *  The local name of the parameter (or ``""`` if unbound)
     */
    U(this, "name");
    /**
     *  The fully qualified type (e.g. ``"address"``, ``"tuple(address)"``,
     *  ``"uint256[3][]"``)
     */
    U(this, "type");
    /**
     *  The base type (e.g. ``"address"``, ``"tuple"``, ``"array"``)
     */
    U(this, "baseType");
    /**
     *  True if the parameters is indexed.
     *
     *  For non-indexable types this is ``null``.
     */
    U(this, "indexed");
    /**
     *  The components for the tuple.
     *
     *  For non-tuple types this is ``null``.
     */
    U(this, "components");
    /**
     *  The array length, or ``-1`` for dynamic-lengthed arrays.
     *
     *  For non-array types this is ``null``.
     */
    U(this, "arrayLength");
    /**
     *  The type of each child in the array.
     *
     *  For non-array types this is ``null``.
     */
    U(this, "arrayChildren");
    if (K_(t, Yt, "ParamType"), Object.defineProperty(this, Be, { value: sp }), a && (a = Object.freeze(a.slice())), i === "array") {
      if (c == null || _ == null)
        throw new Error("");
    } else if (c != null || _ != null)
      throw new Error("");
    if (i === "tuple") {
      if (a == null)
        throw new Error("");
    } else if (a != null)
      throw new Error("");
    gt(this, {
      name: e,
      type: r,
      baseType: i,
      indexed: s,
      components: a,
      arrayLength: c,
      arrayChildren: _
    });
  }
  /**
   *  Return a string representation of this type.
   *
   *  For example,
   *
   *  ``sighash" => "(uint256,address)"``
   *
   *  ``"minimal" => "tuple(uint256,address) indexed"``
   *
   *  ``"full" => "tuple(uint256 foo, address bar) indexed baz"``
   */
  format(t) {
    if (t == null && (t = "sighash"), t === "json") {
      const r = this.name || "";
      if (this.isArray()) {
        const s = JSON.parse(this.arrayChildren.format("json"));
        return s.name = r, s.type += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`, JSON.stringify(s);
      }
      const i = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: r
      };
      return typeof this.indexed == "boolean" && (i.indexed = this.indexed), this.isTuple() && (i.components = this.components.map((s) => JSON.parse(s.format(t)))), JSON.stringify(i);
    }
    let e = "";
    return this.isArray() ? (e += this.arrayChildren.format(t), e += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`) : this.isTuple() ? e += "(" + this.components.map((r) => r.format(t)).join(t === "full" ? ", " : ",") + ")" : e += this.type, t !== "sighash" && (this.indexed === !0 && (e += " indexed"), t === "full" && this.name && (e += " " + this.name)), e;
  }
  /**
   *  Returns true if %%this%% is an Array type.
   *
   *  This provides a type gaurd ensuring that [[arrayChildren]]
   *  and [[arrayLength]] are non-null.
   */
  isArray() {
    return this.baseType === "array";
  }
  /**
   *  Returns true if %%this%% is a Tuple type.
   *
   *  This provides a type gaurd ensuring that [[components]]
   *  is non-null.
   */
  isTuple() {
    return this.baseType === "tuple";
  }
  /**
   *  Returns true if %%this%% is an Indexable type.
   *
   *  This provides a type gaurd ensuring that [[indexed]]
   *  is non-null.
   */
  isIndexable() {
    return this.indexed != null;
  }
  /**
   *  Walks the **ParamType** with %%value%%, calling %%process%%
   *  on each type, destructing the %%value%% recursively.
   */
  walk(t, e) {
    if (this.isArray()) {
      if (!Array.isArray(t))
        throw new Error("invalid array value");
      if (this.arrayLength !== -1 && t.length !== this.arrayLength)
        throw new Error("array is wrong length");
      const r = this;
      return t.map((i) => r.arrayChildren.walk(i, e));
    }
    if (this.isTuple()) {
      if (!Array.isArray(t))
        throw new Error("invalid tuple value");
      if (t.length !== this.components.length)
        throw new Error("array is wrong length");
      const r = this;
      return t.map((i, s) => r.components[s].walk(i, e));
    }
    return e(this.type, t);
  }
  /**
   *  Walks the **ParamType** with %%value%%, asynchronously calling
   *  %%process%% on each type, destructing the %%value%% recursively.
   *
   *  This can be used to resolve ENS names by walking and resolving each
   *  ``"address"`` type.
   */
  async walkAsync(t, e) {
    const r = [], i = [t];
    return ct(this, na, Zc).call(this, r, t, e, (s) => {
      i[0] = s;
    }), r.length && await Promise.all(r), i[0];
  }
  /**
   *  Creates a new **ParamType** for %%obj%%.
   *
   *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,
   *  otherwise the ``indexed`` keyword will throw an error.
   */
  static from(t, e) {
    if (Ve.isParamType(t))
      return t;
    if (typeof t == "string")
      try {
        return Ve.from(gi(t), e);
      } catch {
        T(!1, "invalid param type", "obj", t);
      }
    else if (t instanceof fr) {
      let c = "", _ = "", p = null;
      Un(t, Re(["tuple"])).has("tuple") || t.peekType("OPEN_PAREN") ? (_ = "tuple", p = t.popParams().map((R) => Ve.from(R)), c = `tuple(${p.map((R) => R.format()).join(",")})`) : (c = ip(t.popType("TYPE")), _ = c);
      let f = null, d = null;
      for (; t.length && t.peekType("BRACKET"); ) {
        const R = t.pop();
        f = new Ve(Yt, "", c, _, null, p, d, f), d = R.value, c += R.text, _ = "array", p = null;
      }
      let y = null;
      if (Un(t, Ym).has("indexed")) {
        if (!e)
          throw new Error("");
        y = !0;
      }
      const v = t.peekType("ID") ? t.pop().text : "";
      if (t.length)
        throw new Error("leftover tokens");
      return new Ve(Yt, v, c, _, y, p, d, f);
    }
    const r = t.name;
    T(!r || typeof r == "string" && r.match(m0), "invalid name", "obj.name", r);
    let i = t.indexed;
    i != null && (T(e, "parameter cannot be indexed", "obj.indexed", t.indexed), i = !!i);
    let s = t.type, a = s.match(tS);
    if (a) {
      const c = parseInt(a[2] || "-1"), _ = Ve.from({
        type: a[1],
        components: t.components
      });
      return new Ve(Yt, r || "", s, "array", i, null, c, _);
    }
    if (s === "tuple" || s.startsWith(
      "tuple("
      /* fix: ) */
    ) || s.startsWith(
      "("
      /* fix: ) */
    )) {
      const c = t.components != null ? t.components.map((p) => Ve.from(p)) : null;
      return new Ve(Yt, r || "", s, "tuple", i, c, null, null);
    }
    return s = ip(t.type), new Ve(Yt, r || "", s, s, i, null, null, null);
  }
  /**
   *  Returns true if %%value%% is a **ParamType**.
   */
  static isParamType(t) {
    return t && t[Be] === sp;
  }
};
na = new WeakSet(), Zc = function(t, e, r, i) {
  if (this.isArray()) {
    if (!Array.isArray(e))
      throw new Error("invalid array value");
    if (this.arrayLength !== -1 && e.length !== this.arrayLength)
      throw new Error("array is wrong length");
    const a = this.arrayChildren, c = e.slice();
    c.forEach((_, p) => {
      var f;
      ct(f = a, na, Zc).call(f, t, _, r, (d) => {
        c[p] = d;
      });
    }), i(c);
    return;
  }
  if (this.isTuple()) {
    const a = this.components;
    let c;
    if (Array.isArray(e))
      c = e.slice();
    else {
      if (e == null || typeof e != "object")
        throw new Error("invalid tuple value");
      c = a.map((_) => {
        if (!_.name)
          throw new Error("cannot use object value with unnamed components");
        if (!(_.name in e))
          throw new Error(`missing value for component ${_.name}`);
        return e[_.name];
      });
    }
    if (c.length !== this.components.length)
      throw new Error("array is wrong length");
    c.forEach((_, p) => {
      var f;
      ct(f = a[p], na, Zc).call(f, t, _, r, (d) => {
        c[p] = d;
      });
    }), i(c);
    return;
  }
  const s = r(this.type, e);
  s.then ? t.push(async function() {
    i(await s);
  }()) : i(s);
};
let he = Ve;
class ws {
  /**
   *  @private
   */
  constructor(t, e, r) {
    /**
     *  The type of the fragment.
     */
    U(this, "type");
    /**
     *  The inputs for the fragment.
     */
    U(this, "inputs");
    K_(t, Yt, "Fragment"), r = Object.freeze(r.slice()), gt(this, { type: e, inputs: r });
  }
  /**
   *  Creates a new **Fragment** for %%obj%%, wich can be any supported
   *  ABI frgament type.
   */
  static from(t) {
    if (typeof t == "string") {
      try {
        ws.from(JSON.parse(t));
      } catch {
      }
      return ws.from(gi(t));
    }
    if (t instanceof fr)
      switch (t.peekKeyword(b0)) {
        case "constructor":
          return In.from(t);
        case "error":
          return xe.from(t);
        case "event":
          return cn.from(t);
        case "fallback":
        case "receive":
          return wn.from(t);
        case "function":
          return _n.from(t);
        case "struct":
          return cs.from(t);
      }
    else if (typeof t == "object") {
      switch (t.type) {
        case "constructor":
          return In.from(t);
        case "error":
          return xe.from(t);
        case "event":
          return cn.from(t);
        case "fallback":
        case "receive":
          return wn.from(t);
        case "function":
          return _n.from(t);
        case "struct":
          return cs.from(t);
      }
      et(!1, `unsupported type: ${t.type}`, "UNSUPPORTED_OPERATION", {
        operation: "Fragment.from"
      });
    }
    T(!1, "unsupported frgament object", "obj", t);
  }
  /**
   *  Returns true if %%value%% is a [[ConstructorFragment]].
   */
  static isConstructor(t) {
    return In.isFragment(t);
  }
  /**
   *  Returns true if %%value%% is an [[ErrorFragment]].
   */
  static isError(t) {
    return xe.isFragment(t);
  }
  /**
   *  Returns true if %%value%% is an [[EventFragment]].
   */
  static isEvent(t) {
    return cn.isFragment(t);
  }
  /**
   *  Returns true if %%value%% is a [[FunctionFragment]].
   */
  static isFunction(t) {
    return _n.isFragment(t);
  }
  /**
   *  Returns true if %%value%% is a [[StructFragment]].
   */
  static isStruct(t) {
    return cs.isFragment(t);
  }
}
class Z_ extends ws {
  /**
   *  @private
   */
  constructor(e, r, i, s) {
    super(e, r, s);
    /**
     *  The name of the fragment.
     */
    U(this, "name");
    T(typeof i == "string" && i.match(m0), "invalid identifier", "name", i), s = Object.freeze(s.slice()), gt(this, { name: i });
  }
}
function ac(n, t) {
  return "(" + t.map((e) => e.format(n)).join(n === "full" ? ", " : ",") + ")";
}
class xe extends Z_ {
  /**
   *  @private
   */
  constructor(t, e, r) {
    super(t, "error", e, r), Object.defineProperty(this, Be, { value: op });
  }
  /**
   *  The Custom Error selector.
   */
  get selector() {
    return ps(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this fragment as %%format%%.
   */
  format(t) {
    if (t == null && (t = "sighash"), t === "json")
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((r) => JSON.parse(r.format(t)))
      });
    const e = [];
    return t !== "sighash" && e.push("error"), e.push(this.name + ac(t, this.inputs)), e.join(" ");
  }
  /**
   *  Returns a new **ErrorFragment** for %%obj%%.
   */
  static from(t) {
    if (xe.isFragment(t))
      return t;
    if (typeof t == "string")
      return xe.from(gi(t));
    if (t instanceof fr) {
      const e = q_("error", t), r = zn(t);
      return ds(t), new xe(Yt, e, r);
    }
    return new xe(Yt, t.name, t.inputs ? t.inputs.map(he.from) : []);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **ErrorFragment**.
   */
  static isFragment(t) {
    return t && t[Be] === op;
  }
}
class cn extends Z_ {
  /**
   *  @private
   */
  constructor(e, r, i, s) {
    super(e, "event", r, i);
    /**
     *  Whether this event is anonymous.
     */
    U(this, "anonymous");
    Object.defineProperty(this, Be, { value: ap }), gt(this, { anonymous: s });
  }
  /**
   *  The Event topic hash.
   */
  get topicHash() {
    return ps(this.format("sighash"));
  }
  /**
   *  Returns a string representation of this event as %%format%%.
   */
  format(e) {
    if (e == null && (e = "sighash"), e === "json")
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((i) => JSON.parse(i.format(e)))
      });
    const r = [];
    return e !== "sighash" && r.push("event"), r.push(this.name + ac(e, this.inputs)), e !== "sighash" && this.anonymous && r.push("anonymous"), r.join(" ");
  }
  /**
   *  Return the topic hash for an event with %%name%% and %%params%%.
   */
  static getTopicHash(e, r) {
    return r = (r || []).map((s) => he.from(s)), new cn(Yt, e, r, !1).topicHash;
  }
  /**
   *  Returns a new **EventFragment** for %%obj%%.
   */
  static from(e) {
    if (cn.isFragment(e))
      return e;
    if (typeof e == "string")
      try {
        return cn.from(gi(e));
      } catch {
        T(!1, "invalid event fragment", "obj", e);
      }
    else if (e instanceof fr) {
      const r = q_("event", e), i = zn(e, !0), s = !!Un(e, Re(["anonymous"])).has("anonymous");
      return ds(e), new cn(Yt, r, i, s);
    }
    return new cn(Yt, e.name, e.inputs ? e.inputs.map((r) => he.from(r, !0)) : [], !!e.anonymous);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **EventFragment**.
   */
  static isFragment(e) {
    return e && e[Be] === ap;
  }
}
class In extends ws {
  /**
   *  @private
   */
  constructor(e, r, i, s, a) {
    super(e, r, i);
    /**
     *  Whether the constructor can receive an endowment.
     */
    U(this, "payable");
    /**
     *  The recommended gas limit for deployment or ``null``.
     */
    U(this, "gas");
    Object.defineProperty(this, Be, { value: cp }), gt(this, { payable: s, gas: a });
  }
  /**
   *  Returns a string representation of this constructor as %%format%%.
   */
  format(e) {
    if (et(e != null && e !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", { operation: "format(sighash)" }), e === "json")
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.payable ? "payable" : "undefined",
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((i) => JSON.parse(i.format(e)))
      });
    const r = [`constructor${ac(e, this.inputs)}`];
    return this.payable && r.push("payable"), this.gas != null && r.push(`@${this.gas.toString()}`), r.join(" ");
  }
  /**
   *  Returns a new **ConstructorFragment** for %%obj%%.
   */
  static from(e) {
    if (In.isFragment(e))
      return e;
    if (typeof e == "string")
      try {
        return In.from(gi(e));
      } catch {
        T(!1, "invalid constuctor fragment", "obj", e);
      }
    else if (e instanceof fr) {
      Un(e, Re(["constructor"]));
      const r = zn(e), i = !!Un(e, jm).has("payable"), s = R0(e);
      return ds(e), new In(Yt, "constructor", r, i, s);
    }
    return new In(Yt, "constructor", e.inputs ? e.inputs.map(he.from) : [], !!e.payable, e.gas != null ? e.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **ConstructorFragment**.
   */
  static isFragment(e) {
    return e && e[Be] === cp;
  }
}
class wn extends ws {
  constructor(e, r, i) {
    super(e, "fallback", r);
    /**
     *  If the function can be sent value during invocation.
     */
    U(this, "payable");
    Object.defineProperty(this, Be, { value: _p }), gt(this, { payable: i });
  }
  /**
   *  Returns a string representation of this fallback as %%format%%.
   */
  format(e) {
    const r = this.inputs.length === 0 ? "receive" : "fallback";
    if (e === "json") {
      const i = this.payable ? "payable" : "nonpayable";
      return JSON.stringify({ type: r, stateMutability: i });
    }
    return `${r}()${this.payable ? " payable" : ""}`;
  }
  /**
   *  Returns a new **FallbackFragment** for %%obj%%.
   */
  static from(e) {
    if (wn.isFragment(e))
      return e;
    if (typeof e == "string")
      try {
        return wn.from(gi(e));
      } catch {
        T(!1, "invalid fallback fragment", "obj", e);
      }
    else if (e instanceof fr) {
      const r = e.toString(), i = e.peekKeyword(Re(["fallback", "receive"]));
      if (T(i, "type must be fallback or receive", "obj", r), e.popKeyword(Re(["fallback", "receive"])) === "receive") {
        const _ = zn(e);
        return T(_.length === 0, "receive cannot have arguments", "obj.inputs", _), Un(e, Re(["payable"])), ds(e), new wn(Yt, [], !0);
      }
      let a = zn(e);
      a.length ? T(a.length === 1 && a[0].type === "bytes", "invalid fallback inputs", "obj.inputs", a.map((_) => _.format("minimal")).join(", ")) : a = [he.from("bytes")];
      const c = E0(e);
      if (T(c === "nonpayable" || c === "payable", "fallback cannot be constants", "obj.stateMutability", c), Un(e, Re(["returns"])).has("returns")) {
        const _ = zn(e);
        T(_.length === 1 && _[0].type === "bytes", "invalid fallback outputs", "obj.outputs", _.map((p) => p.format("minimal")).join(", "));
      }
      return ds(e), new wn(Yt, a, c === "payable");
    }
    if (e.type === "receive")
      return new wn(Yt, [], !0);
    if (e.type === "fallback") {
      const r = [he.from("bytes")], i = e.stateMutability === "payable";
      return new wn(Yt, r, i);
    }
    T(!1, "invalid fallback description", "obj", e);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FallbackFragment**.
   */
  static isFragment(e) {
    return e && e[Be] === _p;
  }
}
class _n extends Z_ {
  /**
   *  @private
   */
  constructor(e, r, i, s, a, c) {
    super(e, "function", r, s);
    /**
     *  If the function is constant (e.g. ``pure`` or ``view`` functions).
     */
    U(this, "constant");
    /**
     *  The returned types for the result of calling this function.
     */
    U(this, "outputs");
    /**
     *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``
     *  or ``pure``)
     */
    U(this, "stateMutability");
    /**
     *  If the function can be sent value during invocation.
     */
    U(this, "payable");
    /**
     *  The recommended gas limit to send when calling this function.
     */
    U(this, "gas");
    Object.defineProperty(this, Be, { value: lp }), a = Object.freeze(a.slice()), gt(this, { constant: i === "view" || i === "pure", gas: c, outputs: a, payable: i === "payable", stateMutability: i });
  }
  /**
   *  The Function selector.
   */
  get selector() {
    return ps(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this function as %%format%%.
   */
  format(e) {
    if (e == null && (e = "sighash"), e === "json")
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((i) => JSON.parse(i.format(e))),
        outputs: this.outputs.map((i) => JSON.parse(i.format(e)))
      });
    const r = [];
    return e !== "sighash" && r.push("function"), r.push(this.name + ac(e, this.inputs)), e !== "sighash" && (this.stateMutability !== "nonpayable" && r.push(this.stateMutability), this.outputs && this.outputs.length && (r.push("returns"), r.push(ac(e, this.outputs))), this.gas != null && r.push(`@${this.gas.toString()}`)), r.join(" ");
  }
  /**
   *  Return the selector for a function with %%name%% and %%params%%.
   */
  static getSelector(e, r) {
    return r = (r || []).map((s) => he.from(s)), new _n(Yt, e, "view", r, [], null).selector;
  }
  /**
   *  Returns a new **FunctionFragment** for %%obj%%.
   */
  static from(e) {
    if (_n.isFragment(e))
      return e;
    if (typeof e == "string")
      try {
        return _n.from(gi(e));
      } catch {
        T(!1, "invalid function fragment", "obj", e);
      }
    else if (e instanceof fr) {
      const i = q_("function", e), s = zn(e), a = E0(e);
      let c = [];
      Un(e, Re(["returns"])).has("returns") && (c = zn(e));
      const _ = R0(e);
      return ds(e), new _n(Yt, i, a, s, c, _);
    }
    let r = e.stateMutability;
    return r == null && (r = "payable", typeof e.constant == "boolean" ? (r = "view", e.constant || (r = "payable", typeof e.payable == "boolean" && !e.payable && (r = "nonpayable"))) : typeof e.payable == "boolean" && !e.payable && (r = "nonpayable")), new _n(Yt, e.name, r, e.inputs ? e.inputs.map(he.from) : [], e.outputs ? e.outputs.map(he.from) : [], e.gas != null ? e.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FunctionFragment**.
   */
  static isFragment(e) {
    return e && e[Be] === lp;
  }
}
class cs extends Z_ {
  /**
   *  @private
   */
  constructor(t, e, r) {
    super(t, "struct", e, r), Object.defineProperty(this, Be, { value: up });
  }
  /**
   *  Returns a string representation of this struct as %%format%%.
   */
  format() {
    throw new Error("@TODO");
  }
  /**
   *  Returns a new **StructFragment** for %%obj%%.
   */
  static from(t) {
    if (typeof t == "string")
      try {
        return cs.from(gi(t));
      } catch {
        T(!1, "invalid struct fragment", "obj", t);
      }
    else if (t instanceof fr) {
      const e = q_("struct", t), r = zn(t);
      return ds(t), new cs(Yt, e, r);
    }
    return new cs(Yt, t.name, t.inputs ? t.inputs.map(he.from) : []);
  }
  // @TODO: fix this return type
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **StructFragment**.
   */
  static isFragment(t) {
    return t && t[Be] === up;
  }
}
const dr = /* @__PURE__ */ new Map();
dr.set(0, "GENERIC_PANIC");
dr.set(1, "ASSERT_FALSE");
dr.set(17, "OVERFLOW");
dr.set(18, "DIVIDE_BY_ZERO");
dr.set(33, "ENUM_RANGE_ERROR");
dr.set(34, "BAD_STORAGE_DATA");
dr.set(49, "STACK_UNDERFLOW");
dr.set(50, "ARRAY_RANGE_ERROR");
dr.set(65, "OUT_OF_MEMORY");
dr.set(81, "UNINITIALIZED_FUNCTION_CALL");
const eS = new RegExp(/^bytes([0-9]*)$/), rS = new RegExp(/^(u?int)([0-9]*)$/);
let cu = null, fp = 1024;
function nS(n, t, e, r) {
  let i = "missing revert data", s = null;
  const a = null;
  let c = null;
  if (e) {
    i = "execution reverted";
    const p = Tt(e);
    if (e = ut(e), p.length === 0)
      i += " (no data present; likely require(false) occurred", s = "require(false)";
    else if (p.length % 32 !== 4)
      i += " (could not decode reason; invalid data length)";
    else if (ut(p.slice(0, 4)) === "0x08c379a0")
      try {
        s = r.decode(["string"], p.slice(4))[0], c = {
          signature: "Error(string)",
          name: "Error",
          args: [s]
        }, i += `: ${JSON.stringify(s)}`;
      } catch {
        i += " (could not decode reason; invalid string data)";
      }
    else if (ut(p.slice(0, 4)) === "0x4e487b71")
      try {
        const f = Number(r.decode(["uint256"], p.slice(4))[0]);
        c = {
          signature: "Panic(uint256)",
          name: "Panic",
          args: [f]
        }, s = `Panic due to ${dr.get(f) || "UNKNOWN"}(${f})`, i += `: ${s}`;
      } catch {
        i += " (could not decode panic code)";
      }
    else
      i += " (unknown custom error)";
  }
  const _ = {
    to: t.to ? zt(t.to) : null,
    data: t.data || "0x"
  };
  return t.from && (_.from = zt(t.from)), Wt(i, "CALL_EXCEPTION", {
    action: n,
    data: e,
    reason: s,
    transaction: _,
    invocation: a,
    revert: c
  });
}
var ti, Ns;
const U_ = class U_ {
  constructor() {
    j(this, ti);
  }
  /**
   *  Get the default values for the given %%types%%.
   *
   *  For example, a ``uint`` is by default ``0`` and ``bool``
   *  is by default ``false``.
   */
  getDefaultValue(t) {
    const e = t.map((i) => ct(this, ti, Ns).call(this, he.from(i)));
    return new Vc(e, "_").defaultValue();
  }
  /**
   *  Encode the %%values%% as the %%types%% into ABI data.
   *
   *  @returns DataHexstring
   */
  encode(t, e) {
    Zw(e.length, t.length, "types/values length mismatch");
    const r = t.map((a) => ct(this, ti, Ns).call(this, he.from(a))), i = new Vc(r, "_"), s = new Fu();
    return i.encode(s, e), s.data;
  }
  /**
   *  Decode the ABI %%data%% as the %%types%% into values.
   *
   *  If %%loose%% decoding is enabled, then strict padding is
   *  not enforced. Some older versions of Solidity incorrectly
   *  padded event data emitted from ``external`` functions.
   */
  decode(t, e, r) {
    const i = t.map((a) => ct(this, ti, Ns).call(this, he.from(a)));
    return new Vc(i, "_").decode(new Gu(e, r, fp));
  }
  static _setDefaultMaxInflation(t) {
    T(typeof t == "number" && Number.isInteger(t), "invalid defaultMaxInflation factor", "value", t), fp = t;
  }
  /**
   *  Returns the shared singleton instance of a default [[AbiCoder]].
   *
   *  On the first call, the instance is created internally.
   */
  static defaultAbiCoder() {
    return cu == null && (cu = new U_()), cu;
  }
  /**
   *  Returns an ethers-compatible [[CallExceptionError]] Error for the given
   *  result %%data%% for the [[CallExceptionAction]] %%action%% against
   *  the Transaction %%tx%%.
   */
  static getBuiltinCallException(t, e, r) {
    return nS(t, e, r, U_.defaultAbiCoder());
  }
};
ti = new WeakSet(), Ns = function(t) {
  if (t.isArray())
    return new vA(ct(this, ti, Ns).call(this, t.arrayChildren), t.arrayLength, t.name);
  if (t.isTuple())
    return new Vc(t.components.map((r) => ct(this, ti, Ns).call(this, r)), t.name);
  switch (t.baseType) {
    case "address":
      return new RA(t.name);
    case "bool":
      return new MA(t.name);
    case "string":
      return new kA(t.name);
    case "bytes":
      return new xA(t.name);
    case "":
      return new IA(t.name);
  }
  let e = t.type.match(rS);
  if (e) {
    let r = parseInt(e[2] || "256");
    return T(r !== 0 && r <= 256 && r % 8 === 0, "invalid " + e[1] + " bit length", "param", t), new zA(r / 8, e[1] === "int", t.name);
  }
  if (e = t.type.match(eS), e) {
    let r = parseInt(e[1]);
    return T(r !== 0 && r <= 32, "invalid bytes length", "param", t), new BA(r, t.name);
  }
  T(!1, "invalid type", "type", t.type);
};
let cc = U_;
class iS {
  /**
   *  @_ignore:
   */
  constructor(t, e, r) {
    /**
     *  The matching fragment for the ``topic0``.
     */
    U(this, "fragment");
    /**
     *  The name of the Event.
     */
    U(this, "name");
    /**
     *  The full Event signature.
     */
    U(this, "signature");
    /**
     *  The topic hash for the Event.
     */
    U(this, "topic");
    /**
     *  The arguments passed into the Event with ``emit``.
     */
    U(this, "args");
    const i = t.name, s = t.format();
    gt(this, {
      fragment: t,
      name: i,
      signature: s,
      topic: e,
      args: r
    });
  }
}
class sS {
  /**
   *  @_ignore:
   */
  constructor(t, e, r, i) {
    /**
     *  The matching fragment from the transaction ``data``.
     */
    U(this, "fragment");
    /**
     *  The name of the Function from the transaction ``data``.
     */
    U(this, "name");
    /**
     *  The arguments passed to the Function from the transaction ``data``.
     */
    U(this, "args");
    /**
     *  The full Function signature from the transaction ``data``.
     */
    U(this, "signature");
    /**
     *  The selector for the Function from the transaction ``data``.
     */
    U(this, "selector");
    /**
     *  The ``value`` (in wei) from the transaction.
     */
    U(this, "value");
    const s = t.name, a = t.format();
    gt(this, {
      fragment: t,
      name: s,
      args: r,
      signature: a,
      selector: e,
      value: i
    });
  }
}
class oS {
  /**
   *  @_ignore:
   */
  constructor(t, e, r) {
    /**
     *  The matching fragment.
     */
    U(this, "fragment");
    /**
     *  The name of the Error.
     */
    U(this, "name");
    /**
     *  The arguments passed to the Error with ``revert``.
     */
    U(this, "args");
    /**
     *  The full Error signature.
     */
    U(this, "signature");
    /**
     *  The selector for the Error.
     */
    U(this, "selector");
    const i = t.name, s = t.format();
    gt(this, {
      fragment: t,
      name: i,
      args: r,
      signature: s,
      selector: e
    });
  }
}
class hp {
  /**
   *  @_ignore:
   */
  constructor(t) {
    /**
     *  The ``keccak256`` of the value logged.
     */
    U(this, "hash");
    /**
     *  @_ignore:
     */
    U(this, "_isIndexed");
    gt(this, { hash: t, _isIndexed: !0 });
  }
  /**
   *  Returns ``true`` if %%value%% is an **Indexed**.
   *
   *  This provides a Type Guard for property access.
   */
  static isIndexed(t) {
    return !!(t && t._isIndexed);
  }
}
const pp = {
  0: "generic panic",
  1: "assert(false)",
  17: "arithmetic overflow",
  18: "division or modulo by zero",
  33: "enum overflow",
  34: "invalid encoded storage byte array accessed",
  49: "out-of-bounds array access; popping on an empty array",
  50: "out-of-bounds access of an array or bytesN",
  65: "out of memory",
  81: "uninitialized function"
}, dp = {
  "0x08c379a0": {
    signature: "Error(string)",
    name: "Error",
    inputs: ["string"],
    reason: (n) => `reverted with reason string ${JSON.stringify(n)}`
  },
  "0x4e487b71": {
    signature: "Panic(uint256)",
    name: "Panic",
    inputs: ["uint256"],
    reason: (n) => {
      let t = "unknown panic code";
      return n >= 0 && n <= 255 && pp[n.toString()] && (t = pp[n.toString()]), `reverted with panic code 0x${n.toString(16)} (${t})`;
    }
  }
};
var Rr, Pr, vr, pe, un, Xc, t_;
const Bi = class Bi {
  /**
   *  Create a new Interface for the %%fragments%%.
   */
  constructor(t) {
    j(this, un);
    /**
     *  All the Contract ABI members (i.e. methods, events, errors, etc).
     */
    U(this, "fragments");
    /**
     *  The Contract constructor.
     */
    U(this, "deploy");
    /**
     *  The Fallback method, if any.
     */
    U(this, "fallback");
    /**
     *  If receiving ether is supported.
     */
    U(this, "receive");
    j(this, Rr);
    j(this, Pr);
    j(this, vr);
    //    #structs: Map<string, StructFragment>;
    j(this, pe);
    let e = [];
    typeof t == "string" ? e = JSON.parse(t) : e = t, P(this, vr, /* @__PURE__ */ new Map()), P(this, Rr, /* @__PURE__ */ new Map()), P(this, Pr, /* @__PURE__ */ new Map());
    const r = [];
    for (const a of e)
      try {
        r.push(ws.from(a));
      } catch (c) {
        console.log(`[Warning] Invalid Fragment ${JSON.stringify(a)}:`, c.message);
      }
    gt(this, {
      fragments: Object.freeze(r)
    });
    let i = null, s = !1;
    P(this, pe, this.getAbiCoder()), this.fragments.forEach((a, c) => {
      let _;
      switch (a.type) {
        case "constructor":
          if (this.deploy) {
            console.log("duplicate definition - constructor");
            return;
          }
          gt(this, { deploy: a });
          return;
        case "fallback":
          a.inputs.length === 0 ? s = !0 : (T(!i || a.payable !== i.payable, "conflicting fallback fragments", `fragments[${c}]`, a), i = a, s = i.payable);
          return;
        case "function":
          _ = w(this, vr);
          break;
        case "event":
          _ = w(this, Pr);
          break;
        case "error":
          _ = w(this, Rr);
          break;
        default:
          return;
      }
      const p = a.format();
      _.has(p) || _.set(p, a);
    }), this.deploy || gt(this, {
      deploy: In.from("constructor()")
    }), gt(this, { fallback: i, receive: s });
  }
  /**
   *  Returns the entire Human-Readable ABI, as an array of
   *  signatures, optionally as %%minimal%% strings, which
   *  removes parameter names and unneceesary spaces.
   */
  format(t) {
    const e = t ? "minimal" : "full";
    return this.fragments.map((i) => i.format(e));
  }
  /**
   *  Return the JSON-encoded ABI. This is the format Solidiy
   *  returns.
   */
  formatJson() {
    const t = this.fragments.map((e) => e.format("json"));
    return JSON.stringify(t.map((e) => JSON.parse(e)));
  }
  /**
   *  The ABI coder that will be used to encode and decode binary
   *  data.
   */
  getAbiCoder() {
    return cc.defaultAbiCoder();
  }
  /**
   *  Get the function name for %%key%%, which may be a function selector,
   *  function name or function signature that belongs to the ABI.
   */
  getFunctionName(t) {
    const e = ct(this, un, Xc).call(this, t, null, !1);
    return T(e, "no matching function", "key", t), e.name;
  }
  /**
   *  Returns true if %%key%% (a function selector, function name or
   *  function signature) is present in the ABI.
   *
   *  In the case of a function name, the name may be ambiguous, so
   *  accessing the [[FunctionFragment]] may require refinement.
   */
  hasFunction(t) {
    return !!ct(this, un, Xc).call(this, t, null, !1);
  }
  /**
   *  Get the [[FunctionFragment]] for %%key%%, which may be a function
   *  selector, function name or function signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple functions match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single function in
   *  the ABI, this will throw.
   */
  getFunction(t, e) {
    return ct(this, un, Xc).call(this, t, e || null, !0);
  }
  /**
   *  Iterate over all functions, calling %%callback%%, sorted by their name.
   */
  forEachFunction(t) {
    const e = Array.from(w(this, vr).keys());
    e.sort((r, i) => r.localeCompare(i));
    for (let r = 0; r < e.length; r++) {
      const i = e[r];
      t(w(this, vr).get(i), r);
    }
  }
  /**
   *  Get the event name for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   */
  getEventName(t) {
    const e = ct(this, un, t_).call(this, t, null, !1);
    return T(e, "no matching event", "key", t), e.name;
  }
  /**
   *  Returns true if %%key%% (an event topic hash, event name or
   *  event signature) is present in the ABI.
   *
   *  In the case of an event name, the name may be ambiguous, so
   *  accessing the [[EventFragment]] may require refinement.
   */
  hasEvent(t) {
    return !!ct(this, un, t_).call(this, t, null, !1);
  }
  /**
   *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple events match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single event in
   *  the ABI, this will throw.
   */
  getEvent(t, e) {
    return ct(this, un, t_).call(this, t, e || null, !0);
  }
  /**
   *  Iterate over all events, calling %%callback%%, sorted by their name.
   */
  forEachEvent(t) {
    const e = Array.from(w(this, Pr).keys());
    e.sort((r, i) => r.localeCompare(i));
    for (let r = 0; r < e.length; r++) {
      const i = e[r];
      t(w(this, Pr).get(i), r);
    }
  }
  /**
   *  Get the [[ErrorFragment]] for %%key%%, which may be an error
   *  selector, error name or error signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple errors match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single error in
   *  the ABI, this will throw.
   */
  getError(t, e) {
    if (jt(t)) {
      const i = t.toLowerCase();
      if (dp[i])
        return xe.from(dp[i].signature);
      for (const s of w(this, Rr).values())
        if (i === s.selector)
          return s;
      return null;
    }
    if (t.indexOf("(") === -1) {
      const i = [];
      for (const [s, a] of w(this, Rr))
        s.split(
          "("
          /* fix:) */
        )[0] === t && i.push(a);
      if (i.length === 0)
        return t === "Error" ? xe.from("error Error(string)") : t === "Panic" ? xe.from("error Panic(uint256)") : null;
      if (i.length > 1) {
        const s = i.map((a) => JSON.stringify(a.format())).join(", ");
        T(!1, `ambiguous error description (i.e. ${s})`, "name", t);
      }
      return i[0];
    }
    if (t = xe.from(t).format(), t === "Error(string)")
      return xe.from("error Error(string)");
    if (t === "Panic(uint256)")
      return xe.from("error Panic(uint256)");
    const r = w(this, Rr).get(t);
    return r || null;
  }
  /**
   *  Iterate over all errors, calling %%callback%%, sorted by their name.
   */
  forEachError(t) {
    const e = Array.from(w(this, Rr).keys());
    e.sort((r, i) => r.localeCompare(i));
    for (let r = 0; r < e.length; r++) {
      const i = e[r];
      t(w(this, Rr).get(i), r);
    }
  }
  // Get the 4-byte selector used by Solidity to identify a function
  /*
  getSelector(fragment: ErrorFragment | FunctionFragment): string {
      if (typeof(fragment) === "string") {
          const matches: Array<Fragment> = [ ];
  
          try { matches.push(this.getFunction(fragment)); } catch (error) { }
          try { matches.push(this.getError(<string>fragment)); } catch (_) { }
  
          if (matches.length === 0) {
              logger.throwArgumentError("unknown fragment", "key", fragment);
          } else if (matches.length > 1) {
              logger.throwArgumentError("ambiguous fragment matches function and error", "key", fragment);
          }
  
          fragment = matches[0];
      }
  
      return dataSlice(id(fragment.format()), 0, 4);
  }
      */
  // Get the 32-byte topic hash used by Solidity to identify an event
  /*
  getEventTopic(fragment: EventFragment): string {
      //if (typeof(fragment) === "string") { fragment = this.getEvent(eventFragment); }
      return id(fragment.format());
  }
  */
  _decodeParams(t, e) {
    return w(this, pe).decode(t, e);
  }
  _encodeParams(t, e) {
    return w(this, pe).encode(t, e);
  }
  /**
   *  Encodes a ``tx.data`` object for deploying the Contract with
   *  the %%values%% as the constructor arguments.
   */
  encodeDeploy(t) {
    return this._encodeParams(this.deploy.inputs, t || []);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified error (see [[getError]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeErrorResult(t, e) {
    if (typeof t == "string") {
      const r = this.getError(t);
      T(r, "unknown error", "fragment", t), t = r;
    }
    return T(Jt(e, 0, 4) === t.selector, `data signature does not match error ${t.name}.`, "data", e), this._decodeParams(t.inputs, Jt(e, 4));
  }
  /**
   *  Encodes the transaction revert data for a call result that
   *  reverted from the the Contract with the sepcified %%error%%
   *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeErrorResult(t, e) {
    if (typeof t == "string") {
      const r = this.getError(t);
      T(r, "unknown error", "fragment", t), t = r;
    }
    return Xt([
      t.selector,
      this._encodeParams(t.inputs, e || [])
    ]);
  }
  /**
   *  Decodes the %%data%% from a transaction ``tx.data`` for
   *  the function specified (see [[getFunction]] for valid values
   *  for %%fragment%%).
   *
   *  Most developers should prefer the [[parseTransaction]] method
   *  instead, which will automatically detect the fragment.
   */
  decodeFunctionData(t, e) {
    if (typeof t == "string") {
      const r = this.getFunction(t);
      T(r, "unknown function", "fragment", t), t = r;
    }
    return T(Jt(e, 0, 4) === t.selector, `data signature does not match function ${t.name}.`, "data", e), this._decodeParams(t.inputs, Jt(e, 4));
  }
  /**
   *  Encodes the ``tx.data`` for a transaction that calls the function
   *  specified (see [[getFunction]] for valid values for %%fragment%%) with
   *  the %%values%%.
   */
  encodeFunctionData(t, e) {
    if (typeof t == "string") {
      const r = this.getFunction(t);
      T(r, "unknown function", "fragment", t), t = r;
    }
    return Xt([
      t.selector,
      this._encodeParams(t.inputs, e || [])
    ]);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeFunctionResult(t, e) {
    if (typeof t == "string") {
      const s = this.getFunction(t);
      T(s, "unknown function", "fragment", t), t = s;
    }
    let r = "invalid length for result data";
    const i = Ae(e);
    if (i.length % 32 === 0)
      try {
        return w(this, pe).decode(t.outputs, i);
      } catch {
        r = "could not decode result data";
      }
    et(!1, r, "BAD_DATA", {
      value: ut(i),
      info: { method: t.name, signature: t.format() }
    });
  }
  makeError(t, e) {
    const r = Tt(t, "data"), i = cc.getBuiltinCallException("call", e, r);
    if (i.message.startsWith("execution reverted (unknown custom error)")) {
      const c = ut(r.slice(0, 4)), _ = this.getError(c);
      if (_)
        try {
          const p = w(this, pe).decode(_.inputs, r.slice(4));
          i.revert = {
            name: _.name,
            signature: _.format(),
            args: p
          }, i.reason = i.revert.signature, i.message = `execution reverted: ${i.reason}`;
        } catch {
          i.message = "execution reverted (coult not decode custom error)";
        }
    }
    const a = this.parseTransaction(e);
    return a && (i.invocation = {
      method: a.name,
      signature: a.signature,
      args: a.args
    }), i;
  }
  /**
   *  Encodes the result data (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values
   *  for %%fragment%%) with %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeFunctionResult(t, e) {
    if (typeof t == "string") {
      const r = this.getFunction(t);
      T(r, "unknown function", "fragment", t), t = r;
    }
    return ut(w(this, pe).encode(t.outputs, e || []));
  }
  /*
      spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {
          const promises: Array<Promise<>> = [ ];
          const process = function(type: ParamType, value: any): any {
              if (type.baseType === "array") {
                  return descend(type.child
              }
              if (type. === "address") {
              }
          };
  
          const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {
              if (inputs.length !== values.length) { throw new Error("length mismatch"); }
              
          };
  
          const result: Array<any> = [ ];
          values.forEach((value, index) => {
              if (value == null) {
                  topics.push(null);
              } else if (param.baseType === "array" || param.baseType === "tuple") {
                  logger.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);
              } else if (Array.isArray(value)) {
                  topics.push(value.map((value) => encodeTopic(param, value)));
              } else {
                  topics.push(encodeTopic(param, value));
              }
          });
      }
  */
  // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  encodeFilterTopics(t, e) {
    if (typeof t == "string") {
      const s = this.getEvent(t);
      T(s, "unknown event", "eventFragment", t), t = s;
    }
    et(e.length <= t.inputs.length, `too many arguments for ${t.format()}`, "UNEXPECTED_ARGUMENT", { count: e.length, expectedCount: t.inputs.length });
    const r = [];
    t.anonymous || r.push(t.topicHash);
    const i = (s, a) => s.type === "string" ? ps(a) : s.type === "bytes" ? ee(ut(a)) : (s.type === "bool" && typeof a == "boolean" ? a = a ? "0x01" : "0x00" : s.type.match(/^u?int/) ? a = di(a) : s.type.match(/^bytes/) ? a = Cb(a, 32) : s.type === "address" && w(this, pe).encode(["address"], [a]), fs(ut(a), 32));
    for (e.forEach((s, a) => {
      const c = t.inputs[a];
      if (!c.indexed) {
        T(s == null, "cannot filter non-indexed parameters; must be null", "contract." + c.name, s);
        return;
      }
      s == null ? r.push(null) : c.baseType === "array" || c.baseType === "tuple" ? T(!1, "filtering with tuples or arrays not supported", "contract." + c.name, s) : Array.isArray(s) ? r.push(s.map((_) => i(c, _))) : r.push(i(c, s));
    }); r.length && r[r.length - 1] === null; )
      r.pop();
    return r;
  }
  encodeEventLog(t, e) {
    if (typeof t == "string") {
      const a = this.getEvent(t);
      T(a, "unknown event", "eventFragment", t), t = a;
    }
    const r = [], i = [], s = [];
    return t.anonymous || r.push(t.topicHash), T(e.length === t.inputs.length, "event arguments/values mismatch", "values", e), t.inputs.forEach((a, c) => {
      const _ = e[c];
      if (a.indexed)
        if (a.type === "string")
          r.push(ps(_));
        else if (a.type === "bytes")
          r.push(ee(_));
        else {
          if (a.baseType === "tuple" || a.baseType === "array")
            throw new Error("not implemented");
          r.push(w(this, pe).encode([a.type], [_]));
        }
      else
        i.push(a), s.push(_);
    }), {
      data: w(this, pe).encode(i, s),
      topics: r
    };
  }
  // Decode a filter for the event and the search criteria
  decodeEventLog(t, e, r) {
    if (typeof t == "string") {
      const b = this.getEvent(t);
      T(b, "unknown event", "eventFragment", t), t = b;
    }
    if (r != null && !t.anonymous) {
      const b = t.topicHash;
      T(jt(r[0], 32) && r[0].toLowerCase() === b, "fragment/topic mismatch", "topics[0]", r[0]), r = r.slice(1);
    }
    const i = [], s = [], a = [];
    t.inputs.forEach((b, v) => {
      b.indexed ? b.type === "string" || b.type === "bytes" || b.baseType === "tuple" || b.baseType === "array" ? (i.push(he.from({ type: "bytes32", name: b.name })), a.push(!0)) : (i.push(b), a.push(!1)) : (s.push(b), a.push(!1));
    });
    const c = r != null ? w(this, pe).decode(i, Xt(r)) : null, _ = w(this, pe).decode(s, e, !0), p = [], f = [];
    let d = 0, y = 0;
    return t.inputs.forEach((b, v) => {
      let R = null;
      if (b.indexed)
        if (c == null)
          R = new hp(null);
        else if (a[v])
          R = new hp(c[y++]);
        else
          try {
            R = c[y++];
          } catch (M) {
            R = M;
          }
      else
        try {
          R = _[d++];
        } catch (M) {
          R = M;
        }
      p.push(R), f.push(b.name || null);
    }), Aa.fromItems(p, f);
  }
  /**
   *  Parses a transaction, finding the matching function and extracts
   *  the parameter values along with other useful function details.
   *
   *  If the matching function cannot be found, return null.
   */
  parseTransaction(t) {
    const e = Tt(t.data, "tx.data"), r = ht(t.value != null ? t.value : 0, "tx.value"), i = this.getFunction(ut(e.slice(0, 4)));
    if (!i)
      return null;
    const s = w(this, pe).decode(i.inputs, e.slice(4));
    return new sS(i, i.selector, s, r);
  }
  parseCallResult(t) {
    throw new Error("@TODO");
  }
  /**
   *  Parses a receipt log, finding the matching event and extracts
   *  the parameter values along with other useful event details.
   *
   *  If the matching event cannot be found, returns null.
   */
  parseLog(t) {
    const e = this.getEvent(t.topics[0]);
    return !e || e.anonymous ? null : new iS(e, e.topicHash, this.decodeEventLog(e, t.data, t.topics));
  }
  /**
   *  Parses a revert data, finding the matching error and extracts
   *  the parameter values along with other useful error details.
   *
   *  If the matching error cannot be found, returns null.
   */
  parseError(t) {
    const e = ut(t), r = this.getError(Jt(e, 0, 4));
    if (!r)
      return null;
    const i = w(this, pe).decode(r.inputs, Jt(e, 4));
    return new oS(r, r.selector, i);
  }
  /**
   *  Creates a new [[Interface]] from the ABI %%value%%.
   *
   *  The %%value%% may be provided as an existing [[Interface]] object,
   *  a JSON-encoded ABI or any Human-Readable ABI format.
   */
  static from(t) {
    return t instanceof Bi ? t : typeof t == "string" ? new Bi(JSON.parse(t)) : typeof t.formatJson == "function" ? new Bi(t.formatJson()) : typeof t.format == "function" ? new Bi(t.format("json")) : new Bi(t);
  }
};
Rr = new WeakMap(), Pr = new WeakMap(), vr = new WeakMap(), pe = new WeakMap(), un = new WeakSet(), // Find a function definition by any means necessary (unless it is ambiguous)
Xc = function(t, e, r) {
  if (jt(t)) {
    const s = t.toLowerCase();
    for (const a of w(this, vr).values())
      if (s === a.selector)
        return a;
    return null;
  }
  if (t.indexOf("(") === -1) {
    const s = [];
    for (const [a, c] of w(this, vr))
      a.split(
        "("
        /* fix:) */
      )[0] === t && s.push(c);
    if (e) {
      const a = e.length > 0 ? e[e.length - 1] : null;
      let c = e.length, _ = !0;
      ge.isTyped(a) && a.type === "overrides" && (_ = !1, c--);
      for (let p = s.length - 1; p >= 0; p--) {
        const f = s[p].inputs.length;
        f !== c && (!_ || f !== c - 1) && s.splice(p, 1);
      }
      for (let p = s.length - 1; p >= 0; p--) {
        const f = s[p].inputs;
        for (let d = 0; d < e.length; d++)
          if (ge.isTyped(e[d])) {
            if (d >= f.length) {
              if (e[d].type === "overrides")
                continue;
              s.splice(p, 1);
              break;
            }
            if (e[d].type !== f[d].baseType) {
              s.splice(p, 1);
              break;
            }
          }
      }
    }
    if (s.length === 1 && e && e.length !== s[0].inputs.length) {
      const a = e[e.length - 1];
      (a == null || Array.isArray(a) || typeof a != "object") && s.splice(0, 1);
    }
    if (s.length === 0)
      return null;
    if (s.length > 1 && r) {
      const a = s.map((c) => JSON.stringify(c.format())).join(", ");
      T(!1, `ambiguous function description (i.e. matches ${a})`, "key", t);
    }
    return s[0];
  }
  const i = w(this, vr).get(_n.from(t).format());
  return i || null;
}, // Find an event definition by any means necessary (unless it is ambiguous)
t_ = function(t, e, r) {
  if (jt(t)) {
    const s = t.toLowerCase();
    for (const a of w(this, Pr).values())
      if (s === a.topicHash)
        return a;
    return null;
  }
  if (t.indexOf("(") === -1) {
    const s = [];
    for (const [a, c] of w(this, Pr))
      a.split(
        "("
        /* fix:) */
      )[0] === t && s.push(c);
    if (e) {
      for (let a = s.length - 1; a >= 0; a--)
        s[a].inputs.length < e.length && s.splice(a, 1);
      for (let a = s.length - 1; a >= 0; a--) {
        const c = s[a].inputs;
        for (let _ = 0; _ < e.length; _++)
          if (ge.isTyped(e[_]) && e[_].type !== c[_].baseType) {
            s.splice(a, 1);
            break;
          }
      }
    }
    if (s.length === 0)
      return null;
    if (s.length > 1 && r) {
      const a = s.map((c) => JSON.stringify(c.format())).join(", ");
      T(!1, `ambiguous event description (i.e. matches ${a})`, "key", t);
    }
    return s[0];
  }
  const i = w(this, Pr).get(cn.from(t).format());
  return i || null;
};
let Xu = Bi;
const P0 = BigInt(0);
function Ro(n) {
  return n ?? null;
}
function $t(n) {
  return n == null ? null : n.toString();
}
class wp {
  /**
   *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and
   *  %%maxPriorityFeePerGas%%.
   */
  constructor(t, e, r) {
    /**
     *  The gas price for legacy networks.
     */
    U(this, "gasPrice");
    /**
     *  The maximum fee to pay per gas.
     *
     *  The base fee per gas is defined by the network and based on
     *  congestion, increasing the cost during times of heavy load
     *  and lowering when less busy.
     *
     *  The actual fee per gas will be the base fee for the block
     *  and the priority fee, up to the max fee per gas.
     *
     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
     */
    U(this, "maxFeePerGas");
    /**
     *  The additional amout to pay per gas to encourage a validator
     *  to include the transaction.
     *
     *  The purpose of this is to compensate the validator for the
     *  adjusted risk for including a given transaction.
     *
     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
     */
    U(this, "maxPriorityFeePerGas");
    gt(this, {
      gasPrice: Ro(t),
      maxFeePerGas: Ro(e),
      maxPriorityFeePerGas: Ro(r)
    });
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { gasPrice: t, maxFeePerGas: e, maxPriorityFeePerGas: r } = this;
    return {
      _type: "FeeData",
      gasPrice: $t(t),
      maxFeePerGas: $t(e),
      maxPriorityFeePerGas: $t(r)
    };
  }
}
function R_(n) {
  const t = {};
  n.to && (t.to = n.to), n.from && (t.from = n.from), n.data && (t.data = ut(n.data));
  const e = "chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
  for (const i of e)
    !(i in n) || n[i] == null || (t[i] = ht(n[i], `request.${i}`));
  const r = "type,nonce".split(/,/);
  for (const i of r)
    !(i in n) || n[i] == null || (t[i] = Rt(n[i], `request.${i}`));
  return n.accessList && (t.accessList = ms(n.accessList)), "blockTag" in n && (t.blockTag = n.blockTag), "enableCcipRead" in n && (t.enableCcipRead = !!n.enableCcipRead), "customData" in n && (t.customData = n.customData), "blobVersionedHashes" in n && n.blobVersionedHashes && (t.blobVersionedHashes = n.blobVersionedHashes.slice()), "kzg" in n && (t.kzg = n.kzg), "blobs" in n && n.blobs && (t.blobs = n.blobs.map((i) => If(i) ? ut(i) : Object.assign({}, i))), t;
}
var Rn;
class aS {
  /**
   *  Create a new **Block** object.
   *
   *  This should generally not be necessary as the unless implementing a
   *  low-level library.
   */
  constructor(t, e) {
    /**
     *  The provider connected to the block used to fetch additional details
     *  if necessary.
     */
    U(this, "provider");
    /**
     *  The block number, sometimes called the block height. This is a
     *  sequential number that is one higher than the parent block.
     */
    U(this, "number");
    /**
     *  The block hash.
     *
     *  This hash includes all properties, so can be safely used to identify
     *  an exact set of block properties.
     */
    U(this, "hash");
    /**
     *  The timestamp for this block, which is the number of seconds since
     *  epoch that this block was included.
     */
    U(this, "timestamp");
    /**
     *  The block hash of the parent block.
     */
    U(this, "parentHash");
    /**
     *  The hash tree root of the parent beacon block for the given
     *  execution block. See [[link-eip-4788]].
     */
    U(this, "parentBeaconBlockRoot");
    /**
     *  The nonce.
     *
     *  On legacy networks, this is the random number inserted which
     *  permitted the difficulty target to be reached.
     */
    U(this, "nonce");
    /**
     *  The difficulty target.
     *
     *  On legacy networks, this is the proof-of-work target required
     *  for a block to meet the protocol rules to be included.
     *
     *  On modern networks, this is a random number arrived at using
     *  randao.  @TODO: Find links?
     */
    U(this, "difficulty");
    /**
     *  The total gas limit for this block.
     */
    U(this, "gasLimit");
    /**
     *  The total gas used in this block.
     */
    U(this, "gasUsed");
    /**
     *  The root hash for the global state after applying changes
     *  in this block.
     */
    U(this, "stateRoot");
    /**
     *  The hash of the transaction receipts trie.
     */
    U(this, "receiptsRoot");
    /**
     *  The total amount of blob gas consumed by the transactions
     *  within the block. See [[link-eip-4844]].
     */
    U(this, "blobGasUsed");
    /**
     *  The running total of blob gas consumed in excess of the
     *  target, prior to the block. See [[link-eip-4844]].
     */
    U(this, "excessBlobGas");
    /**
     *  The miner coinbase address, wihch receives any subsidies for
     *  including this block.
     */
    U(this, "miner");
    /**
     *  The latest RANDAO mix of the post beacon state of
     *  the previous block.
     */
    U(this, "prevRandao");
    /**
     *  Any extra data the validator wished to include.
     */
    U(this, "extraData");
    /**
     *  The base fee per gas that all transactions in this block were
     *  charged.
     *
     *  This adjusts after each block, depending on how congested the network
     *  is.
     */
    U(this, "baseFeePerGas");
    j(this, Rn);
    P(this, Rn, t.transactions.map((r) => typeof r != "string" ? new _c(r, e) : r)), gt(this, {
      provider: e,
      hash: Ro(t.hash),
      number: t.number,
      timestamp: t.timestamp,
      parentHash: t.parentHash,
      parentBeaconBlockRoot: t.parentBeaconBlockRoot,
      nonce: t.nonce,
      difficulty: t.difficulty,
      gasLimit: t.gasLimit,
      gasUsed: t.gasUsed,
      blobGasUsed: t.blobGasUsed,
      excessBlobGas: t.excessBlobGas,
      miner: t.miner,
      prevRandao: Ro(t.prevRandao),
      extraData: t.extraData,
      baseFeePerGas: Ro(t.baseFeePerGas),
      stateRoot: t.stateRoot,
      receiptsRoot: t.receiptsRoot
    });
  }
  /**
   *  Returns the list of transaction hashes, in the order
   *  they were executed within the block.
   */
  get transactions() {
    return w(this, Rn).map((t) => typeof t == "string" ? t : t.hash);
  }
  /**
   *  Returns the complete transactions, in the order they
   *  were executed within the block.
   *
   *  This is only available for blocks which prefetched
   *  transactions, by passing ``true`` to %%prefetchTxs%%
   *  into [[Provider-getBlock]].
   */
  get prefetchedTransactions() {
    const t = w(this, Rn).slice();
    return t.length === 0 ? [] : (et(typeof t[0] == "object", "transactions were not prefetched with block request", "UNSUPPORTED_OPERATION", {
      operation: "transactionResponses()"
    }), t);
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { baseFeePerGas: t, difficulty: e, extraData: r, gasLimit: i, gasUsed: s, hash: a, miner: c, prevRandao: _, nonce: p, number: f, parentHash: d, parentBeaconBlockRoot: y, stateRoot: b, receiptsRoot: v, timestamp: R, transactions: M } = this;
    return {
      _type: "Block",
      baseFeePerGas: $t(t),
      difficulty: $t(e),
      extraData: r,
      gasLimit: $t(i),
      gasUsed: $t(s),
      blobGasUsed: $t(this.blobGasUsed),
      excessBlobGas: $t(this.excessBlobGas),
      hash: a,
      miner: c,
      prevRandao: _,
      nonce: p,
      number: f,
      parentHash: d,
      timestamp: R,
      parentBeaconBlockRoot: y,
      stateRoot: b,
      receiptsRoot: v,
      transactions: M
    };
  }
  [Symbol.iterator]() {
    let t = 0;
    const e = this.transactions;
    return {
      next: () => t < this.length ? {
        value: e[t++],
        done: !1
      } : { value: void 0, done: !0 }
    };
  }
  /**
   *  The number of transactions in this block.
   */
  get length() {
    return w(this, Rn).length;
  }
  /**
   *  The [[link-js-date]] this block was included at.
   */
  get date() {
    return this.timestamp == null ? null : new Date(this.timestamp * 1e3);
  }
  /**
   *  Get the transaction at %%indexe%% within this block.
   */
  async getTransaction(t) {
    let e;
    if (typeof t == "number")
      e = w(this, Rn)[t];
    else {
      const r = t.toLowerCase();
      for (const i of w(this, Rn))
        if (typeof i == "string") {
          if (i !== r)
            continue;
          e = i;
          break;
        } else {
          if (i.hash === r)
            continue;
          e = i;
          break;
        }
    }
    if (e == null)
      throw new Error("no such tx");
    return typeof e == "string" ? await this.provider.getTransaction(e) : e;
  }
  /**
   *  If a **Block** was fetched with a request to include the transactions
   *  this will allow synchronous access to those transactions.
   *
   *  If the transactions were not prefetched, this will throw.
   */
  getPrefetchedTransaction(t) {
    const e = this.prefetchedTransactions;
    if (typeof t == "number")
      return e[t];
    t = t.toLowerCase();
    for (const r of e)
      if (r.hash === t)
        return r;
    T(!1, "no matching transaction", "indexOrHash", t);
  }
  /**
   *  Returns true if this block been mined. This provides a type guard
   *  for all properties on a [[MinedBlock]].
   */
  isMined() {
    return !!this.hash;
  }
  /**
   *  Returns true if this block is an [[link-eip-2930]] block.
   */
  isLondon() {
    return !!this.baseFeePerGas;
  }
  /**
   *  @_ignore:
   */
  orphanedEvent() {
    if (!this.isMined())
      throw new Error("");
    return cS(this);
  }
}
Rn = new WeakMap();
class Bc {
  /**
   *  @_ignore:
   */
  constructor(t, e) {
    /**
     *  The provider connected to the log used to fetch additional details
     *  if necessary.
     */
    U(this, "provider");
    /**
     *  The transaction hash of the transaction this log occurred in. Use the
     *  [[Log-getTransaction]] to get the [[TransactionResponse]].
     */
    U(this, "transactionHash");
    /**
     *  The block hash of the block this log occurred in. Use the
     *  [[Log-getBlock]] to get the [[Block]].
     */
    U(this, "blockHash");
    /**
     *  The block number of the block this log occurred in. It is preferred
     *  to use the [[Block-hash]] when fetching the related [[Block]],
     *  since in the case of an orphaned block, the block at that height may
     *  have changed.
     */
    U(this, "blockNumber");
    /**
     *  If the **Log** represents a block that was removed due to an orphaned
     *  block, this will be true.
     *
     *  This can only happen within an orphan event listener.
     */
    U(this, "removed");
    /**
     *  The address of the contract that emitted this log.
     */
    U(this, "address");
    /**
     *  The data included in this log when it was emitted.
     */
    U(this, "data");
    /**
     *  The indexed topics included in this log when it was emitted.
     *
     *  All topics are included in the bloom filters, so they can be
     *  efficiently filtered using the [[Provider-getLogs]] method.
     */
    U(this, "topics");
    /**
     *  The index within the block this log occurred at. This is generally
     *  not useful to developers, but can be used with the various roots
     *  to proof inclusion within a block.
     */
    U(this, "index");
    /**
     *  The index within the transaction of this log.
     */
    U(this, "transactionIndex");
    this.provider = e;
    const r = Object.freeze(t.topics.slice());
    gt(this, {
      transactionHash: t.transactionHash,
      blockHash: t.blockHash,
      blockNumber: t.blockNumber,
      removed: t.removed,
      address: t.address,
      data: t.data,
      topics: r,
      index: t.index,
      transactionIndex: t.transactionIndex
    });
  }
  /**
   *  Returns a JSON-compatible object.
   */
  toJSON() {
    const { address: t, blockHash: e, blockNumber: r, data: i, index: s, removed: a, topics: c, transactionHash: _, transactionIndex: p } = this;
    return {
      _type: "log",
      address: t,
      blockHash: e,
      blockNumber: r,
      data: i,
      index: s,
      removed: a,
      topics: c,
      transactionHash: _,
      transactionIndex: p
    };
  }
  /**
   *  Returns the block that this log occurred in.
   */
  async getBlock() {
    const t = await this.provider.getBlock(this.blockHash);
    return et(!!t, "failed to find transaction", "UNKNOWN_ERROR", {}), t;
  }
  /**
   *  Returns the transaction that this log occurred in.
   */
  async getTransaction() {
    const t = await this.provider.getTransaction(this.transactionHash);
    return et(!!t, "failed to find transaction", "UNKNOWN_ERROR", {}), t;
  }
  /**
   *  Returns the transaction receipt fot the transaction that this
   *  log occurred in.
   */
  async getTransactionReceipt() {
    const t = await this.provider.getTransactionReceipt(this.transactionHash);
    return et(!!t, "failed to find transaction receipt", "UNKNOWN_ERROR", {}), t;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return _S(this);
  }
}
var Ac;
class v0 {
  /**
   *  @_ignore:
   */
  constructor(t, e) {
    /**
     *  The provider connected to the log used to fetch additional details
     *  if necessary.
     */
    U(this, "provider");
    /**
     *  The address the transaction was sent to.
     */
    U(this, "to");
    /**
     *  The sender of the transaction.
     */
    U(this, "from");
    /**
     *  The address of the contract if the transaction was directly
     *  responsible for deploying one.
     *
     *  This is non-null **only** if the ``to`` is empty and the ``data``
     *  was successfully executed as initcode.
     */
    U(this, "contractAddress");
    /**
     *  The transaction hash.
     */
    U(this, "hash");
    /**
     *  The index of this transaction within the block transactions.
     */
    U(this, "index");
    /**
     *  The block hash of the [[Block]] this transaction was included in.
     */
    U(this, "blockHash");
    /**
     *  The block number of the [[Block]] this transaction was included in.
     */
    U(this, "blockNumber");
    /**
     *  The bloom filter bytes that represent all logs that occurred within
     *  this transaction. This is generally not useful for most developers,
     *  but can be used to validate the included logs.
     */
    U(this, "logsBloom");
    /**
     *  The actual amount of gas used by this transaction.
     *
     *  When creating a transaction, the amount of gas that will be used can
     *  only be approximated, but the sender must pay the gas fee for the
     *  entire gas limit. After the transaction, the difference is refunded.
     */
    U(this, "gasUsed");
    /**
     *  The gas used for BLObs. See [[link-eip-4844]].
     */
    U(this, "blobGasUsed");
    /**
     *  The amount of gas used by all transactions within the block for this
     *  and all transactions with a lower ``index``.
     *
     *  This is generally not useful for developers but can be used to
     *  validate certain aspects of execution.
     */
    U(this, "cumulativeGasUsed");
    /**
     *  The actual gas price used during execution.
     *
     *  Due to the complexity of [[link-eip-1559]] this value can only
     *  be caluclated after the transaction has been mined, snce the base
     *  fee is protocol-enforced.
     */
    U(this, "gasPrice");
    /**
     *  The price paid per BLOB in gas. See [[link-eip-4844]].
     */
    U(this, "blobGasPrice");
    /**
     *  The [[link-eip-2718]] transaction type.
     */
    U(this, "type");
    //readonly byzantium!: boolean;
    /**
     *  The status of this transaction, indicating success (i.e. ``1``) or
     *  a revert (i.e. ``0``).
     *
     *  This is available in post-byzantium blocks, but some backends may
     *  backfill this value.
     */
    U(this, "status");
    /**
     *  The root hash of this transaction.
     *
     *  This is no present and was only included in pre-byzantium blocks, but
     *  could be used to validate certain parts of the receipt.
     */
    U(this, "root");
    j(this, Ac);
    P(this, Ac, Object.freeze(t.logs.map((i) => new Bc(i, e))));
    let r = P0;
    t.effectiveGasPrice != null ? r = t.effectiveGasPrice : t.gasPrice != null && (r = t.gasPrice), gt(this, {
      provider: e,
      to: t.to,
      from: t.from,
      contractAddress: t.contractAddress,
      hash: t.hash,
      index: t.index,
      blockHash: t.blockHash,
      blockNumber: t.blockNumber,
      logsBloom: t.logsBloom,
      gasUsed: t.gasUsed,
      cumulativeGasUsed: t.cumulativeGasUsed,
      blobGasUsed: t.blobGasUsed,
      gasPrice: r,
      blobGasPrice: t.blobGasPrice,
      type: t.type,
      //byzantium: tx.byzantium,
      status: t.status,
      root: t.root
    });
  }
  /**
   *  The logs for this transaction.
   */
  get logs() {
    return w(this, Ac);
  }
  /**
   *  Returns a JSON-compatible representation.
   */
  toJSON() {
    const {
      to: t,
      from: e,
      contractAddress: r,
      hash: i,
      index: s,
      blockHash: a,
      blockNumber: c,
      logsBloom: _,
      logs: p,
      //byzantium, 
      status: f,
      root: d
    } = this;
    return {
      _type: "TransactionReceipt",
      blockHash: a,
      blockNumber: c,
      //byzantium, 
      contractAddress: r,
      cumulativeGasUsed: $t(this.cumulativeGasUsed),
      from: e,
      gasPrice: $t(this.gasPrice),
      blobGasUsed: $t(this.blobGasUsed),
      blobGasPrice: $t(this.blobGasPrice),
      gasUsed: $t(this.gasUsed),
      hash: i,
      index: s,
      logs: p,
      logsBloom: _,
      root: d,
      status: f,
      to: t
    };
  }
  /**
   *  @_ignore:
   */
  get length() {
    return this.logs.length;
  }
  [Symbol.iterator]() {
    let t = 0;
    return {
      next: () => t < this.length ? { value: this.logs[t++], done: !1 } : { value: void 0, done: !0 }
    };
  }
  /**
   *  The total fee for this transaction, in wei.
   */
  get fee() {
    return this.gasUsed * this.gasPrice;
  }
  /**
   *  Resolves to the block this transaction occurred in.
   */
  async getBlock() {
    const t = await this.provider.getBlock(this.blockHash);
    if (t == null)
      throw new Error("TODO");
    return t;
  }
  /**
   *  Resolves to the transaction this transaction occurred in.
   */
  async getTransaction() {
    const t = await this.provider.getTransaction(this.hash);
    if (t == null)
      throw new Error("TODO");
    return t;
  }
  /**
   *  Resolves to the return value of the execution of this transaction.
   *
   *  Support for this feature is limited, as it requires an archive node
   *  with the ``debug_`` or ``trace_`` API enabled.
   */
  async getResult() {
    return await this.provider.getTransactionResult(this.hash);
  }
  /**
   *  Resolves to the number of confirmations this transaction has.
   */
  async confirmations() {
    return await this.provider.getBlockNumber() - this.blockNumber + 1;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return x0(this);
  }
  /**
   *  @_ignore:
   */
  reorderedEvent(t) {
    return et(!t || t.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", { operation: "reorderedEvent(other)" }), M0(this, t);
  }
}
Ac = new WeakMap();
var ei;
const ph = class ph {
  /**
   *  @_ignore:
   */
  constructor(t, e) {
    /**
     *  The provider this is connected to, which will influence how its
     *  methods will resolve its async inspection methods.
     */
    U(this, "provider");
    /**
     *  The block number of the block that this transaction was included in.
     *
     *  This is ``null`` for pending transactions.
     */
    U(this, "blockNumber");
    /**
     *  The blockHash of the block that this transaction was included in.
     *
     *  This is ``null`` for pending transactions.
     */
    U(this, "blockHash");
    /**
     *  The index within the block that this transaction resides at.
     */
    U(this, "index");
    /**
     *  The transaction hash.
     */
    U(this, "hash");
    /**
     *  The [[link-eip-2718]] transaction envelope type. This is
     *  ``0`` for legacy transactions types.
     */
    U(this, "type");
    /**
     *  The receiver of this transaction.
     *
     *  If ``null``, then the transaction is an initcode transaction.
     *  This means the result of executing the [[data]] will be deployed
     *  as a new contract on chain (assuming it does not revert) and the
     *  address may be computed using [[getCreateAddress]].
     */
    U(this, "to");
    /**
     *  The sender of this transaction. It is implicitly computed
     *  from the transaction pre-image hash (as the digest) and the
     *  [[signature]] using ecrecover.
     */
    U(this, "from");
    /**
     *  The nonce, which is used to prevent replay attacks and offer
     *  a method to ensure transactions from a given sender are explicitly
     *  ordered.
     *
     *  When sending a transaction, this must be equal to the number of
     *  transactions ever sent by [[from]].
     */
    U(this, "nonce");
    /**
     *  The maximum units of gas this transaction can consume. If execution
     *  exceeds this, the entries transaction is reverted and the sender
     *  is charged for the full amount, despite not state changes being made.
     */
    U(this, "gasLimit");
    /**
     *  The gas price can have various values, depending on the network.
     *
     *  In modern networks, for transactions that are included this is
     *  the //effective gas price// (the fee per gas that was actually
     *  charged), while for transactions that have not been included yet
     *  is the [[maxFeePerGas]].
     *
     *  For legacy transactions, or transactions on legacy networks, this
     *  is the fee that will be charged per unit of gas the transaction
     *  consumes.
     */
    U(this, "gasPrice");
    /**
     *  The maximum priority fee (per unit of gas) to allow a
     *  validator to charge the sender. This is inclusive of the
     *  [[maxFeeFeePerGas]].
     */
    U(this, "maxPriorityFeePerGas");
    /**
     *  The maximum fee (per unit of gas) to allow this transaction
     *  to charge the sender.
     */
    U(this, "maxFeePerGas");
    /**
     *  The [[link-eip-4844]] max fee per BLOb gas.
     */
    U(this, "maxFeePerBlobGas");
    /**
     *  The data.
     */
    U(this, "data");
    /**
     *  The value, in wei. Use [[formatEther]] to format this value
     *  as ether.
     */
    U(this, "value");
    /**
     *  The chain ID.
     */
    U(this, "chainId");
    /**
     *  The signature.
     */
    U(this, "signature");
    /**
     *  The [[link-eip-2930]] access list for transaction types that
     *  support it, otherwise ``null``.
     */
    U(this, "accessList");
    /**
     *  The [[link-eip-4844]] BLOb versioned hashes.
     */
    U(this, "blobVersionedHashes");
    j(this, ei);
    this.provider = e, this.blockNumber = t.blockNumber != null ? t.blockNumber : null, this.blockHash = t.blockHash != null ? t.blockHash : null, this.hash = t.hash, this.index = t.index, this.type = t.type, this.from = t.from, this.to = t.to || null, this.gasLimit = t.gasLimit, this.nonce = t.nonce, this.data = t.data, this.value = t.value, this.gasPrice = t.gasPrice, this.maxPriorityFeePerGas = t.maxPriorityFeePerGas != null ? t.maxPriorityFeePerGas : null, this.maxFeePerGas = t.maxFeePerGas != null ? t.maxFeePerGas : null, this.maxFeePerBlobGas = t.maxFeePerBlobGas != null ? t.maxFeePerBlobGas : null, this.chainId = t.chainId, this.signature = t.signature, this.accessList = t.accessList != null ? t.accessList : null, this.blobVersionedHashes = t.blobVersionedHashes != null ? t.blobVersionedHashes : null, P(this, ei, -1);
  }
  /**
   *  Returns a JSON-compatible representation of this transaction.
   */
  toJSON() {
    const { blockNumber: t, blockHash: e, index: r, hash: i, type: s, to: a, from: c, nonce: _, data: p, signature: f, accessList: d, blobVersionedHashes: y } = this;
    return {
      _type: "TransactionResponse",
      accessList: d,
      blockNumber: t,
      blockHash: e,
      blobVersionedHashes: y,
      chainId: $t(this.chainId),
      data: p,
      from: c,
      gasLimit: $t(this.gasLimit),
      gasPrice: $t(this.gasPrice),
      hash: i,
      maxFeePerGas: $t(this.maxFeePerGas),
      maxPriorityFeePerGas: $t(this.maxPriorityFeePerGas),
      maxFeePerBlobGas: $t(this.maxFeePerBlobGas),
      nonce: _,
      signature: f,
      to: a,
      index: r,
      type: s,
      value: $t(this.value)
    };
  }
  /**
   *  Resolves to the Block that this transaction was included in.
   *
   *  This will return null if the transaction has not been included yet.
   */
  async getBlock() {
    let t = this.blockNumber;
    if (t == null) {
      const r = await this.getTransaction();
      r && (t = r.blockNumber);
    }
    if (t == null)
      return null;
    const e = this.provider.getBlock(t);
    if (e == null)
      throw new Error("TODO");
    return e;
  }
  /**
   *  Resolves to this transaction being re-requested from the
   *  provider. This can be used if you have an unmined transaction
   *  and wish to get an up-to-date populated instance.
   */
  async getTransaction() {
    return this.provider.getTransaction(this.hash);
  }
  /**
   *  Resolve to the number of confirmations this transaction has.
   */
  async confirmations() {
    if (this.blockNumber == null) {
      const { tx: e, blockNumber: r } = await be({
        tx: this.getTransaction(),
        blockNumber: this.provider.getBlockNumber()
      });
      return e == null || e.blockNumber == null ? 0 : r - e.blockNumber + 1;
    }
    return await this.provider.getBlockNumber() - this.blockNumber + 1;
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(t, e) {
    const r = t ?? 1, i = e ?? 0;
    let s = w(this, ei), a = -1, c = s === -1;
    const _ = async () => {
      if (c)
        return null;
      const { blockNumber: y, nonce: b } = await be({
        blockNumber: this.provider.getBlockNumber(),
        nonce: this.provider.getTransactionCount(this.from)
      });
      if (b < this.nonce) {
        s = y;
        return;
      }
      if (c)
        return null;
      const v = await this.getTransaction();
      if (!(v && v.blockNumber != null))
        for (a === -1 && (a = s - 3, a < w(this, ei) && (a = w(this, ei))); a <= y; ) {
          if (c)
            return null;
          const R = await this.provider.getBlock(a, !0);
          if (R == null)
            return;
          for (const M of R)
            if (M === this.hash)
              return;
          for (let M = 0; M < R.length; M++) {
            const A = await R.getTransaction(M);
            if (A.from === this.from && A.nonce === this.nonce) {
              if (c)
                return null;
              const B = await this.provider.getTransactionReceipt(A.hash);
              if (B == null || y - B.blockNumber + 1 < r)
                return;
              let N = "replaced";
              A.data === this.data && A.to === this.to && A.value === this.value ? N = "repriced" : A.data === "0x" && A.from === A.to && A.value === P0 && (N = "cancelled"), et(!1, "transaction was replaced", "TRANSACTION_REPLACED", {
                cancelled: N === "replaced" || N === "cancelled",
                reason: N,
                replacement: A.replaceableTransaction(s),
                hash: A.hash,
                receipt: B
              });
            }
          }
          a++;
        }
    }, p = (y) => {
      if (y == null || y.status !== 0)
        return y;
      et(!1, "transaction execution reverted", "CALL_EXCEPTION", {
        action: "sendTransaction",
        data: null,
        reason: null,
        invocation: null,
        revert: null,
        transaction: {
          to: y.to,
          from: y.from,
          data: ""
          // @TODO: in v7, split out sendTransaction properties
        },
        receipt: y
      });
    }, f = await this.provider.getTransactionReceipt(this.hash);
    if (r === 0)
      return p(f);
    if (f) {
      if (await f.confirmations() >= r)
        return p(f);
    } else if (await _(), r === 0)
      return null;
    return await new Promise((y, b) => {
      const v = [], R = () => {
        v.forEach((A) => A());
      };
      if (v.push(() => {
        c = !0;
      }), i > 0) {
        const A = setTimeout(() => {
          R(), b(Wt("wait for transaction timeout", "TIMEOUT"));
        }, i);
        v.push(() => {
          clearTimeout(A);
        });
      }
      const M = async (A) => {
        if (await A.confirmations() >= r) {
          R();
          try {
            y(p(A));
          } catch (B) {
            b(B);
          }
        }
      };
      if (v.push(() => {
        this.provider.off(this.hash, M);
      }), this.provider.on(this.hash, M), s >= 0) {
        const A = async () => {
          try {
            await _();
          } catch (B) {
            if (fe(B, "TRANSACTION_REPLACED")) {
              R(), b(B);
              return;
            }
          }
          c || this.provider.once("block", A);
        };
        v.push(() => {
          this.provider.off("block", A);
        }), this.provider.once("block", A);
      }
    });
  }
  /**
   *  Returns ``true`` if this transaction has been included.
   *
   *  This is effective only as of the time the TransactionResponse
   *  was instantiated. To get up-to-date information, use
   *  [[getTransaction]].
   *
   *  This provides a Type Guard that this transaction will have
   *  non-null property values for properties that are null for
   *  unmined transactions.
   */
  isMined() {
    return this.blockHash != null;
  }
  /**
   *  Returns true if the transaction is a legacy (i.e. ``type == 0``)
   *  transaction.
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)
   *  transaction. See [[link-eip-2070]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if the transaction is a London (i.e. ``type == 2``)
   *  transaction. See [[link-eip-1559]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if hte transaction is a Cancun (i.e. ``type == 3``)
   *  transaction. See [[link-eip-4844]].
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that evict this transaction.
   */
  removedEvent() {
    return et(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" }), x0(this);
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that re-order this event against %%other%%.
   */
  reorderedEvent(t) {
    return et(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" }), et(!t || t.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" }), M0(this, t);
  }
  /**
   *  Returns a new TransactionResponse instance which has the ability to
   *  detect (and throw an error) if the transaction is replaced, which
   *  will begin scanning at %%startBlock%%.
   *
   *  This should generally not be used by developers and is intended
   *  primarily for internal use. Setting an incorrect %%startBlock%% can
   *  have devastating performance consequences if used incorrectly.
   */
  replaceableTransaction(t) {
    T(Number.isInteger(t) && t >= 0, "invalid startBlock", "startBlock", t);
    const e = new ph(this, this.provider);
    return P(e, ei, t), e;
  }
};
ei = new WeakMap();
let _c = ph;
function cS(n) {
  return { orphan: "drop-block", hash: n.hash, number: n.number };
}
function M0(n, t) {
  return { orphan: "reorder-transaction", tx: n, other: t };
}
function x0(n) {
  return { orphan: "drop-transaction", tx: n };
}
function _S(n) {
  return { orphan: "drop-log", log: {
    transactionHash: n.transactionHash,
    blockHash: n.blockHash,
    blockNumber: n.blockNumber,
    address: n.address,
    data: n.data,
    topics: Object.freeze(n.topics.slice()),
    index: n.index
  } };
}
class Qf extends Bc {
  /**
   * @_ignore:
   */
  constructor(e, r, i) {
    super(e, e.provider);
    /**
     *  The Contract Interface.
     */
    U(this, "interface");
    /**
     *  The matching event.
     */
    U(this, "fragment");
    /**
     *  The parsed arguments passed to the event by ``emit``.
     */
    U(this, "args");
    const s = r.decodeEventLog(i, e.data, e.topics);
    gt(this, { args: s, fragment: i, interface: r });
  }
  /**
   *  The name of the event.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The signature of the event.
   */
  get eventSignature() {
    return this.fragment.format();
  }
}
class B0 extends Bc {
  /**
   * @_ignore:
   */
  constructor(e, r) {
    super(e, e.provider);
    /**
     *  The error encounted when trying to decode the log.
     */
    U(this, "error");
    gt(this, { error: r });
  }
}
var ia;
class lS extends v0 {
  /**
   *  @_ignore:
   */
  constructor(e, r, i) {
    super(i, r);
    j(this, ia);
    P(this, ia, e);
  }
  /**
   *  The parsed logs for any [[Log]] which has a matching event in the
   *  Contract ABI.
   */
  get logs() {
    return super.logs.map((e) => {
      const r = e.topics.length ? w(this, ia).getEvent(e.topics[0]) : null;
      if (r)
        try {
          return new Qf(e, w(this, ia), r);
        } catch (i) {
          return new B0(e, i);
        }
      return e;
    });
  }
}
ia = new WeakMap();
var mc;
class Wf extends _c {
  /**
   *  @_ignore:
   */
  constructor(e, r, i) {
    super(i, r);
    j(this, mc);
    P(this, mc, e);
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(e, r) {
    const i = await super.wait(e, r);
    return i == null ? null : new lS(w(this, mc), this.provider, i);
  }
}
mc = new WeakMap();
class C0 extends rg {
  /**
   *  @_event:
   */
  constructor(e, r, i, s) {
    super(e, r, i);
    /**
     *  The log with no matching events.
     */
    U(this, "log");
    gt(this, { log: s });
  }
  /**
   *  Resolves to the block the event occured in.
   */
  async getBlock() {
    return await this.log.getBlock();
  }
  /**
   *  Resolves to the transaction the event occured in.
   */
  async getTransaction() {
    return await this.log.getTransaction();
  }
  /**
   *  Resolves to the transaction receipt the event occured in.
   */
  async getTransactionReceipt() {
    return await this.log.getTransactionReceipt();
  }
}
class uS extends C0 {
  /**
   *  @_ignore:
   */
  constructor(t, e, r, i, s) {
    super(t, e, r, new Qf(s, t.interface, i));
    const a = t.interface.decodeEventLog(i, this.log.data, this.log.topics);
    gt(this, { args: a, fragment: i });
  }
  /**
   *  The event name.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The event signature.
   */
  get eventSignature() {
    return this.fragment.format();
  }
}
const gp = BigInt(0);
function I0(n) {
  return n && typeof n.call == "function";
}
function N0(n) {
  return n && typeof n.estimateGas == "function";
}
function X_(n) {
  return n && typeof n.resolveName == "function";
}
function O0(n) {
  return n && typeof n.sendTransaction == "function";
}
function T0(n) {
  if (n != null) {
    if (X_(n))
      return n;
    if (n.provider)
      return n.provider;
  }
}
var Sc;
class fS {
  constructor(t, e, r) {
    j(this, Sc);
    U(this, "fragment");
    if (gt(this, { fragment: e }), e.inputs.length < r.length)
      throw new Error("too many arguments");
    const i = gs(t.runner, "resolveName"), s = X_(i) ? i : null;
    P(this, Sc, async function() {
      const a = await Promise.all(e.inputs.map((c, _) => r[_] == null ? null : c.walkAsync(r[_], (f, d) => f === "address" ? Array.isArray(d) ? Promise.all(d.map((y) => Ee(y, s))) : Ee(d, s) : d)));
      return t.interface.encodeFilterTopics(e, a);
    }());
  }
  getTopicFilter() {
    return w(this, Sc);
  }
}
Sc = new WeakMap();
function gs(n, t) {
  return n == null ? null : typeof n[t] == "function" ? n : n.provider && typeof n.provider[t] == "function" ? n.provider : null;
}
function Ni(n) {
  return n == null ? null : n.provider || null;
}
async function z0(n, t) {
  const e = ge.dereference(n, "overrides");
  T(typeof e == "object", "invalid overrides parameter", "overrides", n);
  const r = R_(e);
  return T(r.to == null || (t || []).indexOf("to") >= 0, "cannot override to", "overrides.to", r.to), T(r.data == null || (t || []).indexOf("data") >= 0, "cannot override data", "overrides.data", r.data), r.from && (r.from = r.from), r;
}
async function hS(n, t, e) {
  const r = gs(n, "resolveName"), i = X_(r) ? r : null;
  return await Promise.all(t.map((s, a) => s.walkAsync(e[a], (c, _) => (_ = ge.dereference(_, c), c === "address" ? Ee(_, i) : _))));
}
function pS(n) {
  const t = async function(a) {
    const c = await z0(a, ["data"]);
    c.to = await n.getAddress(), c.from && (c.from = await Ee(c.from, T0(n.runner)));
    const _ = n.interface, p = ht(c.value || gp, "overrides.value") === gp, f = (c.data || "0x") === "0x";
    _.fallback && !_.fallback.payable && _.receive && !f && !p && T(!1, "cannot send data to receive or send value to non-payable fallback", "overrides", a), T(_.fallback || f, "cannot send data to receive-only contract", "overrides.data", c.data);
    const d = _.receive || _.fallback && _.fallback.payable;
    return T(d || p, "cannot send value to non-payable fallback", "overrides.value", c.value), T(_.fallback || f, "cannot send data to receive-only contract", "overrides.data", c.data), c;
  }, e = async function(a) {
    const c = gs(n.runner, "call");
    et(I0(c), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const _ = await t(a);
    try {
      return await c.call(_);
    } catch (p) {
      throw Cf(p) && p.data ? n.interface.makeError(p.data, _) : p;
    }
  }, r = async function(a) {
    const c = n.runner;
    et(O0(c), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const _ = await c.sendTransaction(await t(a)), p = Ni(n.runner);
    return new Wf(n.interface, p, _);
  }, i = async function(a) {
    const c = gs(n.runner, "estimateGas");
    return et(N0(c), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" }), await c.estimateGas(await t(a));
  }, s = async (a) => await r(a);
  return gt(s, {
    _contract: n,
    estimateGas: i,
    populateTransaction: t,
    send: r,
    staticCall: e
  }), s;
}
function dS(n, t) {
  const e = function(...p) {
    const f = n.interface.getFunction(t, p);
    return et(f, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key: t, args: p }
    }), f;
  }, r = async function(...p) {
    const f = e(...p);
    let d = {};
    if (f.inputs.length + 1 === p.length && (d = await z0(p.pop()), d.from && (d.from = await Ee(d.from, T0(n.runner)))), f.inputs.length !== p.length)
      throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
    const y = await hS(n.runner, f.inputs, p);
    return Object.assign({}, d, await be({
      to: n.getAddress(),
      data: n.interface.encodeFunctionData(f, y)
    }));
  }, i = async function(...p) {
    const f = await c(...p);
    return f.length === 1 ? f[0] : f;
  }, s = async function(...p) {
    const f = n.runner;
    et(O0(f), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const d = await f.sendTransaction(await r(...p)), y = Ni(n.runner);
    return new Wf(n.interface, y, d);
  }, a = async function(...p) {
    const f = gs(n.runner, "estimateGas");
    return et(N0(f), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" }), await f.estimateGas(await r(...p));
  }, c = async function(...p) {
    const f = gs(n.runner, "call");
    et(I0(f), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const d = await r(...p);
    let y = "0x";
    try {
      y = await f.call(d);
    } catch (v) {
      throw Cf(v) && v.data ? n.interface.makeError(v.data, d) : v;
    }
    const b = e(...p);
    return n.interface.decodeFunctionResult(b, y);
  }, _ = async (...p) => e(...p).constant ? await i(...p) : await s(...p);
  return gt(_, {
    name: n.interface.getFunctionName(t),
    _contract: n,
    _key: t,
    getFragment: e,
    estimateGas: a,
    populateTransaction: r,
    send: s,
    staticCall: i,
    staticCallResult: c
  }), Object.defineProperty(_, "fragment", {
    configurable: !1,
    enumerable: !0,
    get: () => {
      const p = n.interface.getFunction(t);
      return et(p, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key: t }
      }), p;
    }
  }), _;
}
function wS(n, t) {
  const e = function(...i) {
    const s = n.interface.getEvent(t, i);
    return et(s, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key: t, args: i }
    }), s;
  }, r = function(...i) {
    return new fS(n, e(...i), i);
  };
  return gt(r, {
    name: n.interface.getEventName(t),
    _contract: n,
    _key: t,
    getFragment: e
  }), Object.defineProperty(r, "fragment", {
    configurable: !1,
    enumerable: !0,
    get: () => {
      const i = n.interface.getEvent(t);
      return et(i, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key: t }
      }), i;
    }
  }), r;
}
const P_ = Symbol.for("_ethersInternal_contract"), k0 = /* @__PURE__ */ new WeakMap();
function gS(n, t) {
  k0.set(n[P_], t);
}
function Ne(n) {
  return k0.get(n[P_]);
}
function yS(n) {
  return n && typeof n == "object" && "getTopicFilter" in n && typeof n.getTopicFilter == "function" && n.fragment;
}
async function Jf(n, t) {
  let e, r = null;
  if (Array.isArray(t)) {
    const s = function(a) {
      if (jt(a, 32))
        return a;
      const c = n.interface.getEvent(a);
      return T(c, "unknown fragment", "name", a), c.topicHash;
    };
    e = t.map((a) => a == null ? null : Array.isArray(a) ? a.map(s) : s(a));
  } else t === "*" ? e = [null] : typeof t == "string" ? jt(t, 32) ? e = [t] : (r = n.interface.getEvent(t), T(r, "unknown fragment", "event", t), e = [r.topicHash]) : yS(t) ? e = await t.getTopicFilter() : "fragment" in t ? (r = t.fragment, e = [r.topicHash]) : T(!1, "unknown event name", "event", t);
  e = e.map((s) => {
    if (s == null)
      return null;
    if (Array.isArray(s)) {
      const a = Array.from(new Set(s.map((c) => c.toLowerCase())).values());
      return a.length === 1 ? a[0] : (a.sort(), a);
    }
    return s.toLowerCase();
  });
  const i = e.map((s) => s == null ? "null" : Array.isArray(s) ? s.join("|") : s).join("&");
  return { fragment: r, tag: i, topics: e };
}
async function ja(n, t) {
  const { subs: e } = Ne(n);
  return e.get((await Jf(n, t)).tag) || null;
}
async function yp(n, t, e) {
  const r = Ni(n.runner);
  et(r, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", { operation: t });
  const { fragment: i, tag: s, topics: a } = await Jf(n, e), { addr: c, subs: _ } = Ne(n);
  let p = _.get(s);
  if (!p) {
    const d = { address: c || n, topics: a }, y = (M) => {
      let A = i;
      if (A == null)
        try {
          A = n.interface.getEvent(M.topics[0]);
        } catch {
        }
      if (A) {
        const B = A, N = i ? n.interface.decodeEventLog(i, M.data, M.topics) : [];
        ef(n, e, N, (G) => new uS(n, G, e, B, M));
      } else
        ef(n, e, [], (B) => new C0(n, B, e, M));
    };
    let b = [];
    p = { tag: s, listeners: [], start: () => {
      b.length || b.push(r.on(d, y));
    }, stop: async () => {
      if (b.length == 0)
        return;
      let M = b;
      b = [], await Promise.all(M), r.off(d, y);
    } }, _.set(s, p);
  }
  return p;
}
let tf = Promise.resolve();
async function bS(n, t, e, r) {
  await tf;
  const i = await ja(n, t);
  if (!i)
    return !1;
  const s = i.listeners.length;
  return i.listeners = i.listeners.filter(({ listener: a, once: c }) => {
    const _ = Array.from(e);
    r && _.push(r(c ? null : a));
    try {
      a.call(n, ..._);
    } catch {
    }
    return !c;
  }), i.listeners.length === 0 && (i.stop(), Ne(n).subs.delete(i.tag)), s > 0;
}
async function ef(n, t, e, r) {
  try {
    await tf;
  } catch {
  }
  const i = bS(n, t, e, r);
  return tf = i, await i;
}
const Hc = ["then"];
var $w;
$w = P_;
const Xa = class Xa {
  /**
   *  Creates a new contract connected to %%target%% with the %%abi%% and
   *  optionally connected to a %%runner%% to perform operations on behalf
   *  of.
   */
  constructor(t, e, r, i) {
    /**
     *  The target to connect to.
     *
     *  This can be an address, ENS name or any [[Addressable]], such as
     *  another contract. To get the resovled address, use the ``getAddress``
     *  method.
     */
    U(this, "target");
    /**
     *  The contract Interface.
     */
    U(this, "interface");
    /**
     *  The connected runner. This is generally a [[Provider]] or a
     *  [[Signer]], which dictates what operations are supported.
     *
     *  For example, a **Contract** connected to a [[Provider]] may
     *  only execute read-only operations.
     */
    U(this, "runner");
    /**
     *  All the Events available on this contract.
     */
    U(this, "filters");
    /**
     *  @_ignore:
     */
    U(this, $w);
    /**
     *  The fallback or receive function if any.
     */
    U(this, "fallback");
    T(typeof t == "string" || Kg(t), "invalid value for Contract target", "target", t), r == null && (r = null);
    const s = Xu.from(e);
    gt(this, { target: t, runner: r, interface: s }), Object.defineProperty(this, P_, { value: {} });
    let a, c = null, _ = null;
    if (i) {
      const d = Ni(r);
      _ = new Wf(this.interface, d, i);
    }
    let p = /* @__PURE__ */ new Map();
    if (typeof t == "string")
      if (jt(t))
        c = t, a = Promise.resolve(t);
      else {
        const d = gs(r, "resolveName");
        if (!X_(d))
          throw Wt("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
            operation: "resolveName"
          });
        a = d.resolveName(t).then((y) => {
          if (y == null)
            throw Wt("an ENS name used for a contract target must be correctly configured", "UNCONFIGURED_NAME", {
              value: t
            });
          return Ne(this).addr = y, y;
        });
      }
    else
      a = t.getAddress().then((d) => {
        if (d == null)
          throw new Error("TODO");
        return Ne(this).addr = d, d;
      });
    gS(this, { addrPromise: a, addr: c, deployTx: _, subs: p });
    const f = new Proxy({}, {
      get: (d, y, b) => {
        if (typeof y == "symbol" || Hc.indexOf(y) >= 0)
          return Reflect.get(d, y, b);
        try {
          return this.getEvent(y);
        } catch (v) {
          if (!fe(v, "INVALID_ARGUMENT") || v.argument !== "key")
            throw v;
        }
      },
      has: (d, y) => Hc.indexOf(y) >= 0 ? Reflect.has(d, y) : Reflect.has(d, y) || this.interface.hasEvent(String(y))
    });
    return gt(this, { filters: f }), gt(this, {
      fallback: s.receive || s.fallback ? pS(this) : null
    }), new Proxy(this, {
      get: (d, y, b) => {
        if (typeof y == "symbol" || y in d || Hc.indexOf(y) >= 0)
          return Reflect.get(d, y, b);
        try {
          return d.getFunction(y);
        } catch (v) {
          if (!fe(v, "INVALID_ARGUMENT") || v.argument !== "key")
            throw v;
        }
      },
      has: (d, y) => typeof y == "symbol" || y in d || Hc.indexOf(y) >= 0 ? Reflect.has(d, y) : d.interface.hasFunction(y)
    });
  }
  /**
   *  Return a new Contract instance with the same target and ABI, but
   *  a different %%runner%%.
   */
  connect(t) {
    return new Xa(this.target, this.interface, t);
  }
  /**
   *  Return a new Contract instance with the same ABI and runner, but
   *  a different %%target%%.
   */
  attach(t) {
    return new Xa(t, this.interface, this.runner);
  }
  /**
   *  Return the resolved address of this Contract.
   */
  async getAddress() {
    return await Ne(this).addrPromise;
  }
  /**
   *  Return the deployed bytecode or null if no bytecode is found.
   */
  async getDeployedCode() {
    const t = Ni(this.runner);
    et(t, "runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "getDeployedCode" });
    const e = await t.getCode(await this.getAddress());
    return e === "0x" ? null : e;
  }
  /**
   *  Resolve to this Contract once the bytecode has been deployed, or
   *  resolve immediately if already deployed.
   */
  async waitForDeployment() {
    const t = this.deploymentTransaction();
    if (t)
      return await t.wait(), this;
    if (await this.getDeployedCode() != null)
      return this;
    const r = Ni(this.runner);
    return et(r != null, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "waitForDeployment" }), new Promise((i, s) => {
      const a = async () => {
        try {
          if (await this.getDeployedCode() != null)
            return i(this);
          r.once("block", a);
        } catch (c) {
          s(c);
        }
      };
      a();
    });
  }
  /**
   *  Return the transaction used to deploy this contract.
   *
   *  This is only available if this instance was returned from a
   *  [[ContractFactory]].
   */
  deploymentTransaction() {
    return Ne(this).deployTx;
  }
  /**
   *  Return the function for a given name. This is useful when a contract
   *  method name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getFunction(t) {
    return typeof t != "string" && (t = t.format()), dS(this, t);
  }
  /**
   *  Return the event for a given name. This is useful when a contract
   *  event name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getEvent(t) {
    return typeof t != "string" && (t = t.format()), wS(this, t);
  }
  /**
   *  @_ignore:
   */
  async queryTransaction(t) {
    throw new Error("@TODO");
  }
  /*
      // @TODO: this is a non-backwards compatible change, but will be added
      //        in v7 and in a potential SmartContract class in an upcoming
      //        v6 release
      async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {
          const provider = getProvider(this.runner);
          assert(provider, "contract runner does not have a provider",
              "UNSUPPORTED_OPERATION", { operation: "queryTransaction" });
  
          const receipt = await provider.getTransactionReceipt(hash);
          if (receipt == null) { return null; }
  
          return new ContractTransactionReceipt(this.interface, provider, receipt);
      }
      */
  /**
   *  Provide historic access to event data for %%event%% in the range
   *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``"latest"``)
   *  inclusive.
   */
  async queryFilter(t, e, r) {
    e == null && (e = 0), r == null && (r = "latest");
    const { addr: i, addrPromise: s } = Ne(this), a = i || await s, { fragment: c, topics: _ } = await Jf(this, t), p = { address: a, topics: _, fromBlock: e, toBlock: r }, f = Ni(this.runner);
    return et(f, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", { operation: "queryFilter" }), (await f.getLogs(p)).map((d) => {
      let y = c;
      if (y == null)
        try {
          y = this.interface.getEvent(d.topics[0]);
        } catch {
        }
      if (y)
        try {
          return new Qf(d, this.interface, y);
        } catch (b) {
          return new B0(d, b);
        }
      return new Bc(d, f);
    });
  }
  /**
   *  Add an event %%listener%% for the %%event%%.
   */
  async on(t, e) {
    const r = await yp(this, "on", t);
    return r.listeners.push({ listener: e, once: !1 }), r.start(), this;
  }
  /**
   *  Add an event %%listener%% for the %%event%%, but remove the listener
   *  after it is fired once.
   */
  async once(t, e) {
    const r = await yp(this, "once", t);
    return r.listeners.push({ listener: e, once: !0 }), r.start(), this;
  }
  /**
   *  Emit an %%event%% calling all listeners with %%args%%.
   *
   *  Resolves to ``true`` if any listeners were called.
   */
  async emit(t, ...e) {
    return await ef(this, t, e, null);
  }
  /**
   *  Resolves to the number of listeners of %%event%% or the total number
   *  of listeners if unspecified.
   */
  async listenerCount(t) {
    if (t) {
      const i = await ja(this, t);
      return i ? i.listeners.length : 0;
    }
    const { subs: e } = Ne(this);
    let r = 0;
    for (const { listeners: i } of e.values())
      r += i.length;
    return r;
  }
  /**
   *  Resolves to the listeners subscribed to %%event%% or all listeners
   *  if unspecified.
   */
  async listeners(t) {
    if (t) {
      const i = await ja(this, t);
      return i ? i.listeners.map(({ listener: s }) => s) : [];
    }
    const { subs: e } = Ne(this);
    let r = [];
    for (const { listeners: i } of e.values())
      r = r.concat(i.map(({ listener: s }) => s));
    return r;
  }
  /**
   *  Remove the %%listener%% from the listeners for %%event%% or remove
   *  all listeners if unspecified.
   */
  async off(t, e) {
    const r = await ja(this, t);
    if (!r)
      return this;
    if (e) {
      const i = r.listeners.map(({ listener: s }) => s).indexOf(e);
      i >= 0 && r.listeners.splice(i, 1);
    }
    return (e == null || r.listeners.length === 0) && (r.stop(), Ne(this).subs.delete(r.tag)), this;
  }
  /**
   *  Remove all the listeners for %%event%% or remove all listeners if
   *  unspecified.
   */
  async removeAllListeners(t) {
    if (t) {
      const e = await ja(this, t);
      if (!e)
        return this;
      e.stop(), Ne(this).subs.delete(e.tag);
    } else {
      const { subs: e } = Ne(this);
      for (const { tag: r, stop: i } of e.values())
        i(), e.delete(r);
    }
    return this;
  }
  /**
   *  Alias for [on].
   */
  async addListener(t, e) {
    return await this.on(t, e);
  }
  /**
   *  Alias for [off].
   */
  async removeListener(t, e) {
    return await this.off(t, e);
  }
  /**
   *  Create a new Class for the %%abi%%.
   */
  static buildClass(t) {
    class e extends Xa {
      constructor(i, s = null) {
        super(i, t, s);
      }
    }
    return e;
  }
  /**
   *  Create a new BaseContract with a specified Interface.
   */
  static from(t, e, r) {
    return r == null && (r = null), new this(t, e, r);
  }
};
let rf = Xa;
function AS() {
  return rf;
}
class _s extends AS() {
}
function _u(n) {
  return n.match(/^ipfs:\/\/ipfs\//i) ? n = n.substring(12) : n.match(/^ipfs:\/\//i) ? n = n.substring(7) : T(!1, "unsupported IPFS format", "link", n), `https://gateway.ipfs.io/ipfs/${n}`;
}
class mS {
  /**
   *  Creates a new **MulticoinProviderPluing** for %%name%%.
   */
  constructor(t) {
    /**
     *  The name.
     */
    U(this, "name");
    gt(this, { name: t });
  }
  connect(t) {
    return this;
  }
  /**
   *  Returns ``true`` if %%coinType%% is supported by this plugin.
   */
  supportsCoinType(t) {
    return !1;
  }
  /**
   *  Resolves to the encoded %%address%% for %%coinType%%.
   */
  async encodeAddress(t, e) {
    throw new Error("unsupported coin");
  }
  /**
   *  Resolves to the decoded %%data%% for %%coinType%%.
   */
  async decodeAddress(t, e) {
    throw new Error("unsupported coin");
  }
}
const U0 = new RegExp("^(ipfs)://(.*)$", "i"), bp = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  U0,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
var ri, Xi, ni, Os, F_, F0;
const Ao = class Ao {
  constructor(t, e, r) {
    j(this, ni);
    /**
     *  The connected provider.
     */
    U(this, "provider");
    /**
     *  The address of the resolver.
     */
    U(this, "address");
    /**
     *  The name this resolver was resolved against.
     */
    U(this, "name");
    // For EIP-2544 names, the ancestor that provided the resolver
    j(this, ri);
    j(this, Xi);
    gt(this, { provider: t, address: e, name: r }), P(this, ri, null), P(this, Xi, new _s(e, [
      "function supportsInterface(bytes4) view returns (bool)",
      "function resolve(bytes, bytes) view returns (bytes)",
      "function addr(bytes32) view returns (address)",
      "function addr(bytes32, uint) view returns (bytes)",
      "function text(bytes32, string) view returns (string)",
      "function contenthash(bytes32) view returns (bytes)"
    ], t));
  }
  /**
   *  Resolves to true if the resolver supports wildcard resolution.
   */
  async supportsWildcard() {
    return w(this, ri) == null && P(this, ri, (async () => {
      try {
        return await w(this, Xi).supportsInterface("0x9061b923");
      } catch (t) {
        if (fe(t, "CALL_EXCEPTION"))
          return !1;
        throw P(this, ri, null), t;
      }
    })()), await w(this, ri);
  }
  /**
   *  Resolves to the address for %%coinType%% or null if the
   *  provided %%coinType%% has not been configured.
   */
  async getAddress(t) {
    if (t == null && (t = 60), t === 60)
      try {
        const s = await ct(this, ni, Os).call(this, "addr(bytes32)");
        return s == null || s === ec ? null : s;
      } catch (s) {
        if (fe(s, "CALL_EXCEPTION"))
          return null;
        throw s;
      }
    if (t >= 0 && t < 2147483648) {
      let s = t + 2147483648;
      const a = await ct(this, ni, Os).call(this, "addr(bytes32,uint)", [s]);
      if (jt(a, 20))
        return zt(a);
    }
    let e = null;
    for (const s of this.provider.plugins)
      if (s instanceof mS && s.supportsCoinType(t)) {
        e = s;
        break;
      }
    if (e == null)
      return null;
    const r = await ct(this, ni, Os).call(this, "addr(bytes32,uint)", [t]);
    if (r == null || r === "0x")
      return null;
    const i = await e.decodeAddress(t, r);
    if (i != null)
      return i;
    et(!1, "invalid coin data", "UNSUPPORTED_OPERATION", {
      operation: `getAddress(${t})`,
      info: { coinType: t, data: r }
    });
  }
  /**
   *  Resolves to the EIP-634 text record for %%key%%, or ``null``
   *  if unconfigured.
   */
  async getText(t) {
    const e = await ct(this, ni, Os).call(this, "text(bytes32,string)", [t]);
    return e == null || e === "0x" ? null : e;
  }
  /**
   *  Rsolves to the content-hash or ``null`` if unconfigured.
   */
  async getContentHash() {
    const t = await ct(this, ni, Os).call(this, "contenthash(bytes32)");
    if (t == null || t === "0x")
      return null;
    const e = t.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
    if (e) {
      const i = e[1] === "e3010170" ? "ipfs" : "ipns", s = parseInt(e[4], 16);
      if (e[5].length === s * 2)
        return `${i}://${Ob("0x" + e[2])}`;
    }
    const r = t.match(/^0xe40101fa011b20([0-9a-f]*)$/);
    if (r && r[1].length === 64)
      return `bzz://${r[1]}`;
    et(!1, "invalid or unsupported content hash data", "UNSUPPORTED_OPERATION", {
      operation: "getContentHash()",
      info: { data: t }
    });
  }
  /**
   *  Resolves to the avatar url or ``null`` if the avatar is either
   *  unconfigured or incorrectly configured (e.g. references an NFT
   *  not owned by the address).
   *
   *  If diagnosing issues with configurations, the [[_getAvatar]]
   *  method may be useful.
   */
  async getAvatar() {
    return (await this._getAvatar()).url;
  }
  /**
   *  When resolving an avatar, there are many steps involved, such
   *  fetching metadata and possibly validating ownership of an
   *  NFT.
   *
   *  This method can be used to examine each step and the value it
   *  was working from.
   */
  async _getAvatar() {
    const t = [{ type: "name", value: this.name }];
    try {
      const e = await this.getText("avatar");
      if (e == null)
        return t.push({ type: "!avatar", value: "" }), { url: null, linkage: t };
      t.push({ type: "avatar", value: e });
      for (let r = 0; r < bp.length; r++) {
        const i = e.match(bp[r]);
        if (i == null)
          continue;
        const s = i[1].toLowerCase();
        switch (s) {
          case "https":
          case "data":
            return t.push({ type: "url", value: e }), { linkage: t, url: e };
          case "ipfs": {
            const a = _u(e);
            return t.push({ type: "ipfs", value: e }), t.push({ type: "url", value: a }), { linkage: t, url: a };
          }
          case "erc721":
          case "erc1155": {
            const a = s === "erc721" ? "tokenURI(uint256)" : "uri(uint256)";
            t.push({ type: s, value: e });
            const c = await this.getAddress();
            if (c == null)
              return t.push({ type: "!owner", value: "" }), { url: null, linkage: t };
            const _ = (i[2] || "").split("/");
            if (_.length !== 2)
              return t.push({ type: `!${s}caip`, value: i[2] || "" }), { url: null, linkage: t };
            const p = _[1], f = new _s(_[0], [
              // ERC-721
              "function tokenURI(uint) view returns (string)",
              "function ownerOf(uint) view returns (address)",
              // ERC-1155
              "function uri(uint) view returns (string)",
              "function balanceOf(address, uint256) view returns (uint)"
            ], this.provider);
            if (s === "erc721") {
              const R = await f.ownerOf(p);
              if (c !== R)
                return t.push({ type: "!owner", value: R }), { url: null, linkage: t };
              t.push({ type: "owner", value: R });
            } else if (s === "erc1155") {
              const R = await f.balanceOf(c, p);
              if (!R)
                return t.push({ type: "!balance", value: "0" }), { url: null, linkage: t };
              t.push({ type: "balance", value: R.toString() });
            }
            let d = await f[a](p);
            if (d == null || d === "0x")
              return t.push({ type: "!metadata-url", value: "" }), { url: null, linkage: t };
            t.push({ type: "metadata-url-base", value: d }), s === "erc1155" && (d = d.replace("{id}", di(p, 32).substring(2)), t.push({ type: "metadata-url-expanded", value: d })), d.match(/^ipfs:/i) && (d = _u(d)), t.push({ type: "metadata-url", value: d });
            let y = {};
            const b = await new kn(d).send();
            b.assertOk();
            try {
              y = b.bodyJson;
            } catch {
              try {
                t.push({ type: "!metadata", value: b.bodyText });
              } catch {
                const A = b.body;
                return A && t.push({ type: "!metadata", value: ut(A) }), { url: null, linkage: t };
              }
              return { url: null, linkage: t };
            }
            if (!y)
              return t.push({ type: "!metadata", value: "" }), { url: null, linkage: t };
            t.push({ type: "metadata", value: JSON.stringify(y) });
            let v = y.image;
            if (typeof v != "string")
              return t.push({ type: "!imageUrl", value: "" }), { url: null, linkage: t };
            if (!v.match(/^(https:\/\/|data:)/i)) {
              if (v.match(U0) == null)
                return t.push({ type: "!imageUrl-ipfs", value: v }), { url: null, linkage: t };
              t.push({ type: "imageUrl-ipfs", value: v }), v = _u(v);
            }
            return t.push({ type: "url", value: v }), { linkage: t, url: v };
          }
        }
      }
    } catch {
    }
    return { linkage: t, url: null };
  }
  static async getEnsAddress(t) {
    const e = await t.getNetwork(), r = e.getPlugin("org.ethers.plugins.network.Ens");
    return et(r, "network does not support ENS", "UNSUPPORTED_OPERATION", {
      operation: "getEnsAddress",
      info: { network: e }
    }), r.address;
  }
  /**
   *  Resolve to the ENS resolver for %%name%% using %%provider%% or
   *  ``null`` if unconfigured.
   */
  static async fromName(t, e) {
    var i;
    let r = e;
    for (; ; ) {
      if (r === "" || r === "." || e !== "eth" && r === "eth")
        return null;
      const s = await ct(i = Ao, F_, F0).call(i, t, r);
      if (s != null) {
        const a = new Ao(t, s, e);
        return r !== e && !await a.supportsWildcard() ? null : a;
      }
      r = r.split(".").slice(1).join(".");
    }
  }
};
ri = new WeakMap(), Xi = new WeakMap(), ni = new WeakSet(), Os = async function(t, e) {
  e = (e || []).slice();
  const r = w(this, Xi).interface;
  e.unshift(qu(this.name));
  let i = null;
  await this.supportsWildcard() && (i = r.getFunction(t), et(i, "missing fragment", "UNKNOWN_ERROR", {
    info: { funcName: t }
  }), e = [
    Am(this.name, 255),
    r.encodeFunctionData(i, e)
  ], t = "resolve(bytes,bytes)"), e.push({
    enableCcipRead: !0
  });
  try {
    const s = await w(this, Xi)[t](...e);
    return i ? r.decodeFunctionResult(i, s)[0] : s;
  } catch (s) {
    if (!fe(s, "CALL_EXCEPTION"))
      throw s;
  }
  return null;
}, F_ = new WeakSet(), F0 = async function(t, e) {
  const r = await Ao.getEnsAddress(t);
  try {
    const s = await new _s(r, [
      "function resolver(bytes32) view returns (address)"
    ], t).resolver(qu(e), {
      enableCcipRead: !0
    });
    return s === ec ? null : s;
  } catch (i) {
    throw i;
  }
  return null;
}, j(Ao, F_);
let v_ = Ao;
const Ap = BigInt(0);
function Ot(n, t) {
  return function(e) {
    return e == null ? t : n(e);
  };
}
function tl(n, t) {
  return (e) => {
    if (t && e == null)
      return null;
    if (!Array.isArray(e))
      throw new Error("not an array");
    return e.map((r) => n(r));
  };
}
function Cc(n, t) {
  return (e) => {
    const r = {};
    for (const i in n) {
      let s = i;
      if (t && i in t && !(s in e)) {
        for (const a of t[i])
          if (a in e) {
            s = a;
            break;
          }
      }
      try {
        const a = n[i](e[s]);
        a !== void 0 && (r[i] = a);
      } catch (a) {
        const c = a instanceof Error ? a.message : "not-an-error";
        et(!1, `invalid value for value.${i} (${c})`, "BAD_DATA", { value: e });
      }
    }
    return r;
  };
}
function SS(n) {
  switch (n) {
    case !0:
    case "true":
      return !0;
    case !1:
    case "false":
      return !1;
  }
  T(!1, `invalid boolean; ${JSON.stringify(n)}`, "value", n);
}
function Ma(n) {
  return T(jt(n, !0), "invalid data", "value", n), n;
}
function ue(n) {
  return T(jt(n, 32), "invalid hash", "value", n), n;
}
const ES = Cc({
  address: zt,
  blockHash: ue,
  blockNumber: Rt,
  data: Ma,
  index: Rt,
  removed: Ot(SS, !1),
  topics: tl(ue),
  transactionHash: ue,
  transactionIndex: Rt
}, {
  index: ["logIndex"]
});
function RS(n) {
  return ES(n);
}
const PS = Cc({
  hash: Ot(ue),
  parentHash: ue,
  parentBeaconBlockRoot: Ot(ue, null),
  number: Rt,
  timestamp: Rt,
  nonce: Ot(Ma),
  difficulty: ht,
  gasLimit: ht,
  gasUsed: ht,
  stateRoot: Ot(ue, null),
  receiptsRoot: Ot(ue, null),
  blobGasUsed: Ot(ht, null),
  excessBlobGas: Ot(ht, null),
  miner: Ot(zt),
  prevRandao: Ot(ue, null),
  extraData: Ma,
  baseFeePerGas: Ot(ht)
}, {
  prevRandao: ["mixHash"]
});
function vS(n) {
  const t = PS(n);
  return t.transactions = n.transactions.map((e) => typeof e == "string" ? e : G0(e)), t;
}
const MS = Cc({
  transactionIndex: Rt,
  blockNumber: Rt,
  transactionHash: ue,
  address: zt,
  topics: tl(ue),
  data: Ma,
  index: Rt,
  blockHash: ue
}, {
  index: ["logIndex"]
});
function xS(n) {
  return MS(n);
}
const BS = Cc({
  to: Ot(zt, null),
  from: Ot(zt, null),
  contractAddress: Ot(zt, null),
  // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
  index: Rt,
  root: Ot(ut),
  gasUsed: ht,
  blobGasUsed: Ot(ht, null),
  logsBloom: Ot(Ma),
  blockHash: ue,
  hash: ue,
  logs: tl(xS),
  blockNumber: Rt,
  //confirmations: allowNull(getNumber, null),
  cumulativeGasUsed: ht,
  effectiveGasPrice: Ot(ht),
  blobGasPrice: Ot(ht, null),
  status: Ot(Rt),
  type: Ot(Rt, 0)
}, {
  effectiveGasPrice: ["gasPrice"],
  hash: ["transactionHash"],
  index: ["transactionIndex"]
});
function CS(n) {
  return BS(n);
}
function G0(n) {
  n.to && ht(n.to) === Ap && (n.to = "0x0000000000000000000000000000000000000000");
  const t = Cc({
    hash: ue,
    // Some nodes do not return this, usually test nodes (like Ganache)
    index: Ot(Rt, void 0),
    type: (e) => e === "0x" || e == null ? 0 : Rt(e),
    accessList: Ot(ms, null),
    blobVersionedHashes: Ot(tl(ue, !0), null),
    blockHash: Ot(ue, null),
    blockNumber: Ot(Rt, null),
    transactionIndex: Ot(Rt, null),
    from: zt,
    // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas) must be set
    gasPrice: Ot(ht),
    maxPriorityFeePerGas: Ot(ht),
    maxFeePerGas: Ot(ht),
    maxFeePerBlobGas: Ot(ht, null),
    gasLimit: ht,
    to: Ot(zt, null),
    value: ht,
    nonce: Rt,
    data: Ma,
    creates: Ot(zt, null),
    chainId: Ot(ht, null)
  }, {
    data: ["input"],
    gasLimit: ["gas"],
    index: ["transactionIndex"]
  })(n);
  if (t.to == null && t.creates == null && (t.creates = EA(t)), (n.type === 1 || n.type === 2) && n.accessList == null && (t.accessList = []), n.signature ? t.signature = ur.from(n.signature) : t.signature = ur.from(n), t.chainId == null) {
    const e = t.signature.legacyChainId;
    e != null && (t.chainId = e);
  }
  return t.blockHash && ht(t.blockHash) === Ap && (t.blockHash = null), t;
}
const IS = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
class Ic {
  /**
   *  Creates a new **NetworkPlugin**.
   */
  constructor(t) {
    /**
     *  The name of the plugin.
     *
     *  It is recommended to use reverse-domain-notation, which permits
     *  unique names with a known authority as well as hierarchal entries.
     */
    U(this, "name");
    gt(this, { name: t });
  }
  /**
   *  Creates a copy of this plugin.
   */
  clone() {
    return new Ic(this.name);
  }
}
class el extends Ic {
  /**
   *  Creates a new GasCostPlugin from %%effectiveBlock%% until the
   *  latest block or another GasCostPlugin supercedes that block number,
   *  with the associated %%costs%%.
   */
  constructor(e, r) {
    e == null && (e = 0);
    super(`org.ethers.network.plugins.GasCost#${e || 0}`);
    /**
     *  The block number to treat these values as valid from.
     *
     *  This allows a hardfork to have updated values included as well as
     *  mulutiple hardforks to be supported.
     */
    U(this, "effectiveBlock");
    /**
     *  The transactions base fee.
     */
    U(this, "txBase");
    /**
     *  The fee for creating a new account.
     */
    U(this, "txCreate");
    /**
     *  The fee per zero-byte in the data.
     */
    U(this, "txDataZero");
    /**
     *  The fee per non-zero-byte in the data.
     */
    U(this, "txDataNonzero");
    /**
     *  The fee per storage key in the [[link-eip-2930]] access list.
     */
    U(this, "txAccessListStorageKey");
    /**
     *  The fee per address in the [[link-eip-2930]] access list.
     */
    U(this, "txAccessListAddress");
    const i = { effectiveBlock: e };
    function s(a, c) {
      let _ = (r || {})[a];
      _ == null && (_ = c), T(typeof _ == "number", `invalud value for ${a}`, "costs", r), i[a] = _;
    }
    s("txBase", 21e3), s("txCreate", 32e3), s("txDataZero", 4), s("txDataNonzero", 16), s("txAccessListStorageKey", 1900), s("txAccessListAddress", 2400), gt(this, i);
  }
  clone() {
    return new el(this.effectiveBlock, this);
  }
}
class rl extends Ic {
  /**
   *  Creates a new **EnsPlugin** connected to %%address%% on the
   *  %%targetNetwork%%. The default ENS address and mainnet is used
   *  if unspecified.
   */
  constructor(e, r) {
    super("org.ethers.plugins.network.Ens");
    /**
     *  The ENS Registrty Contract address.
     */
    U(this, "address");
    /**
     *  The chain ID that the ENS contract lives on.
     */
    U(this, "targetNetwork");
    gt(this, {
      address: e || IS,
      targetNetwork: r ?? 1
    });
  }
  clone() {
    return new rl(this.address, this.targetNetwork);
  }
}
var Ec, Rc;
class NS extends Ic {
  /**
   *  Creates a new **FetchUrlFeeDataNetworkPlugin** which will
   *  be used when computing the fee data for the network.
   */
  constructor(e, r) {
    super("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    j(this, Ec);
    j(this, Rc);
    P(this, Ec, e), P(this, Rc, r);
  }
  /**
   *  The URL to initialize the FetchRequest with in %%processFunc%%.
   */
  get url() {
    return w(this, Ec);
  }
  /**
   *  The callback to use when computing the FeeData.
   */
  get processFunc() {
    return w(this, Rc);
  }
  // We are immutable, so we can serve as our own clone
  clone() {
    return this;
  }
}
Ec = new WeakMap(), Rc = new WeakMap();
const lu = /* @__PURE__ */ new Map();
var sa, oa, ii;
const mo = class mo {
  /**
   *  Creates a new **Network** for %%name%% and %%chainId%%.
   */
  constructor(t, e) {
    j(this, sa);
    j(this, oa);
    j(this, ii);
    P(this, sa, t), P(this, oa, ht(e)), P(this, ii, /* @__PURE__ */ new Map());
  }
  /**
   *  Returns a JSON-compatible representation of a Network.
   */
  toJSON() {
    return { name: this.name, chainId: String(this.chainId) };
  }
  /**
   *  The network common name.
   *
   *  This is the canonical name, as networks migh have multiple
   *  names.
   */
  get name() {
    return w(this, sa);
  }
  set name(t) {
    P(this, sa, t);
  }
  /**
   *  The network chain ID.
   */
  get chainId() {
    return w(this, oa);
  }
  set chainId(t) {
    P(this, oa, ht(t, "chainId"));
  }
  /**
   *  Returns true if %%other%% matches this network. Any chain ID
   *  must match, and if no chain ID is present, the name must match.
   *
   *  This method does not currently check for additional properties,
   *  such as ENS address or plug-in compatibility.
   */
  matches(t) {
    if (t == null)
      return !1;
    if (typeof t == "string") {
      try {
        return this.chainId === ht(t);
      } catch {
      }
      return this.name === t;
    }
    if (typeof t == "number" || typeof t == "bigint") {
      try {
        return this.chainId === ht(t);
      } catch {
      }
      return !1;
    }
    if (typeof t == "object") {
      if (t.chainId != null) {
        try {
          return this.chainId === ht(t.chainId);
        } catch {
        }
        return !1;
      }
      return t.name != null ? this.name === t.name : !1;
    }
    return !1;
  }
  /**
   *  Returns the list of plugins currently attached to this Network.
   */
  get plugins() {
    return Array.from(w(this, ii).values());
  }
  /**
   *  Attach a new %%plugin%% to this Network. The network name
   *  must be unique, excluding any fragment.
   */
  attachPlugin(t) {
    if (w(this, ii).get(t.name))
      throw new Error(`cannot replace existing plugin: ${t.name} `);
    return w(this, ii).set(t.name, t.clone()), this;
  }
  /**
   *  Return the plugin, if any, matching %%name%% exactly. Plugins
   *  with fragments will not be returned unless %%name%% includes
   *  a fragment.
   */
  getPlugin(t) {
    return w(this, ii).get(t) || null;
  }
  /**
   *  Gets a list of all plugins that match %%name%%, with otr without
   *  a fragment.
   */
  getPlugins(t) {
    return this.plugins.filter((e) => e.name.split("#")[0] === t);
  }
  /**
   *  Create a copy of this Network.
   */
  clone() {
    const t = new mo(this.name, this.chainId);
    return this.plugins.forEach((e) => {
      t.attachPlugin(e.clone());
    }), t;
  }
  /**
   *  Compute the intrinsic gas required for a transaction.
   *
   *  A GasCostPlugin can be attached to override the default
   *  values.
   */
  computeIntrinsicGas(t) {
    const e = this.getPlugin("org.ethers.plugins.network.GasCost") || new el();
    let r = e.txBase;
    if (t.to == null && (r += e.txCreate), t.data)
      for (let i = 2; i < t.data.length; i += 2)
        t.data.substring(i, i + 2) === "00" ? r += e.txDataZero : r += e.txDataNonzero;
    if (t.accessList) {
      const i = ms(t.accessList);
      for (const s in i)
        r += e.txAccessListAddress + e.txAccessListStorageKey * i[s].storageKeys.length;
    }
    return r;
  }
  /**
   *  Returns a new Network for the %%network%% name or chainId.
   */
  static from(t) {
    if (OS(), t == null)
      return mo.from("mainnet");
    if (typeof t == "number" && (t = BigInt(t)), typeof t == "string" || typeof t == "bigint") {
      const e = lu.get(t);
      if (e)
        return e();
      if (typeof t == "bigint")
        return new mo("unknown", t);
      T(!1, "unknown network", "network", t);
    }
    if (typeof t.clone == "function")
      return t.clone();
    if (typeof t == "object") {
      T(typeof t.name == "string" && typeof t.chainId == "number", "invalid network object name or chainId", "network", t);
      const e = new mo(t.name, t.chainId);
      return (t.ensAddress || t.ensNetwork != null) && e.attachPlugin(new rl(t.ensAddress, t.ensNetwork)), e;
    }
    T(!1, "invalid network", "network", t);
  }
  /**
   *  Register %%nameOrChainId%% with a function which returns
   *  an instance of a Network representing that chain.
   */
  static register(t, e) {
    typeof t == "number" && (t = BigInt(t));
    const r = lu.get(t);
    r && T(!1, `conflicting network for ${JSON.stringify(r.name)}`, "nameOrChainId", t), lu.set(t, e);
  }
};
sa = new WeakMap(), oa = new WeakMap(), ii = new WeakMap();
let ln = mo;
function mp(n, t) {
  const e = String(n);
  if (!e.match(/^[0-9.]+$/))
    throw new Error(`invalid gwei value: ${n}`);
  const r = e.split(".");
  if (r.length === 1 && r.push(""), r.length !== 2)
    throw new Error(`invalid gwei value: ${n}`);
  for (; r[1].length < t; )
    r[1] += "0";
  if (r[1].length > 9) {
    let i = BigInt(r[1].substring(0, 9));
    r[1].substring(9).match(/^0+$/) || i++, r[1] = i.toString();
  }
  return BigInt(r[0] + r[1]);
}
function Sp(n) {
  return new NS(n, async (t, e, r) => {
    r.setHeader("User-Agent", "ethers");
    let i;
    try {
      const [s, a] = await Promise.all([
        r.send(),
        t()
      ]);
      i = s;
      const c = i.bodyJson.standard;
      return {
        gasPrice: a.gasPrice,
        maxFeePerGas: mp(c.maxFee, 9),
        maxPriorityFeePerGas: mp(c.maxPriorityFee, 9)
      };
    } catch (s) {
      et(!1, `error encountered with polygon gas station (${JSON.stringify(r.url)})`, "SERVER_ERROR", { request: r, response: i, error: s });
    }
  });
}
let Ep = !1;
function OS() {
  if (Ep)
    return;
  Ep = !0;
  function n(t, e, r) {
    const i = function() {
      const s = new ln(t, e);
      return r.ensNetwork != null && s.attachPlugin(new rl(null, r.ensNetwork)), s.attachPlugin(new el()), (r.plugins || []).forEach((a) => {
        s.attachPlugin(a);
      }), s;
    };
    ln.register(t, i), ln.register(e, i), r.altNames && r.altNames.forEach((s) => {
      ln.register(s, i);
    });
  }
  n("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] }), n("ropsten", 3, { ensNetwork: 3 }), n("rinkeby", 4, { ensNetwork: 4 }), n("goerli", 5, { ensNetwork: 5 }), n("kovan", 42, { ensNetwork: 42 }), n("sepolia", 11155111, { ensNetwork: 11155111 }), n("holesky", 17e3, { ensNetwork: 17e3 }), n("classic", 61, {}), n("classicKotti", 6, {}), n("arbitrum", 42161, {
    ensNetwork: 1
  }), n("arbitrum-goerli", 421613, {}), n("arbitrum-sepolia", 421614, {}), n("base", 8453, { ensNetwork: 1 }), n("base-goerli", 84531, {}), n("base-sepolia", 84532, {}), n("bnb", 56, { ensNetwork: 1 }), n("bnbt", 97, {}), n("linea", 59144, { ensNetwork: 1 }), n("linea-goerli", 59140, {}), n("linea-sepolia", 59141, {}), n("matic", 137, {
    ensNetwork: 1,
    plugins: [
      Sp("https://gasstation.polygon.technology/v2")
    ]
  }), n("matic-amoy", 80002, {}), n("matic-mumbai", 80001, {
    altNames: ["maticMumbai", "maticmum"],
    plugins: [
      Sp("https://gasstation-testnet.polygon.technology/v2")
    ]
  }), n("optimism", 10, {
    ensNetwork: 1,
    plugins: []
  }), n("optimism-goerli", 420, {}), n("optimism-sepolia", 11155420, {}), n("xdai", 100, { ensNetwork: 1 });
}
function nf(n) {
  return JSON.parse(JSON.stringify(n));
}
var Pn, Ye, si, Mr, aa, e_;
class TS {
  /**
   *  Create a new **PollingBlockSubscriber** attached to %%provider%%.
   */
  constructor(t) {
    j(this, aa);
    j(this, Pn);
    j(this, Ye);
    j(this, si);
    // The most recent block we have scanned for events. The value -2
    // indicates we still need to fetch an initial block number
    j(this, Mr);
    P(this, Pn, t), P(this, Ye, null), P(this, si, 4e3), P(this, Mr, -2);
  }
  /**
   *  The polling interval.
   */
  get pollingInterval() {
    return w(this, si);
  }
  set pollingInterval(t) {
    P(this, si, t);
  }
  start() {
    w(this, Ye) || (P(this, Ye, w(this, Pn)._setTimeout(ct(this, aa, e_).bind(this), w(this, si))), ct(this, aa, e_).call(this));
  }
  stop() {
    w(this, Ye) && (w(this, Pn)._clearTimeout(w(this, Ye)), P(this, Ye, null));
  }
  pause(t) {
    this.stop(), t && P(this, Mr, -2);
  }
  resume() {
    this.start();
  }
}
Pn = new WeakMap(), Ye = new WeakMap(), si = new WeakMap(), Mr = new WeakMap(), aa = new WeakSet(), e_ = async function() {
  try {
    const t = await w(this, Pn).getBlockNumber();
    if (w(this, Mr) === -2) {
      P(this, Mr, t);
      return;
    }
    if (t !== w(this, Mr)) {
      for (let e = w(this, Mr) + 1; e <= t; e++) {
        if (w(this, Ye) == null)
          return;
        await w(this, Pn).emit("block", e);
      }
      P(this, Mr, t);
    }
  } catch {
  }
  w(this, Ye) != null && P(this, Ye, w(this, Pn)._setTimeout(ct(this, aa, e_).bind(this), w(this, si)));
};
var ts, es, oi;
class $f {
  /**
   *  Create a new **OnBlockSubscriber** attached to %%provider%%.
   */
  constructor(t) {
    j(this, ts);
    j(this, es);
    j(this, oi);
    P(this, ts, t), P(this, oi, !1), P(this, es, (e) => {
      this._poll(e, w(this, ts));
    });
  }
  /**
   *  Called on every new block.
   */
  async _poll(t, e) {
    throw new Error("sub-classes must override this");
  }
  start() {
    w(this, oi) || (P(this, oi, !0), w(this, es).call(this, -2), w(this, ts).on("block", w(this, es)));
  }
  stop() {
    w(this, oi) && (P(this, oi, !1), w(this, ts).off("block", w(this, es)));
  }
  pause(t) {
    this.stop();
  }
  resume() {
    this.start();
  }
}
ts = new WeakMap(), es = new WeakMap(), oi = new WeakMap();
var ca, vn;
class zS extends $f {
  constructor(e, r) {
    super(e);
    j(this, ca);
    j(this, vn);
    P(this, ca, r), P(this, vn, -2);
  }
  pause(e) {
    e && P(this, vn, -2), super.pause(e);
  }
  async _poll(e, r) {
    const i = await r.getBlock(w(this, ca));
    i != null && (w(this, vn) === -2 ? P(this, vn, i.number) : i.number > w(this, vn) && (r.emit(w(this, ca), i.number), P(this, vn, i.number)));
  }
}
ca = new WeakMap(), vn = new WeakMap();
var G_;
class kS extends $f {
  constructor(e, r) {
    super(e);
    j(this, G_);
    P(this, G_, nf(r));
  }
  async _poll(e, r) {
    throw new Error("@TODO");
  }
}
G_ = new WeakMap();
var _a;
class US extends $f {
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%hash%%.
   */
  constructor(e, r) {
    super(e);
    j(this, _a);
    P(this, _a, r);
  }
  async _poll(e, r) {
    const i = await r.getTransactionReceipt(w(this, _a));
    i && r.emit(w(this, _a), i);
  }
}
_a = new WeakMap();
var Mn, la, ua, ai, Qe, L_, L0;
class qf {
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%filter%%.
   */
  constructor(t, e) {
    j(this, L_);
    j(this, Mn);
    j(this, la);
    j(this, ua);
    j(this, ai);
    // The most recent block we have scanned for events. The value -2
    // indicates we still need to fetch an initial block number
    j(this, Qe);
    P(this, Mn, t), P(this, la, nf(e)), P(this, ua, ct(this, L_, L0).bind(this)), P(this, ai, !1), P(this, Qe, -2);
  }
  start() {
    w(this, ai) || (P(this, ai, !0), w(this, Qe) === -2 && w(this, Mn).getBlockNumber().then((t) => {
      P(this, Qe, t);
    }), w(this, Mn).on("block", w(this, ua)));
  }
  stop() {
    w(this, ai) && (P(this, ai, !1), w(this, Mn).off("block", w(this, ua)));
  }
  pause(t) {
    this.stop(), t && P(this, Qe, -2);
  }
  resume() {
    this.start();
  }
}
Mn = new WeakMap(), la = new WeakMap(), ua = new WeakMap(), ai = new WeakMap(), Qe = new WeakMap(), L_ = new WeakSet(), L0 = async function(t) {
  if (w(this, Qe) === -2)
    return;
  const e = nf(w(this, la));
  e.fromBlock = w(this, Qe) + 1, e.toBlock = t;
  const r = await w(this, Mn).getLogs(e);
  if (r.length === 0) {
    w(this, Qe) < t - 60 && P(this, Qe, t - 60);
    return;
  }
  for (const i of r)
    w(this, Mn).emit(w(this, la), i), P(this, Qe, i.blockNumber);
};
const FS = BigInt(2), GS = 10;
function Yc(n) {
  return n && typeof n.then == "function";
}
function r_(n, t) {
  return n + ":" + JSON.stringify(t, (e, r) => {
    if (r == null)
      return "null";
    if (typeof r == "bigint")
      return `bigint:${r.toString()}`;
    if (typeof r == "string")
      return r.toLowerCase();
    if (typeof r == "object" && !Array.isArray(r)) {
      const i = Object.keys(r);
      return i.sort(), i.reduce((s, a) => (s[a] = r[a], s), {});
    }
    return r;
  });
}
class D0 {
  /**
   *  Create a new UnmanagedSubscriber with %%name%%.
   */
  constructor(t) {
    /**
     *  The name fof the event.
     */
    U(this, "name");
    gt(this, { name: t });
  }
  start() {
  }
  stop() {
  }
  pause(t) {
  }
  resume() {
  }
}
function LS(n) {
  return JSON.parse(JSON.stringify(n));
}
function sf(n) {
  return n = Array.from(new Set(n).values()), n.sort(), n;
}
async function uu(n, t) {
  if (n == null)
    throw new Error("invalid event");
  if (Array.isArray(n) && (n = { topics: n }), typeof n == "string")
    switch (n) {
      case "block":
      case "debug":
      case "error":
      case "finalized":
      case "network":
      case "pending":
      case "safe":
        return { type: n, tag: n };
    }
  if (jt(n, 32)) {
    const e = n.toLowerCase();
    return { type: "transaction", tag: r_("tx", { hash: e }), hash: e };
  }
  if (n.orphan) {
    const e = n;
    return { type: "orphan", tag: r_("orphan", e), filter: LS(e) };
  }
  if (n.address || n.topics) {
    const e = n, r = {
      topics: (e.topics || []).map((i) => i == null ? null : Array.isArray(i) ? sf(i.map((s) => s.toLowerCase())) : i.toLowerCase())
    };
    if (e.address) {
      const i = [], s = [], a = (c) => {
        jt(c) ? i.push(c) : s.push((async () => {
          i.push(await Ee(c, t));
        })());
      };
      Array.isArray(e.address) ? e.address.forEach(a) : a(e.address), s.length && await Promise.all(s), r.address = sf(i.map((c) => c.toLowerCase()));
    }
    return { filter: r, tag: r_("event", r), type: "event" };
  }
  T(!1, "unknown ProviderEvent", "event", n);
}
function fu() {
  return (/* @__PURE__ */ new Date()).getTime();
}
const DS = {
  cacheTimeout: 250,
  pollingInterval: 4e3
};
var de, ci, we, fa, Ue, rs, _i, xn, Pc, We, ha, pa, Et, Ie, of, af, Ha, cf, Ya, n_;
class KS {
  /**
   *  Create a new **AbstractProvider** connected to %%network%%, or
   *  use the various network detection capabilities to discover the
   *  [[Network]] if necessary.
   */
  constructor(t, e) {
    j(this, Et);
    j(this, de);
    j(this, ci);
    // null=unpaused, true=paused+dropWhilePaused, false=paused
    j(this, we);
    j(this, fa);
    j(this, Ue);
    j(this, rs);
    j(this, _i);
    // The most recent block number if running an event or -1 if no "block" event
    j(this, xn);
    j(this, Pc);
    j(this, We);
    j(this, ha);
    j(this, pa);
    if (P(this, pa, Object.assign({}, DS, e || {})), t === "any")
      P(this, rs, !0), P(this, Ue, null);
    else if (t) {
      const r = ln.from(t);
      P(this, rs, !1), P(this, Ue, Promise.resolve(r)), setTimeout(() => {
        this.emit("network", r, null);
      }, 0);
    } else
      P(this, rs, !1), P(this, Ue, null);
    P(this, xn, -1), P(this, _i, /* @__PURE__ */ new Map()), P(this, de, /* @__PURE__ */ new Map()), P(this, ci, /* @__PURE__ */ new Map()), P(this, we, null), P(this, fa, !1), P(this, Pc, 1), P(this, We, /* @__PURE__ */ new Map()), P(this, ha, !1);
  }
  get pollingInterval() {
    return w(this, pa).pollingInterval;
  }
  /**
   *  Returns ``this``, to allow an **AbstractProvider** to implement
   *  the [[ContractRunner]] interface.
   */
  get provider() {
    return this;
  }
  /**
   *  Returns all the registered plug-ins.
   */
  get plugins() {
    return Array.from(w(this, ci).values());
  }
  /**
   *  Attach a new plug-in.
   */
  attachPlugin(t) {
    if (w(this, ci).get(t.name))
      throw new Error(`cannot replace existing plugin: ${t.name} `);
    return w(this, ci).set(t.name, t.connect(this)), this;
  }
  /**
   *  Get a plugin by name.
   */
  getPlugin(t) {
    return w(this, ci).get(t) || null;
  }
  /**
   *  Prevent any CCIP-read operation, regardless of whether requested
   *  in a [[call]] using ``enableCcipRead``.
   */
  get disableCcipRead() {
    return w(this, ha);
  }
  set disableCcipRead(t) {
    P(this, ha, !!t);
  }
  /**
   *  Resolves to the data for executing the CCIP-read operations.
   */
  async ccipReadFetch(t, e, r) {
    if (this.disableCcipRead || r.length === 0 || t.to == null)
      return null;
    const i = t.to.toLowerCase(), s = e.toLowerCase(), a = [];
    for (let c = 0; c < r.length; c++) {
      const _ = r[c], p = _.replace("{sender}", i).replace("{data}", s), f = new kn(p);
      _.indexOf("{data}") === -1 && (f.body = { data: s, sender: i }), this.emit("debug", { action: "sendCcipReadFetchRequest", request: f, index: c, urls: r });
      let d = "unknown error", y;
      try {
        y = await f.send();
      } catch (b) {
        a.push(b.message), this.emit("debug", { action: "receiveCcipReadFetchError", request: f, result: { error: b } });
        continue;
      }
      try {
        const b = y.bodyJson;
        if (b.data)
          return this.emit("debug", { action: "receiveCcipReadFetchResult", request: f, result: b }), b.data;
        b.message && (d = b.message), this.emit("debug", { action: "receiveCcipReadFetchError", request: f, result: b });
      } catch {
      }
      et(y.statusCode < 400 || y.statusCode >= 500, `response not found during CCIP fetch: ${d}`, "OFFCHAIN_FAULT", { reason: "404_MISSING_RESOURCE", transaction: t, info: { url: _, errorMessage: d } }), a.push(d);
    }
    et(!1, `error encountered during CCIP fetch: ${a.map((c) => JSON.stringify(c)).join(", ")}`, "OFFCHAIN_FAULT", {
      reason: "500_SERVER_ERROR",
      transaction: t,
      info: { urls: r, errorMessages: a }
    });
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a block before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Block]].
   */
  _wrapBlock(t, e) {
    return new aS(vS(t), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a log before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Log]].
   */
  _wrapLog(t, e) {
    return new Bc(RS(t), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  receipt before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionReceipt]].
   */
  _wrapTransactionReceipt(t, e) {
    return new v0(CS(t), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  response before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionResponse]].
   */
  _wrapTransactionResponse(t, e) {
    return new _c(G0(t), this);
  }
  /**
   *  Resolves to the Network, forcing a network detection using whatever
   *  technique the sub-class requires.
   *
   *  Sub-classes **must** override this.
   */
  _detectNetwork() {
    et(!1, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
      operation: "_detectNetwork"
    });
  }
  /**
   *  Sub-classes should use this to perform all built-in operations. All
   *  methods sanitizes and normalizes the values passed into this.
   *
   *  Sub-classes **must** override this.
   */
  async _perform(t) {
    et(!1, `unsupported method: ${t.method}`, "UNSUPPORTED_OPERATION", {
      operation: t.method,
      info: t
    });
  }
  // State
  async getBlockNumber() {
    const t = Rt(await ct(this, Et, Ie).call(this, { method: "getBlockNumber" }), "%response");
    return w(this, xn) >= 0 && P(this, xn, t), t;
  }
  /**
   *  Returns or resolves to the address for %%address%%, resolving ENS
   *  names and [[Addressable]] objects and returning if already an
   *  address.
   */
  _getAddress(t) {
    return Ee(t, this);
  }
  /**
   *  Returns or resolves to a valid block tag for %%blockTag%%, resolving
   *  negative values and returning if already a valid block tag.
   */
  _getBlockTag(t) {
    if (t == null)
      return "latest";
    switch (t) {
      case "earliest":
        return "0x0";
      case "finalized":
      case "latest":
      case "pending":
      case "safe":
        return t;
    }
    if (jt(t))
      return jt(t, 32) ? t : Us(t);
    if (typeof t == "bigint" && (t = Rt(t, "blockTag")), typeof t == "number")
      return t >= 0 ? Us(t) : w(this, xn) >= 0 ? Us(w(this, xn) + t) : this.getBlockNumber().then((e) => Us(e + t));
    T(!1, "invalid blockTag", "blockTag", t);
  }
  /**
   *  Returns or resolves to a filter for %%filter%%, resolving any ENS
   *  names or [[Addressable]] object and returning if already a valid
   *  filter.
   */
  _getFilter(t) {
    const e = (t.topics || []).map((_) => _ == null ? null : Array.isArray(_) ? sf(_.map((p) => p.toLowerCase())) : _.toLowerCase()), r = "blockHash" in t ? t.blockHash : void 0, i = (_, p, f) => {
      let d;
      switch (_.length) {
        case 0:
          break;
        case 1:
          d = _[0];
          break;
        default:
          _.sort(), d = _;
      }
      if (r && (p != null || f != null))
        throw new Error("invalid filter");
      const y = {};
      return d && (y.address = d), e.length && (y.topics = e), p && (y.fromBlock = p), f && (y.toBlock = f), r && (y.blockHash = r), y;
    };
    let s = [];
    if (t.address)
      if (Array.isArray(t.address))
        for (const _ of t.address)
          s.push(this._getAddress(_));
      else
        s.push(this._getAddress(t.address));
    let a;
    "fromBlock" in t && (a = this._getBlockTag(t.fromBlock));
    let c;
    return "toBlock" in t && (c = this._getBlockTag(t.toBlock)), s.filter((_) => typeof _ != "string").length || a != null && typeof a != "string" || c != null && typeof c != "string" ? Promise.all([Promise.all(s), a, c]).then((_) => i(_[0], _[1], _[2])) : i(s, a, c);
  }
  /**
   *  Returns or resolves to a transaction for %%request%%, resolving
   *  any ENS names or [[Addressable]] and returning if already a valid
   *  transaction.
   */
  _getTransactionRequest(t) {
    const e = R_(t), r = [];
    if (["to", "from"].forEach((i) => {
      if (e[i] == null)
        return;
      const s = Ee(e[i], this);
      Yc(s) ? r.push(async function() {
        e[i] = await s;
      }()) : e[i] = s;
    }), e.blockTag != null) {
      const i = this._getBlockTag(e.blockTag);
      Yc(i) ? r.push(async function() {
        e.blockTag = await i;
      }()) : e.blockTag = i;
    }
    return r.length ? async function() {
      return await Promise.all(r), e;
    }() : e;
  }
  async getNetwork() {
    if (w(this, Ue) == null) {
      const i = (async () => {
        try {
          const s = await this._detectNetwork();
          return this.emit("network", s, null), s;
        } catch (s) {
          throw w(this, Ue) === i && P(this, Ue, null), s;
        }
      })();
      return P(this, Ue, i), (await i).clone();
    }
    const t = w(this, Ue), [e, r] = await Promise.all([
      t,
      this._detectNetwork()
      // The actual connected network
    ]);
    return e.chainId !== r.chainId && (w(this, rs) ? (this.emit("network", r, e), w(this, Ue) === t && P(this, Ue, Promise.resolve(r))) : et(!1, `network changed: ${e.chainId} => ${r.chainId} `, "NETWORK_ERROR", {
      event: "changed"
    })), e.clone();
  }
  async getFeeData() {
    const t = await this.getNetwork(), e = async () => {
      const { _block: i, gasPrice: s, priorityFee: a } = await be({
        _block: ct(this, Et, cf).call(this, "latest", !1),
        gasPrice: (async () => {
          try {
            const f = await ct(this, Et, Ie).call(this, { method: "getGasPrice" });
            return ht(f, "%response");
          } catch {
          }
          return null;
        })(),
        priorityFee: (async () => {
          try {
            const f = await ct(this, Et, Ie).call(this, { method: "getPriorityFee" });
            return ht(f, "%response");
          } catch {
          }
          return null;
        })()
      });
      let c = null, _ = null;
      const p = this._wrapBlock(i, t);
      return p && p.baseFeePerGas && (_ = a ?? BigInt("1000000000"), c = p.baseFeePerGas * FS + _), new wp(s, c, _);
    }, r = t.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    if (r) {
      const i = new kn(r.url), s = await r.processFunc(e, this, i);
      return new wp(s.gasPrice, s.maxFeePerGas, s.maxPriorityFeePerGas);
    }
    return await e();
  }
  async estimateGas(t) {
    let e = this._getTransactionRequest(t);
    return Yc(e) && (e = await e), ht(await ct(this, Et, Ie).call(this, {
      method: "estimateGas",
      transaction: e
    }), "%response");
  }
  async call(t) {
    const { tx: e, blockTag: r } = await be({
      tx: this._getTransactionRequest(t),
      blockTag: this._getBlockTag(t.blockTag)
    });
    return await ct(this, Et, af).call(this, ct(this, Et, of).call(this, e, r, t.enableCcipRead ? 0 : -1));
  }
  async getBalance(t, e) {
    return ht(await ct(this, Et, Ha).call(this, { method: "getBalance" }, t, e), "%response");
  }
  async getTransactionCount(t, e) {
    return Rt(await ct(this, Et, Ha).call(this, { method: "getTransactionCount" }, t, e), "%response");
  }
  async getCode(t, e) {
    return ut(await ct(this, Et, Ha).call(this, { method: "getCode" }, t, e));
  }
  async getStorage(t, e, r) {
    const i = ht(e, "position");
    return ut(await ct(this, Et, Ha).call(this, { method: "getStorage", position: i }, t, r));
  }
  // Write
  async broadcastTransaction(t) {
    const { blockNumber: e, hash: r, network: i } = await be({
      blockNumber: this.getBlockNumber(),
      hash: this._perform({
        method: "broadcastTransaction",
        signedTransaction: t
      }),
      network: this.getNetwork()
    }), s = S_.from(t);
    if (s.hash !== r)
      throw new Error("@TODO: the returned hash did not match");
    return this._wrapTransactionResponse(s, i).replaceableTransaction(e);
  }
  // Queries
  async getBlock(t, e) {
    const { network: r, params: i } = await be({
      network: this.getNetwork(),
      params: ct(this, Et, cf).call(this, t, !!e)
    });
    return i == null ? null : this._wrapBlock(i, r);
  }
  async getTransaction(t) {
    const { network: e, params: r } = await be({
      network: this.getNetwork(),
      params: ct(this, Et, Ie).call(this, { method: "getTransaction", hash: t })
    });
    return r == null ? null : this._wrapTransactionResponse(r, e);
  }
  async getTransactionReceipt(t) {
    const { network: e, params: r } = await be({
      network: this.getNetwork(),
      params: ct(this, Et, Ie).call(this, { method: "getTransactionReceipt", hash: t })
    });
    if (r == null)
      return null;
    if (r.gasPrice == null && r.effectiveGasPrice == null) {
      const i = await ct(this, Et, Ie).call(this, { method: "getTransaction", hash: t });
      if (i == null)
        throw new Error("report this; could not find tx or effectiveGasPrice");
      r.effectiveGasPrice = i.gasPrice;
    }
    return this._wrapTransactionReceipt(r, e);
  }
  async getTransactionResult(t) {
    const { result: e } = await be({
      network: this.getNetwork(),
      result: ct(this, Et, Ie).call(this, { method: "getTransactionResult", hash: t })
    });
    return e == null ? null : ut(e);
  }
  // Bloom-filter Queries
  async getLogs(t) {
    let e = this._getFilter(t);
    Yc(e) && (e = await e);
    const { network: r, params: i } = await be({
      network: this.getNetwork(),
      params: ct(this, Et, Ie).call(this, { method: "getLogs", filter: e })
    });
    return i.map((s) => this._wrapLog(s, r));
  }
  // ENS
  _getProvider(t) {
    et(!1, "provider cannot connect to target network", "UNSUPPORTED_OPERATION", {
      operation: "_getProvider()"
    });
  }
  async getResolver(t) {
    return await v_.fromName(this, t);
  }
  async getAvatar(t) {
    const e = await this.getResolver(t);
    return e ? await e.getAvatar() : null;
  }
  async resolveName(t) {
    const e = await this.getResolver(t);
    return e ? await e.getAddress() : null;
  }
  async lookupAddress(t) {
    t = zt(t);
    const e = qu(t.substring(2).toLowerCase() + ".addr.reverse");
    try {
      const r = await v_.getEnsAddress(this), s = await new _s(r, [
        "function resolver(bytes32) view returns (address)"
      ], this).resolver(e);
      if (s == null || s === ec)
        return null;
      const c = await new _s(s, [
        "function name(bytes32) view returns (string)"
      ], this).name(e);
      return await this.resolveName(c) !== t ? null : c;
    } catch (r) {
      if (fe(r, "BAD_DATA") && r.value === "0x" || fe(r, "CALL_EXCEPTION"))
        return null;
      throw r;
    }
    return null;
  }
  async waitForTransaction(t, e, r) {
    const i = e ?? 1;
    return i === 0 ? this.getTransactionReceipt(t) : new Promise(async (s, a) => {
      let c = null;
      const _ = async (p) => {
        try {
          const f = await this.getTransactionReceipt(t);
          if (f != null && p - f.blockNumber + 1 >= i) {
            s(f), c && (clearTimeout(c), c = null);
            return;
          }
        } catch (f) {
          console.log("EEE", f);
        }
        this.once("block", _);
      };
      r != null && (c = setTimeout(() => {
        c != null && (c = null, this.off("block", _), a(Wt("timeout", "TIMEOUT", { reason: "timeout" })));
      }, r)), _(await this.getBlockNumber());
    });
  }
  async waitForBlock(t) {
    et(!1, "not implemented yet", "NOT_IMPLEMENTED", {
      operation: "waitForBlock"
    });
  }
  /**
   *  Clear a timer created using the [[_setTimeout]] method.
   */
  _clearTimeout(t) {
    const e = w(this, We).get(t);
    e && (e.timer && clearTimeout(e.timer), w(this, We).delete(t));
  }
  /**
   *  Create a timer that will execute %%func%% after at least %%timeout%%
   *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute
   *  in the next event loop.
   *
   *  [Pausing](AbstractProvider-paused) the provider will pause any
   *  associated timers.
   */
  _setTimeout(t, e) {
    e == null && (e = 0);
    const r = Ua(this, Pc)._++, i = () => {
      w(this, We).delete(r), t();
    };
    if (this.paused)
      w(this, We).set(r, { timer: null, func: i, time: e });
    else {
      const s = setTimeout(i, e);
      w(this, We).set(r, { timer: s, func: i, time: fu() });
    }
    return r;
  }
  /**
   *  Perform %%func%% on each subscriber.
   */
  _forEachSubscriber(t) {
    for (const e of w(this, de).values())
      t(e.subscriber);
  }
  /**
   *  Sub-classes may override this to customize subscription
   *  implementations.
   */
  _getSubscriber(t) {
    switch (t.type) {
      case "debug":
      case "error":
      case "network":
        return new D0(t.type);
      case "block": {
        const e = new TS(this);
        return e.pollingInterval = this.pollingInterval, e;
      }
      case "safe":
      case "finalized":
        return new zS(this, t.type);
      case "event":
        return new qf(this, t.filter);
      case "transaction":
        return new US(this, t.hash);
      case "orphan":
        return new kS(this, t.filter);
    }
    throw new Error(`unsupported event: ${t.type}`);
  }
  /**
   *  If a [[Subscriber]] fails and needs to replace itself, this
   *  method may be used.
   *
   *  For example, this is used for providers when using the
   *  ``eth_getFilterChanges`` method, which can return null if state
   *  filters are not supported by the backend, allowing the Subscriber
   *  to swap in a [[PollingEventSubscriber]].
   */
  _recoverSubscriber(t, e) {
    for (const r of w(this, de).values())
      if (r.subscriber === t) {
        r.started && r.subscriber.stop(), r.subscriber = e, r.started && e.start(), w(this, we) != null && e.pause(w(this, we));
        break;
      }
  }
  async on(t, e) {
    const r = await ct(this, Et, n_).call(this, t);
    return r.listeners.push({ listener: e, once: !1 }), r.started || (r.subscriber.start(), r.started = !0, w(this, we) != null && r.subscriber.pause(w(this, we))), this;
  }
  async once(t, e) {
    const r = await ct(this, Et, n_).call(this, t);
    return r.listeners.push({ listener: e, once: !0 }), r.started || (r.subscriber.start(), r.started = !0, w(this, we) != null && r.subscriber.pause(w(this, we))), this;
  }
  async emit(t, ...e) {
    const r = await ct(this, Et, Ya).call(this, t, e);
    if (!r || r.listeners.length === 0)
      return !1;
    const i = r.listeners.length;
    return r.listeners = r.listeners.filter(({ listener: s, once: a }) => {
      const c = new rg(this, a ? null : s, t);
      try {
        s.call(this, ...e, c);
      } catch {
      }
      return !a;
    }), r.listeners.length === 0 && (r.started && r.subscriber.stop(), w(this, de).delete(r.tag)), i > 0;
  }
  async listenerCount(t) {
    if (t) {
      const r = await ct(this, Et, Ya).call(this, t);
      return r ? r.listeners.length : 0;
    }
    let e = 0;
    for (const { listeners: r } of w(this, de).values())
      e += r.length;
    return e;
  }
  async listeners(t) {
    if (t) {
      const r = await ct(this, Et, Ya).call(this, t);
      return r ? r.listeners.map(({ listener: i }) => i) : [];
    }
    let e = [];
    for (const { listeners: r } of w(this, de).values())
      e = e.concat(r.map(({ listener: i }) => i));
    return e;
  }
  async off(t, e) {
    const r = await ct(this, Et, Ya).call(this, t);
    if (!r)
      return this;
    if (e) {
      const i = r.listeners.map(({ listener: s }) => s).indexOf(e);
      i >= 0 && r.listeners.splice(i, 1);
    }
    return (!e || r.listeners.length === 0) && (r.started && r.subscriber.stop(), w(this, de).delete(r.tag)), this;
  }
  async removeAllListeners(t) {
    if (t) {
      const { tag: e, started: r, subscriber: i } = await ct(this, Et, n_).call(this, t);
      r && i.stop(), w(this, de).delete(e);
    } else
      for (const [e, { started: r, subscriber: i }] of w(this, de))
        r && i.stop(), w(this, de).delete(e);
    return this;
  }
  // Alias for "on"
  async addListener(t, e) {
    return await this.on(t, e);
  }
  // Alias for "off"
  async removeListener(t, e) {
    return this.off(t, e);
  }
  /**
   *  If this provider has been destroyed using the [[destroy]] method.
   *
   *  Once destroyed, all resources are reclaimed, internal event loops
   *  and timers are cleaned up and no further requests may be sent to
   *  the provider.
   */
  get destroyed() {
    return w(this, fa);
  }
  /**
   *  Sub-classes may use this to shutdown any sockets or release their
   *  resources and reject any pending requests.
   *
   *  Sub-classes **must** call ``super.destroy()``.
   */
  destroy() {
    this.removeAllListeners();
    for (const t of w(this, We).keys())
      this._clearTimeout(t);
    P(this, fa, !0);
  }
  /**
   *  Whether the provider is currently paused.
   *
   *  A paused provider will not emit any events, and generally should
   *  not make any requests to the network, but that is up to sub-classes
   *  to manage.
   *
   *  Setting ``paused = true`` is identical to calling ``.pause(false)``,
   *  which will buffer any events that occur while paused until the
   *  provider is unpaused.
   */
  get paused() {
    return w(this, we) != null;
  }
  set paused(t) {
    !!t !== this.paused && (this.paused ? this.resume() : this.pause(!1));
  }
  /**
   *  Pause the provider. If %%dropWhilePaused%%, any events that occur
   *  while paused are dropped, otherwise all events will be emitted once
   *  the provider is unpaused.
   */
  pause(t) {
    if (P(this, xn, -1), w(this, we) != null) {
      if (w(this, we) == !!t)
        return;
      et(!1, "cannot change pause type; resume first", "UNSUPPORTED_OPERATION", {
        operation: "pause"
      });
    }
    this._forEachSubscriber((e) => e.pause(t)), P(this, we, !!t);
    for (const e of w(this, We).values())
      e.timer && clearTimeout(e.timer), e.time = fu() - e.time;
  }
  /**
   *  Resume the provider.
   */
  resume() {
    if (w(this, we) != null) {
      this._forEachSubscriber((t) => t.resume()), P(this, we, null);
      for (const t of w(this, We).values()) {
        let e = t.time;
        e < 0 && (e = 0), t.time = fu(), setTimeout(t.func, e);
      }
    }
  }
}
de = new WeakMap(), ci = new WeakMap(), we = new WeakMap(), fa = new WeakMap(), Ue = new WeakMap(), rs = new WeakMap(), _i = new WeakMap(), xn = new WeakMap(), Pc = new WeakMap(), We = new WeakMap(), ha = new WeakMap(), pa = new WeakMap(), Et = new WeakSet(), Ie = async function(t) {
  const e = w(this, pa).cacheTimeout;
  if (e < 0)
    return await this._perform(t);
  const r = r_(t.method, t);
  let i = w(this, _i).get(r);
  return i || (i = this._perform(t), w(this, _i).set(r, i), setTimeout(() => {
    w(this, _i).get(r) === i && w(this, _i).delete(r);
  }, e)), await i;
}, of = async function(t, e, r) {
  et(r < GS, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
    reason: "TOO_MANY_REDIRECTS",
    transaction: Object.assign({}, t, { blockTag: e, enableCcipRead: !0 })
  });
  const i = R_(t);
  try {
    return ut(await this._perform({ method: "call", transaction: i, blockTag: e }));
  } catch (s) {
    if (!this.disableCcipRead && Cf(s) && s.data && r >= 0 && e === "latest" && i.to != null && Jt(s.data, 0, 4) === "0x556f1830") {
      const a = s.data, c = await Ee(i.to, this);
      let _;
      try {
        _ = QS(Jt(s.data, 4));
      } catch (d) {
        et(!1, d.message, "OFFCHAIN_FAULT", {
          reason: "BAD_DATA",
          transaction: i,
          info: { data: a }
        });
      }
      et(_.sender.toLowerCase() === c.toLowerCase(), "CCIP Read sender mismatch", "CALL_EXCEPTION", {
        action: "call",
        data: a,
        reason: "OffchainLookup",
        transaction: i,
        invocation: null,
        revert: {
          signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
          name: "OffchainLookup",
          args: _.errorArgs
        }
      });
      const p = await this.ccipReadFetch(i, _.calldata, _.urls);
      et(p != null, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
        reason: "FETCH_FAILED",
        transaction: i,
        info: { data: s.data, errorArgs: _.errorArgs }
      });
      const f = {
        to: c,
        data: Xt([_.selector, YS([p, _.extraData])])
      };
      this.emit("debug", { action: "sendCcipReadCall", transaction: f });
      try {
        const d = await ct(this, Et, of).call(this, f, e, r + 1);
        return this.emit("debug", { action: "receiveCcipReadCallResult", transaction: Object.assign({}, f), result: d }), d;
      } catch (d) {
        throw this.emit("debug", { action: "receiveCcipReadCallError", transaction: Object.assign({}, f), error: d }), d;
      }
    }
    throw s;
  }
}, af = async function(t) {
  const { value: e } = await be({
    network: this.getNetwork(),
    value: t
  });
  return e;
}, Ha = async function(t, e, r) {
  let i = this._getAddress(e), s = this._getBlockTag(r);
  return (typeof i != "string" || typeof s != "string") && ([i, s] = await Promise.all([i, s])), await ct(this, Et, af).call(this, ct(this, Et, Ie).call(this, Object.assign(t, { address: i, blockTag: s })));
}, cf = async function(t, e) {
  if (jt(t, 32))
    return await ct(this, Et, Ie).call(this, {
      method: "getBlock",
      blockHash: t,
      includeTransactions: e
    });
  let r = this._getBlockTag(t);
  return typeof r != "string" && (r = await r), await ct(this, Et, Ie).call(this, {
    method: "getBlock",
    blockTag: r,
    includeTransactions: e
  });
}, Ya = async function(t, e) {
  let r = await uu(t, this);
  return r.type === "event" && e && e.length > 0 && e[0].removed === !0 && (r = await uu({ orphan: "drop-log", log: e[0] }, this)), w(this, de).get(r.tag) || null;
}, n_ = async function(t) {
  const e = await uu(t, this), r = e.tag;
  let i = w(this, de).get(r);
  return i || (i = { subscriber: this._getSubscriber(e), tag: r, addressableMap: /* @__PURE__ */ new WeakMap(), nameMap: /* @__PURE__ */ new Map(), started: !1, listeners: [] }, w(this, de).set(r, i)), i;
};
function VS(n, t) {
  try {
    const e = _f(n, t);
    if (e)
      return d_(e);
  } catch {
  }
  return null;
}
function _f(n, t) {
  if (n === "0x")
    return null;
  try {
    const e = Rt(Jt(n, t, t + 32)), r = Rt(Jt(n, e, e + 32));
    return Jt(n, e + 32, e + 32 + r);
  } catch {
  }
  return null;
}
function Rp(n) {
  const t = me(n);
  if (t.length > 32)
    throw new Error("internal; should not happen");
  const e = new Uint8Array(32);
  return e.set(t, 32 - t.length), e;
}
function jS(n) {
  if (n.length % 32 === 0)
    return n;
  const t = new Uint8Array(Math.ceil(n.length / 32) * 32);
  return t.set(n), t;
}
const HS = new Uint8Array([]);
function YS(n) {
  const t = [];
  let e = 0;
  for (let r = 0; r < n.length; r++)
    t.push(HS), e += 32;
  for (let r = 0; r < n.length; r++) {
    const i = Tt(n[r]);
    t[r] = Rp(e), t.push(Rp(i.length)), t.push(jS(i)), e += 32 + Math.ceil(i.length / 32) * 32;
  }
  return Xt(t);
}
const Pp = "0x0000000000000000000000000000000000000000000000000000000000000000";
function QS(n) {
  const t = {
    sender: "",
    urls: [],
    calldata: "",
    selector: "",
    extraData: "",
    errorArgs: []
  };
  et(So(n) >= 5 * 32, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
    reason: "insufficient OffchainLookup data"
  });
  const e = Jt(n, 0, 32);
  et(Jt(e, 0, 12) === Jt(Pp, 0, 12), "corrupt OffchainLookup sender", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup sender"
  }), t.sender = Jt(e, 12);
  try {
    const r = [], i = Rt(Jt(n, 32, 64)), s = Rt(Jt(n, i, i + 32)), a = Jt(n, i + 32);
    for (let c = 0; c < s; c++) {
      const _ = VS(a, c * 32);
      if (_ == null)
        throw new Error("abort");
      r.push(_);
    }
    t.urls = r;
  } catch {
    et(!1, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup urls"
    });
  }
  try {
    const r = _f(n, 64);
    if (r == null)
      throw new Error("abort");
    t.calldata = r;
  } catch {
    et(!1, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup calldata"
    });
  }
  et(Jt(n, 100, 128) === Jt(Pp, 0, 28), "corrupt OffchainLookup callbaackSelector", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup callbaackSelector"
  }), t.selector = Jt(n, 96, 100);
  try {
    const r = _f(n, 128);
    if (r == null)
      throw new Error("abort");
    t.extraData = r;
  } catch {
    et(!1, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup extraData"
    });
  }
  return t.errorArgs = "sender,urls,calldata,selector,extraData".split(/,/).map((r) => t[r]), t;
}
function vs(n, t) {
  if (n.provider)
    return n.provider;
  et(!1, "missing provider", "UNSUPPORTED_OPERATION", { operation: t });
}
async function vp(n, t) {
  let e = R_(t);
  if (e.to != null && (e.to = Ee(e.to, n)), e.from != null) {
    const r = e.from;
    e.from = Promise.all([
      n.getAddress(),
      Ee(r, n)
    ]).then(([i, s]) => (T(i.toLowerCase() === s.toLowerCase(), "transaction from mismatch", "tx.from", s), i));
  } else
    e.from = n.getAddress();
  return await be(e);
}
class WS {
  /**
   *  Creates a new Signer connected to %%provider%%.
   */
  constructor(t) {
    /**
     *  The provider this signer is connected to.
     */
    U(this, "provider");
    gt(this, { provider: t || null });
  }
  async getNonce(t) {
    return vs(this, "getTransactionCount").getTransactionCount(await this.getAddress(), t);
  }
  async populateCall(t) {
    return await vp(this, t);
  }
  async populateTransaction(t) {
    const e = vs(this, "populateTransaction"), r = await vp(this, t);
    r.nonce == null && (r.nonce = await this.getNonce("pending")), r.gasLimit == null && (r.gasLimit = await this.estimateGas(r));
    const i = await this.provider.getNetwork();
    if (r.chainId != null) {
      const a = ht(r.chainId);
      T(a === i.chainId, "transaction chainId mismatch", "tx.chainId", t.chainId);
    } else
      r.chainId = i.chainId;
    const s = r.maxFeePerGas != null || r.maxPriorityFeePerGas != null;
    if (r.gasPrice != null && (r.type === 2 || s) ? T(!1, "eip-1559 transaction do not support gasPrice", "tx", t) : (r.type === 0 || r.type === 1) && s && T(!1, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", t), (r.type === 2 || r.type == null) && r.maxFeePerGas != null && r.maxPriorityFeePerGas != null)
      r.type = 2;
    else if (r.type === 0 || r.type === 1) {
      const a = await e.getFeeData();
      et(a.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
        operation: "getGasPrice"
      }), r.gasPrice == null && (r.gasPrice = a.gasPrice);
    } else {
      const a = await e.getFeeData();
      if (r.type == null)
        if (a.maxFeePerGas != null && a.maxPriorityFeePerGas != null)
          if (r.type = 2, r.gasPrice != null) {
            const c = r.gasPrice;
            delete r.gasPrice, r.maxFeePerGas = c, r.maxPriorityFeePerGas = c;
          } else
            r.maxFeePerGas == null && (r.maxFeePerGas = a.maxFeePerGas), r.maxPriorityFeePerGas == null && (r.maxPriorityFeePerGas = a.maxPriorityFeePerGas);
        else a.gasPrice != null ? (et(!s, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
          operation: "populateTransaction"
        }), r.gasPrice == null && (r.gasPrice = a.gasPrice), r.type = 0) : et(!1, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
          operation: "signer.getFeeData"
        });
      else (r.type === 2 || r.type === 3) && (r.maxFeePerGas == null && (r.maxFeePerGas = a.maxFeePerGas), r.maxPriorityFeePerGas == null && (r.maxPriorityFeePerGas = a.maxPriorityFeePerGas));
    }
    return await be(r);
  }
  async estimateGas(t) {
    return vs(this, "estimateGas").estimateGas(await this.populateCall(t));
  }
  async call(t) {
    return vs(this, "call").call(await this.populateCall(t));
  }
  async resolveName(t) {
    return await vs(this, "resolveName").resolveName(t);
  }
  async sendTransaction(t) {
    const e = vs(this, "sendTransaction"), r = await this.populateTransaction(t);
    delete r.from;
    const i = S_.from(r);
    return await e.broadcastTransaction(await this.signTransaction(i));
  }
}
function JS(n) {
  return JSON.parse(JSON.stringify(n));
}
var ye, xr, ns, li, is, da, wi, lf, uf;
class K0 {
  /**
   *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]
   *  and [[_emitResults]] to setup the subscription and provide the event
   *  to the %%provider%%.
   */
  constructor(t) {
    j(this, wi);
    j(this, ye);
    j(this, xr);
    j(this, ns);
    j(this, li);
    j(this, is);
    j(this, da);
    P(this, ye, t), P(this, xr, null), P(this, ns, ct(this, wi, lf).bind(this)), P(this, li, !1), P(this, is, null), P(this, da, !1);
  }
  /**
   *  Sub-classes **must** override this to begin the subscription.
   */
  _subscribe(t) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle the events.
   */
  _emitResults(t, e) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle recovery on errors.
   */
  _recover(t) {
    throw new Error("subclasses must override this");
  }
  start() {
    w(this, li) || (P(this, li, !0), ct(this, wi, lf).call(this, -2));
  }
  stop() {
    w(this, li) && (P(this, li, !1), P(this, da, !0), ct(this, wi, uf).call(this), w(this, ye).off("block", w(this, ns)));
  }
  pause(t) {
    t && ct(this, wi, uf).call(this), w(this, ye).off("block", w(this, ns));
  }
  resume() {
    this.start();
  }
}
ye = new WeakMap(), xr = new WeakMap(), ns = new WeakMap(), li = new WeakMap(), is = new WeakMap(), da = new WeakMap(), wi = new WeakSet(), lf = async function(t) {
  try {
    w(this, xr) == null && P(this, xr, this._subscribe(w(this, ye)));
    let e = null;
    try {
      e = await w(this, xr);
    } catch (s) {
      if (!fe(s, "UNSUPPORTED_OPERATION") || s.operation !== "eth_newFilter")
        throw s;
    }
    if (e == null) {
      P(this, xr, null), w(this, ye)._recoverSubscriber(this, this._recover(w(this, ye)));
      return;
    }
    const r = await w(this, ye).getNetwork();
    if (w(this, is) || P(this, is, r), w(this, is).chainId !== r.chainId)
      throw new Error("chaid changed");
    if (w(this, da))
      return;
    const i = await w(this, ye).send("eth_getFilterChanges", [e]);
    await this._emitResults(w(this, ye), i);
  } catch (e) {
    console.log("@TODO", e);
  }
  w(this, ye).once("block", w(this, ns));
}, uf = function() {
  const t = w(this, xr);
  t && (P(this, xr, null), t.then((e) => {
    w(this, ye).destroyed || w(this, ye).send("eth_uninstallFilter", [e]);
  }));
};
var ss;
class $S extends K0 {
  /**
   *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%
   *  listening for %%filter%%.
   */
  constructor(e, r) {
    super(e);
    j(this, ss);
    P(this, ss, JS(r));
  }
  _recover(e) {
    return new qf(e, w(this, ss));
  }
  async _subscribe(e) {
    return await e.send("eth_newFilter", [w(this, ss)]);
  }
  async _emitResults(e, r) {
    for (const i of r)
      e.emit(w(this, ss), e._wrapLog(i, e._network));
  }
}
ss = new WeakMap();
class qS extends K0 {
  async _subscribe(t) {
    return await t.send("eth_newPendingTransactionFilter", []);
  }
  async _emitResults(t, e) {
    for (const r of e)
      t.emit("pending", r);
  }
}
const ZS = "bigint,boolean,function,number,string,symbol".split(/,/g);
function i_(n) {
  if (n == null || ZS.indexOf(typeof n) >= 0 || typeof n.getAddress == "function")
    return n;
  if (Array.isArray(n))
    return n.map(i_);
  if (typeof n == "object")
    return Object.keys(n).reduce((t, e) => (t[e] = n[e], t), {});
  throw new Error(`should not happen: ${n} (${typeof n})`);
}
function XS(n) {
  return new Promise((t) => {
    setTimeout(t, n);
  });
}
function Ms(n) {
  return n && n.toLowerCase();
}
function Mp(n) {
  return n && typeof n.pollingInterval == "number";
}
const V0 = {
  polling: !1,
  staticNetwork: null,
  batchStallTime: 10,
  batchMaxSize: 1 << 20,
  batchMaxCount: 100,
  cacheTimeout: 250,
  pollingInterval: 4e3
};
class hu extends WS {
  constructor(e, r) {
    super(e);
    U(this, "address");
    r = zt(r), gt(this, { address: r });
  }
  connect(e) {
    et(!1, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
      operation: "signer.connect"
    });
  }
  async getAddress() {
    return this.address;
  }
  // JSON-RPC will automatially fill in nonce, etc. so we just check from
  async populateTransaction(e) {
    return await this.populateCall(e);
  }
  // Returns just the hash of the transaction after sent, which is what
  // the bare JSON-RPC API does;
  async sendUncheckedTransaction(e) {
    const r = i_(e), i = [];
    if (r.from) {
      const a = r.from;
      i.push((async () => {
        const c = await Ee(a, this.provider);
        T(c != null && c.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", e), r.from = c;
      })());
    } else
      r.from = this.address;
    if (r.gasLimit == null && i.push((async () => {
      r.gasLimit = await this.provider.estimateGas({ ...r, from: this.address });
    })()), r.to != null) {
      const a = r.to;
      i.push((async () => {
        r.to = await Ee(a, this.provider);
      })());
    }
    i.length && await Promise.all(i);
    const s = this.provider.getRpcTransaction(r);
    return this.provider.send("eth_sendTransaction", [s]);
  }
  async sendTransaction(e) {
    const r = await this.provider.getBlockNumber(), i = await this.sendUncheckedTransaction(e);
    return await new Promise((s, a) => {
      const c = [1e3, 100];
      let _ = 0;
      const p = async () => {
        try {
          const f = await this.provider.getTransaction(i);
          if (f != null) {
            s(f.replaceableTransaction(r));
            return;
          }
        } catch (f) {
          if (fe(f, "CANCELLED") || fe(f, "BAD_DATA") || fe(f, "NETWORK_ERROR") || fe(f, "UNSUPPORTED_OPERATION")) {
            f.info == null && (f.info = {}), f.info.sendTransactionHash = i, a(f);
            return;
          }
          if (fe(f, "INVALID_ARGUMENT") && (_++, f.info == null && (f.info = {}), f.info.sendTransactionHash = i, _ > 10)) {
            a(f);
            return;
          }
          this.provider.emit("error", Wt("failed to fetch transation after sending (will try again)", "UNKNOWN_ERROR", { error: f }));
        }
        this.provider._setTimeout(() => {
          p();
        }, c.pop() || 4e3);
      };
      p();
    });
  }
  async signTransaction(e) {
    const r = i_(e);
    if (r.from) {
      const s = await Ee(r.from, this.provider);
      T(s != null && s.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", e), r.from = s;
    } else
      r.from = this.address;
    const i = this.provider.getRpcTransaction(r);
    return await this.provider.send("eth_signTransaction", [i]);
  }
  async signMessage(e) {
    const r = typeof e == "string" ? On(e) : e;
    return await this.provider.send("personal_sign", [
      ut(r),
      this.address.toLowerCase()
    ]);
  }
  async signTypedData(e, r, i) {
    const s = i_(i), a = await E_.resolveNames(e, r, s, async (c) => {
      const _ = await Ee(c);
      return T(_ != null, "TypedData does not support null address", "value", c), _;
    });
    return await this.provider.send("eth_signTypedData_v4", [
      this.address.toLowerCase(),
      JSON.stringify(E_.getPayload(a.domain, r, a.value))
    ]);
  }
  async unlock(e) {
    return this.provider.send("personal_unlockAccount", [
      this.address.toLowerCase(),
      e,
      null
    ]);
  }
  // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign
  async _legacySignMessage(e) {
    const r = typeof e == "string" ? On(e) : e;
    return await this.provider.send("eth_sign", [
      this.address.toLowerCase(),
      ut(r)
    ]);
  }
}
var os, wa, Bn, Br, _r, Je, ve, vc, ff;
class t2 extends KS {
  constructor(e, r) {
    super(e, r);
    j(this, vc);
    j(this, os);
    // The next ID to use for the JSON-RPC ID field
    j(this, wa);
    // Payloads are queued and triggered in batches using the drainTimer
    j(this, Bn);
    j(this, Br);
    j(this, _r);
    j(this, Je);
    j(this, ve);
    P(this, wa, 1), P(this, os, Object.assign({}, V0, r || {})), P(this, Bn, []), P(this, Br, null), P(this, Je, null), P(this, ve, null);
    {
      let s = null;
      const a = new Promise((c) => {
        s = c;
      });
      P(this, _r, { promise: a, resolve: s });
    }
    const i = this._getOption("staticNetwork");
    typeof i == "boolean" ? (T(!i || e !== "any", "staticNetwork cannot be used on special network 'any'", "options", r), i && e != null && P(this, Je, ln.from(e))) : i && (T(e == null || i.matches(e), "staticNetwork MUST match network object", "options", r), P(this, Je, i));
  }
  /**
   *  Returns the value associated with the option %%key%%.
   *
   *  Sub-classes can use this to inquire about configuration options.
   */
  _getOption(e) {
    return w(this, os)[e];
  }
  /**
   *  Gets the [[Network]] this provider has committed to. On each call, the network
   *  is detected, and if it has changed, the call will reject.
   */
  get _network() {
    return et(w(this, Je), "network is not available yet", "NETWORK_ERROR"), w(this, Je);
  }
  /**
   *  Resolves to the non-normalized value by performing %%req%%.
   *
   *  Sub-classes may override this to modify behavior of actions,
   *  and should generally call ``super._perform`` as a fallback.
   */
  async _perform(e) {
    if (e.method === "call" || e.method === "estimateGas") {
      let i = e.transaction;
      if (i && i.type != null && ht(i.type) && i.maxFeePerGas == null && i.maxPriorityFeePerGas == null) {
        const s = await this.getFeeData();
        s.maxFeePerGas == null && s.maxPriorityFeePerGas == null && (e = Object.assign({}, e, {
          transaction: Object.assign({}, i, { type: void 0 })
        }));
      }
    }
    const r = this.getRpcRequest(e);
    return r != null ? await this.send(r.method, r.args) : super._perform(e);
  }
  /**
   *  Sub-classes may override this; it detects the *actual* network that
   *  we are **currently** connected to.
   *
   *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the
   *  _send primitive must be used instead.
   */
  async _detectNetwork() {
    const e = this._getOption("staticNetwork");
    if (e)
      if (e === !0) {
        if (w(this, Je))
          return w(this, Je);
      } else
        return e;
    return w(this, ve) ? await w(this, ve) : this.ready ? (P(this, ve, (async () => {
      try {
        const r = ln.from(ht(await this.send("eth_chainId", [])));
        return P(this, ve, null), r;
      } catch (r) {
        throw P(this, ve, null), r;
      }
    })()), await w(this, ve)) : (P(this, ve, (async () => {
      const r = {
        id: Ua(this, wa)._++,
        method: "eth_chainId",
        params: [],
        jsonrpc: "2.0"
      };
      this.emit("debug", { action: "sendRpcPayload", payload: r });
      let i;
      try {
        i = (await this._send(r))[0], P(this, ve, null);
      } catch (s) {
        throw P(this, ve, null), this.emit("debug", { action: "receiveRpcError", error: s }), s;
      }
      if (this.emit("debug", { action: "receiveRpcResult", result: i }), "result" in i)
        return ln.from(ht(i.result));
      throw this.getRpcError(r, i);
    })()), await w(this, ve));
  }
  /**
   *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls
   *  will be passed to [[_send]] from [[send]]. If it is overridden, then
   *  ``super._start()`` **MUST** be called.
   *
   *  Calling it multiple times is safe and has no effect.
   */
  _start() {
    w(this, _r) == null || w(this, _r).resolve == null || (w(this, _r).resolve(), P(this, _r, null), (async () => {
      for (; w(this, Je) == null && !this.destroyed; )
        try {
          P(this, Je, await this._detectNetwork());
        } catch (e) {
          if (this.destroyed)
            break;
          console.log("JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)"), this.emit("error", Wt("failed to bootstrap network detection", "NETWORK_ERROR", { event: "initial-network-discovery", info: { error: e } })), await XS(1e3);
        }
      ct(this, vc, ff).call(this);
    })());
  }
  /**
   *  Resolves once the [[_start]] has been called. This can be used in
   *  sub-classes to defer sending data until the connection has been
   *  established.
   */
  async _waitUntilReady() {
    if (w(this, _r) != null)
      return await w(this, _r).promise;
  }
  /**
   *  Return a Subscriber that will manage the %%sub%%.
   *
   *  Sub-classes may override this to modify the behavior of
   *  subscription management.
   */
  _getSubscriber(e) {
    return e.type === "pending" ? new qS(this) : e.type === "event" ? this._getOption("polling") ? new qf(this, e.filter) : new $S(this, e.filter) : e.type === "orphan" && e.filter.orphan === "drop-log" ? new D0("orphan") : super._getSubscriber(e);
  }
  /**
   *  Returns true only if the [[_start]] has been called.
   */
  get ready() {
    return w(this, _r) == null;
  }
  /**
   *  Returns %%tx%% as a normalized JSON-RPC transaction request,
   *  which has all values hexlified and any numeric values converted
   *  to Quantity values.
   */
  getRpcTransaction(e) {
    const r = {};
    return ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach((i) => {
      if (e[i] == null)
        return;
      let s = i;
      i === "gasLimit" && (s = "gas"), r[s] = Us(ht(e[i], `tx.${i}`));
    }), ["from", "to", "data"].forEach((i) => {
      e[i] != null && (r[i] = ut(e[i]));
    }), e.accessList && (r.accessList = ms(e.accessList)), e.blobVersionedHashes && (r.blobVersionedHashes = e.blobVersionedHashes.map((i) => i.toLowerCase())), r;
  }
  /**
   *  Returns the request method and arguments required to perform
   *  %%req%%.
   */
  getRpcRequest(e) {
    switch (e.method) {
      case "chainId":
        return { method: "eth_chainId", args: [] };
      case "getBlockNumber":
        return { method: "eth_blockNumber", args: [] };
      case "getGasPrice":
        return { method: "eth_gasPrice", args: [] };
      case "getPriorityFee":
        return { method: "eth_maxPriorityFeePerGas", args: [] };
      case "getBalance":
        return {
          method: "eth_getBalance",
          args: [Ms(e.address), e.blockTag]
        };
      case "getTransactionCount":
        return {
          method: "eth_getTransactionCount",
          args: [Ms(e.address), e.blockTag]
        };
      case "getCode":
        return {
          method: "eth_getCode",
          args: [Ms(e.address), e.blockTag]
        };
      case "getStorage":
        return {
          method: "eth_getStorageAt",
          args: [
            Ms(e.address),
            "0x" + e.position.toString(16),
            e.blockTag
          ]
        };
      case "broadcastTransaction":
        return {
          method: "eth_sendRawTransaction",
          args: [e.signedTransaction]
        };
      case "getBlock":
        if ("blockTag" in e)
          return {
            method: "eth_getBlockByNumber",
            args: [e.blockTag, !!e.includeTransactions]
          };
        if ("blockHash" in e)
          return {
            method: "eth_getBlockByHash",
            args: [e.blockHash, !!e.includeTransactions]
          };
        break;
      case "getTransaction":
        return {
          method: "eth_getTransactionByHash",
          args: [e.hash]
        };
      case "getTransactionReceipt":
        return {
          method: "eth_getTransactionReceipt",
          args: [e.hash]
        };
      case "call":
        return {
          method: "eth_call",
          args: [this.getRpcTransaction(e.transaction), e.blockTag]
        };
      case "estimateGas":
        return {
          method: "eth_estimateGas",
          args: [this.getRpcTransaction(e.transaction)]
        };
      case "getLogs":
        return e.filter && e.filter.address != null && (Array.isArray(e.filter.address) ? e.filter.address = e.filter.address.map(Ms) : e.filter.address = Ms(e.filter.address)), { method: "eth_getLogs", args: [e.filter] };
    }
    return null;
  }
  /**
   *  Returns an ethers-style Error for the given JSON-RPC error
   *  %%payload%%, coalescing the various strings and error shapes
   *  that different nodes return, coercing them into a machine-readable
   *  standardized error.
   */
  getRpcError(e, r) {
    const { method: i } = e, { error: s } = r;
    if (i === "eth_estimateGas" && s.message) {
      const _ = s.message;
      if (!_.match(/revert/i) && _.match(/insufficient funds/i))
        return Wt("insufficient funds", "INSUFFICIENT_FUNDS", {
          transaction: e.params[0],
          info: { payload: e, error: s }
        });
    }
    if (i === "eth_call" || i === "eth_estimateGas") {
      const _ = hf(s), p = cc.getBuiltinCallException(i === "eth_call" ? "call" : "estimateGas", e.params[0], _ ? _.data : null);
      return p.info = { error: s, payload: e }, p;
    }
    const a = JSON.stringify(r2(s));
    if (typeof s.message == "string" && s.message.match(/user denied|ethers-user-denied/i))
      return Wt("user rejected action", "ACTION_REJECTED", {
        action: {
          eth_sign: "signMessage",
          personal_sign: "signMessage",
          eth_signTypedData_v4: "signTypedData",
          eth_signTransaction: "signTransaction",
          eth_sendTransaction: "sendTransaction",
          eth_requestAccounts: "requestAccess",
          wallet_requestAccounts: "requestAccess"
        }[i] || "unknown",
        reason: "rejected",
        info: { payload: e, error: s }
      });
    if (i === "eth_sendRawTransaction" || i === "eth_sendTransaction") {
      const _ = e.params[0];
      if (a.match(/insufficient funds|base fee exceeds gas limit/i))
        return Wt("insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
          transaction: _,
          info: { error: s }
        });
      if (a.match(/nonce/i) && a.match(/too low/i))
        return Wt("nonce has already been used", "NONCE_EXPIRED", { transaction: _, info: { error: s } });
      if (a.match(/replacement transaction/i) && a.match(/underpriced/i))
        return Wt("replacement fee too low", "REPLACEMENT_UNDERPRICED", { transaction: _, info: { error: s } });
      if (a.match(/only replay-protected/i))
        return Wt("legacy pre-eip-155 transactions not supported", "UNSUPPORTED_OPERATION", {
          operation: i,
          info: { transaction: _, info: { error: s } }
        });
    }
    let c = !!a.match(/the method .* does not exist/i);
    return c || s && s.details && s.details.startsWith("Unauthorized method:") && (c = !0), c ? Wt("unsupported operation", "UNSUPPORTED_OPERATION", {
      operation: e.method,
      info: { error: s, payload: e }
    }) : Wt("could not coalesce error", "UNKNOWN_ERROR", { error: s, payload: e });
  }
  /**
   *  Requests the %%method%% with %%params%% via the JSON-RPC protocol
   *  over the underlying channel. This can be used to call methods
   *  on the backend that do not have a high-level API within the Provider
   *  API.
   *
   *  This method queues requests according to the batch constraints
   *  in the options, assigns the request a unique ID.
   *
   *  **Do NOT override** this method in sub-classes; instead
   *  override [[_send]] or force the options values in the
   *  call to the constructor to modify this method's behavior.
   */
  send(e, r) {
    if (this.destroyed)
      return Promise.reject(Wt("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: e }));
    const i = Ua(this, wa)._++, s = new Promise((a, c) => {
      w(this, Bn).push({
        resolve: a,
        reject: c,
        payload: { method: e, params: r, id: i, jsonrpc: "2.0" }
      });
    });
    return ct(this, vc, ff).call(this), s;
  }
  /**
   *  Resolves to the [[Signer]] account for  %%address%% managed by
   *  the client.
   *
   *  If the %%address%% is a number, it is used as an index in the
   *  the accounts from [[listAccounts]].
   *
   *  This can only be used on clients which manage accounts (such as
   *  Geth with imported account or MetaMask).
   *
   *  Throws if the account doesn't exist.
   */
  async getSigner(e) {
    e == null && (e = 0);
    const r = this.send("eth_accounts", []);
    if (typeof e == "number") {
      const s = await r;
      if (e >= s.length)
        throw new Error("no such account");
      return new hu(this, s[e]);
    }
    const { accounts: i } = await be({
      network: this.getNetwork(),
      accounts: r
    });
    e = zt(e);
    for (const s of i)
      if (zt(s) === e)
        return new hu(this, e);
    throw new Error("invalid account");
  }
  async listAccounts() {
    return (await this.send("eth_accounts", [])).map((r) => new hu(this, r));
  }
  destroy() {
    w(this, Br) && (clearTimeout(w(this, Br)), P(this, Br, null));
    for (const { payload: e, reject: r } of w(this, Bn))
      r(Wt("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: e.method }));
    P(this, Bn, []), super.destroy();
  }
}
os = new WeakMap(), wa = new WeakMap(), Bn = new WeakMap(), Br = new WeakMap(), _r = new WeakMap(), Je = new WeakMap(), ve = new WeakMap(), vc = new WeakSet(), ff = function() {
  if (w(this, Br))
    return;
  const e = this._getOption("batchMaxCount") === 1 ? 0 : this._getOption("batchStallTime");
  P(this, Br, setTimeout(() => {
    P(this, Br, null);
    const r = w(this, Bn);
    for (P(this, Bn, []); r.length; ) {
      const i = [r.shift()];
      for (; r.length && i.length !== w(this, os).batchMaxCount; )
        if (i.push(r.shift()), JSON.stringify(i.map((a) => a.payload)).length > w(this, os).batchMaxSize) {
          r.unshift(i.pop());
          break;
        }
      (async () => {
        const s = i.length === 1 ? i[0].payload : i.map((a) => a.payload);
        this.emit("debug", { action: "sendRpcPayload", payload: s });
        try {
          const a = await this._send(s);
          this.emit("debug", { action: "receiveRpcResult", result: a });
          for (const { resolve: c, reject: _, payload: p } of i) {
            if (this.destroyed) {
              _(Wt("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: p.method }));
              continue;
            }
            const f = a.filter((d) => d.id === p.id)[0];
            if (f == null) {
              const d = Wt("missing response for request", "BAD_DATA", {
                value: a,
                info: { payload: p }
              });
              this.emit("error", d), _(d);
              continue;
            }
            if ("error" in f) {
              _(this.getRpcError(p, f));
              continue;
            }
            c(f.result);
          }
        } catch (a) {
          this.emit("debug", { action: "receiveRpcError", error: a });
          for (const { reject: c } of i)
            c(a);
        }
      })();
    }
  }, e));
};
var ui;
class j0 extends t2 {
  constructor(e, r) {
    super(e, r);
    j(this, ui);
    let i = this._getOption("pollingInterval");
    i == null && (i = V0.pollingInterval), P(this, ui, i);
  }
  _getSubscriber(e) {
    const r = super._getSubscriber(e);
    return Mp(r) && (r.pollingInterval = w(this, ui)), r;
  }
  /**
   *  The polling interval (default: 4000 ms)
   */
  get pollingInterval() {
    return w(this, ui);
  }
  set pollingInterval(e) {
    if (!Number.isInteger(e) || e < 0)
      throw new Error("invalid interval");
    P(this, ui, e), this._forEachSubscriber((r) => {
      Mp(r) && (r.pollingInterval = w(this, ui));
    });
  }
}
ui = new WeakMap();
var ga;
class e2 extends j0 {
  constructor(e, r, i) {
    e == null && (e = "http://localhost:8545");
    super(r, i);
    j(this, ga);
    typeof e == "string" ? P(this, ga, new kn(e)) : P(this, ga, e.clone());
  }
  _getConnection() {
    return w(this, ga).clone();
  }
  async send(e, r) {
    return await this._start(), await super.send(e, r);
  }
  async _send(e) {
    const r = this._getConnection();
    r.body = JSON.stringify(e), r.setHeader("content-type", "application/json");
    const i = await r.send();
    i.assertOk();
    let s = i.bodyJson;
    return Array.isArray(s) || (s = [s]), s;
  }
}
ga = new WeakMap();
function hf(n) {
  if (n == null)
    return null;
  if (typeof n.message == "string" && n.message.match(/revert/i) && jt(n.data))
    return { message: n.message, data: n.data };
  if (typeof n == "object") {
    for (const t in n) {
      const e = hf(n[t]);
      if (e)
        return e;
    }
    return null;
  }
  if (typeof n == "string")
    try {
      return hf(JSON.parse(n));
    } catch {
    }
  return null;
}
function pf(n, t) {
  if (n != null) {
    if (typeof n.message == "string" && t.push(n.message), typeof n == "object")
      for (const e in n)
        pf(n[e], t);
    if (typeof n == "string")
      try {
        return pf(JSON.parse(n), t);
      } catch {
      }
  }
}
function r2(n) {
  const t = [];
  return pf(n, t), t;
}
var ya;
class n2 extends j0 {
  /**
   *  Connnect to the %%ethereum%% provider, optionally forcing the
   *  %%network%%.
   */
  constructor(e, r, i) {
    const s = Object.assign({}, i ?? {}, { batchMaxCount: 1 });
    T(e && e.request, "invalid EIP-1193 provider", "ethereum", e);
    super(r, s);
    j(this, ya);
    P(this, ya, async (a, c) => {
      const _ = { method: a, params: c };
      this.emit("debug", { action: "sendEip1193Request", payload: _ });
      try {
        const p = await e.request(_);
        return this.emit("debug", { action: "receiveEip1193Result", result: p }), p;
      } catch (p) {
        const f = new Error(p.message);
        throw f.code = p.code, f.data = p.data, f.payload = _, this.emit("debug", { action: "receiveEip1193Error", error: f }), f;
      }
    });
  }
  async send(e, r) {
    return await this._start(), await super.send(e, r);
  }
  async _send(e) {
    T(!Array.isArray(e), "EIP-1193 does not support batch request", "payload", e);
    try {
      const r = await w(this, ya).call(this, e.method, e.params || []);
      return [{ id: e.id, result: r }];
    } catch (r) {
      return [{
        id: e.id,
        error: { code: r.code, data: r.data, message: r.message }
      }];
    }
  }
  getRpcError(e, r) {
    switch (r = JSON.parse(JSON.stringify(r)), r.error.code || -1) {
      case 4001:
        r.error.message = `ethers-user-denied: ${r.error.message}`;
        break;
      case 4200:
        r.error.message = `ethers-unsupported: ${r.error.message}`;
        break;
    }
    return super.getRpcError(e, r);
  }
  /**
   *  Resolves to ``true`` if the provider manages the %%address%%.
   */
  async hasSigner(e) {
    e == null && (e = 0);
    const r = await this.send("eth_accounts", []);
    return typeof e == "number" ? r.length > e : (e = e.toLowerCase(), r.filter((i) => i.toLowerCase() === e).length !== 0);
  }
  async getSigner(e) {
    if (e == null && (e = 0), !await this.hasSigner(e))
      try {
        await w(this, ya).call(this, "eth_requestAccounts", []);
      } catch (r) {
        const i = r.payload;
        throw this.getRpcError(i, { id: i.id, error: r });
      }
    return await super.getSigner(e);
  }
}
ya = new WeakMap();
var Fn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function H0(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
function i2(n) {
  if (n.__esModule) return n;
  var t = n.default;
  if (typeof t == "function") {
    var e = function r() {
      return this instanceof r ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    e.prototype = t.prototype;
  } else e = {};
  return Object.defineProperty(e, "__esModule", { value: !0 }), Object.keys(n).forEach(function(r) {
    var i = Object.getOwnPropertyDescriptor(n, r);
    Object.defineProperty(e, r, i.get ? i : {
      enumerable: !0,
      get: function() {
        return n[r];
      }
    });
  }), e;
}
var Nc = {};
Object.defineProperty(Nc, "__esModule", { value: !0 });
function s2(n) {
  {
    const t = ne.from(n);
    t.reverse();
    const e = t.toString("hex");
    return e.length === 0 ? BigInt(0) : BigInt(`0x${e}`);
  }
}
Nc.toBigIntLE = s2;
function o2(n) {
  {
    const t = n.toString("hex");
    return t.length === 0 ? BigInt(0) : BigInt(`0x${t}`);
  }
}
var a2 = Nc.toBigIntBE = o2;
function c2(n, t) {
  {
    const e = n.toString(16), r = ne.from(e.padStart(t * 2, "0").slice(0, t * 2), "hex");
    return r.reverse(), r;
  }
}
Nc.toBufferLE = c2;
function _2(n, t) {
  {
    const e = n.toString(16);
    return ne.from(e.padStart(t * 2, "0").slice(0, t * 2), "hex");
  }
}
var l2 = Nc.toBufferBE = _2, df = { exports: {} };
function u2(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var Y0 = { exports: {} }, te = Y0.exports = {}, yr, br;
function wf() {
  throw new Error("setTimeout has not been defined");
}
function gf() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? yr = setTimeout : yr = wf;
  } catch {
    yr = wf;
  }
  try {
    typeof clearTimeout == "function" ? br = clearTimeout : br = gf;
  } catch {
    br = gf;
  }
})();
function Q0(n) {
  if (yr === setTimeout)
    return setTimeout(n, 0);
  if ((yr === wf || !yr) && setTimeout)
    return yr = setTimeout, setTimeout(n, 0);
  try {
    return yr(n, 0);
  } catch {
    try {
      return yr.call(null, n, 0);
    } catch {
      return yr.call(this, n, 0);
    }
  }
}
function f2(n) {
  if (br === clearTimeout)
    return clearTimeout(n);
  if ((br === gf || !br) && clearTimeout)
    return br = clearTimeout, clearTimeout(n);
  try {
    return br(n);
  } catch {
    try {
      return br.call(null, n);
    } catch {
      return br.call(this, n);
    }
  }
}
var Nn = [], Po = !1, Oi, s_ = -1;
function h2() {
  !Po || !Oi || (Po = !1, Oi.length ? Nn = Oi.concat(Nn) : s_ = -1, Nn.length && W0());
}
function W0() {
  if (!Po) {
    var n = Q0(h2);
    Po = !0;
    for (var t = Nn.length; t; ) {
      for (Oi = Nn, Nn = []; ++s_ < t; )
        Oi && Oi[s_].run();
      s_ = -1, t = Nn.length;
    }
    Oi = null, Po = !1, f2(n);
  }
}
te.nextTick = function(n) {
  var t = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var e = 1; e < arguments.length; e++)
      t[e - 1] = arguments[e];
  Nn.push(new J0(n, t)), Nn.length === 1 && !Po && Q0(W0);
};
function J0(n, t) {
  this.fun = n, this.array = t;
}
J0.prototype.run = function() {
  this.fun.apply(null, this.array);
};
te.title = "browser";
te.browser = !0;
te.env = {};
te.argv = [];
te.version = "";
te.versions = {};
function Dn() {
}
te.on = Dn;
te.addListener = Dn;
te.once = Dn;
te.off = Dn;
te.removeListener = Dn;
te.removeAllListeners = Dn;
te.emit = Dn;
te.prependListener = Dn;
te.prependOnceListener = Dn;
te.listeners = function(n) {
  return [];
};
te.binding = function(n) {
  throw new Error("process.binding is not supported");
};
te.cwd = function() {
  return "/";
};
te.chdir = function(n) {
  throw new Error("process.chdir is not supported");
};
te.umask = function() {
  return 0;
};
var p2 = Y0.exports;
const vt = /* @__PURE__ */ u2(p2);
var Zf = { exports: {} }, vo = typeof Reflect == "object" ? Reflect : null, xp = vo && typeof vo.apply == "function" ? vo.apply : function(t, e, r) {
  return Function.prototype.apply.call(t, e, r);
}, o_;
vo && typeof vo.ownKeys == "function" ? o_ = vo.ownKeys : Object.getOwnPropertySymbols ? o_ = function(t) {
  return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
} : o_ = function(t) {
  return Object.getOwnPropertyNames(t);
};
function d2(n) {
  console && console.warn && console.warn(n);
}
var $0 = Number.isNaN || function(t) {
  return t !== t;
};
function Lt() {
  Lt.init.call(this);
}
Zf.exports = Lt;
Zf.exports.once = b2;
Lt.EventEmitter = Lt;
Lt.prototype._events = void 0;
Lt.prototype._eventsCount = 0;
Lt.prototype._maxListeners = void 0;
var Bp = 10;
function nl(n) {
  if (typeof n != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof n);
}
Object.defineProperty(Lt, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return Bp;
  },
  set: function(n) {
    if (typeof n != "number" || n < 0 || $0(n))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + n + ".");
    Bp = n;
  }
});
Lt.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
Lt.prototype.setMaxListeners = function(t) {
  if (typeof t != "number" || t < 0 || $0(t))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
  return this._maxListeners = t, this;
};
function q0(n) {
  return n._maxListeners === void 0 ? Lt.defaultMaxListeners : n._maxListeners;
}
Lt.prototype.getMaxListeners = function() {
  return q0(this);
};
Lt.prototype.emit = function(t) {
  for (var e = [], r = 1; r < arguments.length; r++) e.push(arguments[r]);
  var i = t === "error", s = this._events;
  if (s !== void 0)
    i = i && s.error === void 0;
  else if (!i)
    return !1;
  if (i) {
    var a;
    if (e.length > 0 && (a = e[0]), a instanceof Error)
      throw a;
    var c = new Error("Unhandled error." + (a ? " (" + a.message + ")" : ""));
    throw c.context = a, c;
  }
  var _ = s[t];
  if (_ === void 0)
    return !1;
  if (typeof _ == "function")
    xp(_, this, e);
  else
    for (var p = _.length, f = ry(_, p), r = 0; r < p; ++r)
      xp(f[r], this, e);
  return !0;
};
function Z0(n, t, e, r) {
  var i, s, a;
  if (nl(e), s = n._events, s === void 0 ? (s = n._events = /* @__PURE__ */ Object.create(null), n._eventsCount = 0) : (s.newListener !== void 0 && (n.emit(
    "newListener",
    t,
    e.listener ? e.listener : e
  ), s = n._events), a = s[t]), a === void 0)
    a = s[t] = e, ++n._eventsCount;
  else if (typeof a == "function" ? a = s[t] = r ? [e, a] : [a, e] : r ? a.unshift(e) : a.push(e), i = q0(n), i > 0 && a.length > i && !a.warned) {
    a.warned = !0;
    var c = new Error("Possible EventEmitter memory leak detected. " + a.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    c.name = "MaxListenersExceededWarning", c.emitter = n, c.type = t, c.count = a.length, d2(c);
  }
  return n;
}
Lt.prototype.addListener = function(t, e) {
  return Z0(this, t, e, !1);
};
Lt.prototype.on = Lt.prototype.addListener;
Lt.prototype.prependListener = function(t, e) {
  return Z0(this, t, e, !0);
};
function w2() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function X0(n, t, e) {
  var r = { fired: !1, wrapFn: void 0, target: n, type: t, listener: e }, i = w2.bind(r);
  return i.listener = e, r.wrapFn = i, i;
}
Lt.prototype.once = function(t, e) {
  return nl(e), this.on(t, X0(this, t, e)), this;
};
Lt.prototype.prependOnceListener = function(t, e) {
  return nl(e), this.prependListener(t, X0(this, t, e)), this;
};
Lt.prototype.removeListener = function(t, e) {
  var r, i, s, a, c;
  if (nl(e), i = this._events, i === void 0)
    return this;
  if (r = i[t], r === void 0)
    return this;
  if (r === e || r.listener === e)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i[t], i.removeListener && this.emit("removeListener", t, r.listener || e));
  else if (typeof r != "function") {
    for (s = -1, a = r.length - 1; a >= 0; a--)
      if (r[a] === e || r[a].listener === e) {
        c = r[a].listener, s = a;
        break;
      }
    if (s < 0)
      return this;
    s === 0 ? r.shift() : g2(r, s), r.length === 1 && (i[t] = r[0]), i.removeListener !== void 0 && this.emit("removeListener", t, c || e);
  }
  return this;
};
Lt.prototype.off = Lt.prototype.removeListener;
Lt.prototype.removeAllListeners = function(t) {
  var e, r, i;
  if (r = this._events, r === void 0)
    return this;
  if (r.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : r[t] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete r[t]), this;
  if (arguments.length === 0) {
    var s = Object.keys(r), a;
    for (i = 0; i < s.length; ++i)
      a = s[i], a !== "removeListener" && this.removeAllListeners(a);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (e = r[t], typeof e == "function")
    this.removeListener(t, e);
  else if (e !== void 0)
    for (i = e.length - 1; i >= 0; i--)
      this.removeListener(t, e[i]);
  return this;
};
function ty(n, t, e) {
  var r = n._events;
  if (r === void 0)
    return [];
  var i = r[t];
  return i === void 0 ? [] : typeof i == "function" ? e ? [i.listener || i] : [i] : e ? y2(i) : ry(i, i.length);
}
Lt.prototype.listeners = function(t) {
  return ty(this, t, !0);
};
Lt.prototype.rawListeners = function(t) {
  return ty(this, t, !1);
};
Lt.listenerCount = function(n, t) {
  return typeof n.listenerCount == "function" ? n.listenerCount(t) : ey.call(n, t);
};
Lt.prototype.listenerCount = ey;
function ey(n) {
  var t = this._events;
  if (t !== void 0) {
    var e = t[n];
    if (typeof e == "function")
      return 1;
    if (e !== void 0)
      return e.length;
  }
  return 0;
}
Lt.prototype.eventNames = function() {
  return this._eventsCount > 0 ? o_(this._events) : [];
};
function ry(n, t) {
  for (var e = new Array(t), r = 0; r < t; ++r)
    e[r] = n[r];
  return e;
}
function g2(n, t) {
  for (; t + 1 < n.length; t++)
    n[t] = n[t + 1];
  n.pop();
}
function y2(n) {
  for (var t = new Array(n.length), e = 0; e < t.length; ++e)
    t[e] = n[e].listener || n[e];
  return t;
}
function b2(n, t) {
  return new Promise(function(e, r) {
    function i(a) {
      n.removeListener(t, s), r(a);
    }
    function s() {
      typeof n.removeListener == "function" && n.removeListener("error", i), e([].slice.call(arguments));
    }
    ny(n, t, s, { once: !0 }), t !== "error" && A2(n, i, { once: !0 });
  });
}
function A2(n, t, e) {
  typeof n.on == "function" && ny(n, "error", t, e);
}
function ny(n, t, e, r) {
  if (typeof n.on == "function")
    r.once ? n.once(t, e) : n.on(t, e);
  else if (typeof n.addEventListener == "function")
    n.addEventListener(t, function i(s) {
      r.once && n.removeEventListener(t, i), e(s);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof n);
}
var iy = Zf.exports, sy = iy.EventEmitter;
const il = /* @__PURE__ */ i2(Mb);
var Xf = {}, oy = {}, ay = function() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var t = {}, e = Symbol("test"), r = Object(e);
  if (typeof e == "string" || Object.prototype.toString.call(e) !== "[object Symbol]" || Object.prototype.toString.call(r) !== "[object Symbol]")
    return !1;
  var i = 42;
  t[e] = i;
  for (var s in t)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0)
    return !1;
  var a = Object.getOwnPropertySymbols(t);
  if (a.length !== 1 || a[0] !== e || !Object.prototype.propertyIsEnumerable.call(t, e))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var c = (
      /** @type {PropertyDescriptor} */
      Object.getOwnPropertyDescriptor(t, e)
    );
    if (c.value !== i || c.enumerable !== !0)
      return !1;
  }
  return !0;
}, m2 = ay, th = function() {
  return m2() && !!Symbol.toStringTag;
}, S2 = Object, E2 = Error, R2 = EvalError, P2 = RangeError, v2 = ReferenceError, cy = SyntaxError, sl = TypeError, M2 = URIError, x2 = Math.abs, B2 = Math.floor, C2 = Math.max, I2 = Math.min, N2 = Math.pow, O2 = Object.getOwnPropertyDescriptor, a_ = O2;
if (a_)
  try {
    a_([], "length");
  } catch {
    a_ = null;
  }
var Oc = a_, c_ = Object.defineProperty || !1;
if (c_)
  try {
    c_({}, "a", { value: 1 });
  } catch {
    c_ = !1;
  }
var ol = c_, pu, Cp;
function T2() {
  if (Cp) return pu;
  Cp = 1;
  var n = typeof Symbol < "u" && Symbol, t = ay;
  return pu = function() {
    return typeof n != "function" || typeof Symbol != "function" || typeof n("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : t();
  }, pu;
}
var z2 = "Function.prototype.bind called on incompatible ", k2 = Object.prototype.toString, U2 = Math.max, F2 = "[object Function]", Ip = function(t, e) {
  for (var r = [], i = 0; i < t.length; i += 1)
    r[i] = t[i];
  for (var s = 0; s < e.length; s += 1)
    r[s + t.length] = e[s];
  return r;
}, G2 = function(t, e) {
  for (var r = [], i = e, s = 0; i < t.length; i += 1, s += 1)
    r[s] = t[i];
  return r;
}, L2 = function(n, t) {
  for (var e = "", r = 0; r < n.length; r += 1)
    e += n[r], r + 1 < n.length && (e += t);
  return e;
}, D2 = function(t) {
  var e = this;
  if (typeof e != "function" || k2.apply(e) !== F2)
    throw new TypeError(z2 + e);
  for (var r = G2(arguments, 1), i, s = function() {
    if (this instanceof i) {
      var f = e.apply(
        this,
        Ip(r, arguments)
      );
      return Object(f) === f ? f : this;
    }
    return e.apply(
      t,
      Ip(r, arguments)
    );
  }, a = U2(0, e.length - r.length), c = [], _ = 0; _ < a; _++)
    c[_] = "$" + _;
  if (i = Function("binder", "return function (" + L2(c, ",") + "){ return binder.apply(this,arguments); }")(s), e.prototype) {
    var p = function() {
    };
    p.prototype = e.prototype, i.prototype = new p(), p.prototype = null;
  }
  return i;
}, K2 = D2, Tc = Function.prototype.bind || K2, eh = Function.prototype.call, rh = Function.prototype.apply, V2 = typeof Reflect < "u" && Reflect && Reflect.apply, j2 = Tc, H2 = rh, Y2 = eh, Q2 = V2, _y = Q2 || j2.call(Y2, H2), W2 = Tc, J2 = sl, $2 = eh, q2 = _y, ly = function(t) {
  if (t.length < 1 || typeof t[0] != "function")
    throw new J2("a function is required");
  return q2(W2, $2, t);
}, du, Np;
function Z2() {
  if (Np) return du;
  Np = 1;
  var n = ly, t = Oc, e = (
    /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype
  ), r = e && t && t(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  ), i = Object, s = i.getPrototypeOf;
  return du = r && typeof r.get == "function" ? n([r.get]) : typeof s == "function" ? (
    /** @type {import('./get')} */
    function(c) {
      return s(c == null ? c : i(c));
    }
  ) : !1, du;
}
var wu, Op;
function X2() {
  if (Op) return wu;
  Op = 1;
  var n = Function.prototype.call, t = Object.prototype.hasOwnProperty, e = Tc;
  return wu = e.call(n, t), wu;
}
var Bt, uy = S2, tE = E2, eE = R2, rE = P2, nE = v2, xa = cy, Mo = sl, iE = M2, sE = x2, oE = B2, aE = C2, cE = I2, _E = N2, fy = Function, gu = function(n) {
  try {
    return fy('"use strict"; return (' + n + ").constructor;")();
  } catch {
  }
}, lc = Oc, lE = ol, yu = function() {
  throw new Mo();
}, uE = lc ? function() {
  try {
    return arguments.callee, yu;
  } catch {
    try {
      return lc(arguments, "callee").get;
    } catch {
      return yu;
    }
  }
}() : yu, xs = T2()(), fE = Z2(), oe = typeof Reflect == "function" && Reflect.getPrototypeOf || uy.getPrototypeOf || fE, hy = rh, zc = eh, Ts = {}, hE = typeof Uint8Array > "u" || !oe ? Bt : oe(Uint8Array), ls = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError > "u" ? Bt : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? Bt : ArrayBuffer,
  "%ArrayIteratorPrototype%": xs && oe ? oe([][Symbol.iterator]()) : Bt,
  "%AsyncFromSyncIteratorPrototype%": Bt,
  "%AsyncFunction%": Ts,
  "%AsyncGenerator%": Ts,
  "%AsyncGeneratorFunction%": Ts,
  "%AsyncIteratorPrototype%": Ts,
  "%Atomics%": typeof Atomics > "u" ? Bt : Atomics,
  "%BigInt%": typeof BigInt > "u" ? Bt : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? Bt : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? Bt : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? Bt : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": tE,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": eE,
  "%Float32Array%": typeof Float32Array > "u" ? Bt : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? Bt : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? Bt : FinalizationRegistry,
  "%Function%": fy,
  "%GeneratorFunction%": Ts,
  "%Int8Array%": typeof Int8Array > "u" ? Bt : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? Bt : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? Bt : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": xs && oe ? oe(oe([][Symbol.iterator]())) : Bt,
  "%JSON%": typeof JSON == "object" ? JSON : Bt,
  "%Map%": typeof Map > "u" ? Bt : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !xs || !oe ? Bt : oe((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": uy,
  "%Object.getOwnPropertyDescriptor%": lc,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? Bt : Promise,
  "%Proxy%": typeof Proxy > "u" ? Bt : Proxy,
  "%RangeError%": rE,
  "%ReferenceError%": nE,
  "%Reflect%": typeof Reflect > "u" ? Bt : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? Bt : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !xs || !oe ? Bt : oe((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? Bt : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": xs && oe ? oe(""[Symbol.iterator]()) : Bt,
  "%Symbol%": xs ? Symbol : Bt,
  "%SyntaxError%": xa,
  "%ThrowTypeError%": uE,
  "%TypedArray%": hE,
  "%TypeError%": Mo,
  "%Uint8Array%": typeof Uint8Array > "u" ? Bt : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? Bt : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? Bt : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? Bt : Uint32Array,
  "%URIError%": iE,
  "%WeakMap%": typeof WeakMap > "u" ? Bt : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? Bt : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? Bt : WeakSet,
  "%Function.prototype.call%": zc,
  "%Function.prototype.apply%": hy,
  "%Object.defineProperty%": lE,
  "%Math.abs%": sE,
  "%Math.floor%": oE,
  "%Math.max%": aE,
  "%Math.min%": cE,
  "%Math.pow%": _E
};
if (oe)
  try {
    null.error;
  } catch (n) {
    var pE = oe(oe(n));
    ls["%Error.prototype%"] = pE;
  }
var dE = function n(t) {
  var e;
  if (t === "%AsyncFunction%")
    e = gu("async function () {}");
  else if (t === "%GeneratorFunction%")
    e = gu("function* () {}");
  else if (t === "%AsyncGeneratorFunction%")
    e = gu("async function* () {}");
  else if (t === "%AsyncGenerator%") {
    var r = n("%AsyncGeneratorFunction%");
    r && (e = r.prototype);
  } else if (t === "%AsyncIteratorPrototype%") {
    var i = n("%AsyncGenerator%");
    i && oe && (e = oe(i.prototype));
  }
  return ls[t] = e, e;
}, Tp = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, kc = Tc, M_ = X2(), wE = kc.call(zc, Array.prototype.concat), gE = kc.call(hy, Array.prototype.splice), zp = kc.call(zc, String.prototype.replace), x_ = kc.call(zc, String.prototype.slice), yE = kc.call(zc, RegExp.prototype.exec), bE = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, AE = /\\(\\)?/g, mE = function(t) {
  var e = x_(t, 0, 1), r = x_(t, -1);
  if (e === "%" && r !== "%")
    throw new xa("invalid intrinsic syntax, expected closing `%`");
  if (r === "%" && e !== "%")
    throw new xa("invalid intrinsic syntax, expected opening `%`");
  var i = [];
  return zp(t, bE, function(s, a, c, _) {
    i[i.length] = c ? zp(_, AE, "$1") : a || s;
  }), i;
}, SE = function(t, e) {
  var r = t, i;
  if (M_(Tp, r) && (i = Tp[r], r = "%" + i[0] + "%"), M_(ls, r)) {
    var s = ls[r];
    if (s === Ts && (s = dE(r)), typeof s > "u" && !e)
      throw new Mo("intrinsic " + t + " exists, but is not available. Please file an issue!");
    return {
      alias: i,
      name: r,
      value: s
    };
  }
  throw new xa("intrinsic " + t + " does not exist!");
}, nh = function(t, e) {
  if (typeof t != "string" || t.length === 0)
    throw new Mo("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof e != "boolean")
    throw new Mo('"allowMissing" argument must be a boolean');
  if (yE(/^%?[^%]*%?$/, t) === null)
    throw new xa("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var r = mE(t), i = r.length > 0 ? r[0] : "", s = SE("%" + i + "%", e), a = s.name, c = s.value, _ = !1, p = s.alias;
  p && (i = p[0], gE(r, wE([0, 1], p)));
  for (var f = 1, d = !0; f < r.length; f += 1) {
    var y = r[f], b = x_(y, 0, 1), v = x_(y, -1);
    if ((b === '"' || b === "'" || b === "`" || v === '"' || v === "'" || v === "`") && b !== v)
      throw new xa("property names with quotes must have matching quotes");
    if ((y === "constructor" || !d) && (_ = !0), i += "." + y, a = "%" + i + "%", M_(ls, a))
      c = ls[a];
    else if (c != null) {
      if (!(y in c)) {
        if (!e)
          throw new Mo("base intrinsic for " + t + " exists, but the property is not available.");
        return;
      }
      if (lc && f + 1 >= r.length) {
        var R = lc(c, y);
        d = !!R, d && "get" in R && !("originalValue" in R.get) ? c = R.get : c = c[y];
      } else
        d = M_(c, y), c = c[y];
      d && !_ && (ls[a] = c);
    }
  }
  return c;
}, py = { exports: {} }, kp = ol, EE = cy, Bs = sl, Up = Oc, RE = function(t, e, r) {
  if (!t || typeof t != "object" && typeof t != "function")
    throw new Bs("`obj` must be an object or a function`");
  if (typeof e != "string" && typeof e != "symbol")
    throw new Bs("`property` must be a string or a symbol`");
  if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
    throw new Bs("`nonEnumerable`, if provided, must be a boolean or null");
  if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
    throw new Bs("`nonWritable`, if provided, must be a boolean or null");
  if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
    throw new Bs("`nonConfigurable`, if provided, must be a boolean or null");
  if (arguments.length > 6 && typeof arguments[6] != "boolean")
    throw new Bs("`loose`, if provided, must be a boolean");
  var i = arguments.length > 3 ? arguments[3] : null, s = arguments.length > 4 ? arguments[4] : null, a = arguments.length > 5 ? arguments[5] : null, c = arguments.length > 6 ? arguments[6] : !1, _ = !!Up && Up(t, e);
  if (kp)
    kp(t, e, {
      configurable: a === null && _ ? _.configurable : !a,
      enumerable: i === null && _ ? _.enumerable : !i,
      value: r,
      writable: s === null && _ ? _.writable : !s
    });
  else if (c || !i && !s && !a)
    t[e] = r;
  else
    throw new EE("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
}, yf = ol, dy = function() {
  return !!yf;
};
dy.hasArrayLengthDefineBug = function() {
  if (!yf)
    return null;
  try {
    return yf([], "length", { value: 1 }).length !== 1;
  } catch {
    return !0;
  }
};
var PE = dy, vE = nh, Fp = RE, ME = PE(), Gp = Oc, Lp = sl, xE = vE("%Math.floor%"), BE = function(t, e) {
  if (typeof t != "function")
    throw new Lp("`fn` is not a function");
  if (typeof e != "number" || e < 0 || e > 4294967295 || xE(e) !== e)
    throw new Lp("`length` must be a positive 32-bit integer");
  var r = arguments.length > 2 && !!arguments[2], i = !0, s = !0;
  if ("length" in t && Gp) {
    var a = Gp(t, "length");
    a && !a.configurable && (i = !1), a && !a.writable && (s = !1);
  }
  return (i || s || !r) && (ME ? Fp(
    /** @type {Parameters<define>[0]} */
    t,
    "length",
    e,
    !0,
    !0
  ) : Fp(
    /** @type {Parameters<define>[0]} */
    t,
    "length",
    e
  )), t;
}, CE = Tc, IE = rh, NE = _y, OE = function() {
  return NE(CE, IE, arguments);
};
(function(n) {
  var t = BE, e = ol, r = ly, i = OE;
  n.exports = function(a) {
    var c = r(arguments), _ = a.length - (arguments.length - 1);
    return t(
      c,
      1 + (_ > 0 ? _ : 0),
      !0
    );
  }, e ? e(n.exports, "apply", { value: i }) : n.exports.apply = i;
})(py);
var ih = py.exports, wy = nh, gy = ih, TE = gy(
  /** @type {typeof String.prototype.indexOf} */
  wy("String.prototype.indexOf")
), zE = function(t, e) {
  var r = (
    /** @type {Parameters<typeof callBind>[0]} */
    wy(t, !!e)
  );
  return typeof r == "function" && TE(t, ".prototype.") > -1 ? gy(r) : r;
}, kE = th(), UE = zE, bf = UE("Object.prototype.toString"), al = function(t) {
  return kE && t && typeof t == "object" && Symbol.toStringTag in t ? !1 : bf(t) === "[object Arguments]";
}, yy = function(t) {
  return al(t) ? !0 : t !== null && typeof t == "object" && "length" in t && typeof t.length == "number" && t.length >= 0 && bf(t) !== "[object Array]" && "callee" in t && bf(t.callee) === "[object Function]";
}, FE = function() {
  return al(arguments);
}();
al.isLegacyArguments = yy;
var GE = FE ? al : yy, LE = Object.prototype.toString, DE = Function.prototype.toString, KE = /^\s*(?:function)?\*/, by = th(), bu = Object.getPrototypeOf, VE = function() {
  if (!by)
    return !1;
  try {
    return Function("return function*() {}")();
  } catch {
  }
}, Au, jE = function(t) {
  if (typeof t != "function")
    return !1;
  if (KE.test(DE.call(t)))
    return !0;
  if (!by) {
    var e = LE.call(t);
    return e === "[object GeneratorFunction]";
  }
  if (!bu)
    return !1;
  if (typeof Au > "u") {
    var r = VE();
    Au = r ? bu(r) : !1;
  }
  return bu(t) === Au;
}, Ay = Function.prototype.toString, Fs = typeof Reflect == "object" && Reflect !== null && Reflect.apply, Af, __;
if (typeof Fs == "function" && typeof Object.defineProperty == "function")
  try {
    Af = Object.defineProperty({}, "length", {
      get: function() {
        throw __;
      }
    }), __ = {}, Fs(function() {
      throw 42;
    }, null, Af);
  } catch (n) {
    n !== __ && (Fs = null);
  }
else
  Fs = null;
var HE = /^\s*class\b/, mf = function(t) {
  try {
    var e = Ay.call(t);
    return HE.test(e);
  } catch {
    return !1;
  }
}, mu = function(t) {
  try {
    return mf(t) ? !1 : (Ay.call(t), !0);
  } catch {
    return !1;
  }
}, l_ = Object.prototype.toString, YE = "[object Object]", QE = "[object Function]", WE = "[object GeneratorFunction]", JE = "[object HTMLAllCollection]", $E = "[object HTML document.all class]", qE = "[object HTMLCollection]", ZE = typeof Symbol == "function" && !!Symbol.toStringTag, XE = !(0 in [,]), Sf = function() {
  return !1;
};
if (typeof document == "object") {
  var tR = document.all;
  l_.call(tR) === l_.call(document.all) && (Sf = function(t) {
    if ((XE || !t) && (typeof t > "u" || typeof t == "object"))
      try {
        var e = l_.call(t);
        return (e === JE || e === $E || e === qE || e === YE) && t("") == null;
      } catch {
      }
    return !1;
  });
}
var eR = Fs ? function(t) {
  if (Sf(t))
    return !0;
  if (!t || typeof t != "function" && typeof t != "object")
    return !1;
  try {
    Fs(t, null, Af);
  } catch (e) {
    if (e !== __)
      return !1;
  }
  return !mf(t) && mu(t);
} : function(t) {
  if (Sf(t))
    return !0;
  if (!t || typeof t != "function" && typeof t != "object")
    return !1;
  if (ZE)
    return mu(t);
  if (mf(t))
    return !1;
  var e = l_.call(t);
  return e !== QE && e !== WE && !/^\[object HTML/.test(e) ? !1 : mu(t);
}, rR = eR, nR = Object.prototype.toString, my = Object.prototype.hasOwnProperty, iR = function(t, e, r) {
  for (var i = 0, s = t.length; i < s; i++)
    my.call(t, i) && (r == null ? e(t[i], i, t) : e.call(r, t[i], i, t));
}, sR = function(t, e, r) {
  for (var i = 0, s = t.length; i < s; i++)
    r == null ? e(t.charAt(i), i, t) : e.call(r, t.charAt(i), i, t);
}, oR = function(t, e, r) {
  for (var i in t)
    my.call(t, i) && (r == null ? e(t[i], i, t) : e.call(r, t[i], i, t));
}, aR = function(t, e, r) {
  if (!rR(e))
    throw new TypeError("iterator must be a function");
  var i;
  arguments.length >= 3 && (i = r), nR.call(t) === "[object Array]" ? iR(t, e, i) : typeof t == "string" ? sR(t, e, i) : oR(t, e, i);
}, cR = aR, _R = [
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Int16Array",
  "Int32Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array"
], Su = _R, lR = typeof globalThis > "u" ? Fn : globalThis, uR = function() {
  for (var t = [], e = 0; e < Su.length; e++)
    typeof lR[Su[e]] == "function" && (t[t.length] = Su[e]);
  return t;
}, Sy = nh, Ey = ih, fR = Ey(Sy("String.prototype.indexOf")), hR = function(t, e) {
  var r = Sy(t, !!e);
  return typeof r == "function" && fR(t, ".prototype.") > -1 ? Ey(r) : r;
}, B_ = cR, pR = uR, Dp = ih, sh = hR, u_ = Oc, dR = sh("Object.prototype.toString"), Ry = th(), Kp = typeof globalThis > "u" ? Fn : globalThis, Ef = pR(), oh = sh("String.prototype.slice"), Eu = Object.getPrototypeOf, wR = sh("Array.prototype.indexOf", !0) || function(t, e) {
  for (var r = 0; r < t.length; r += 1)
    if (t[r] === e)
      return r;
  return -1;
}, C_ = { __proto__: null };
Ry && u_ && Eu ? B_(Ef, function(n) {
  var t = new Kp[n]();
  if (Symbol.toStringTag in t) {
    var e = Eu(t), r = u_(e, Symbol.toStringTag);
    if (!r) {
      var i = Eu(e);
      r = u_(i, Symbol.toStringTag);
    }
    C_["$" + n] = Dp(r.get);
  }
}) : B_(Ef, function(n) {
  var t = new Kp[n](), e = t.slice || t.set;
  e && (C_["$" + n] = Dp(e));
});
var gR = function(t) {
  var e = !1;
  return B_(
    // eslint-disable-next-line no-extra-parens
    /** @type {Record<`\$${TypedArrayName}`, Getter>} */
    /** @type {any} */
    C_,
    /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
    function(r, i) {
      if (!e)
        try {
          "$" + r(t) === i && (e = oh(i, 1));
        } catch {
        }
    }
  ), e;
}, yR = function(t) {
  var e = !1;
  return B_(
    // eslint-disable-next-line no-extra-parens
    /** @type {Record<`\$${TypedArrayName}`, Getter>} */
    /** @type {any} */
    C_,
    /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */
    function(r, i) {
      if (!e)
        try {
          r(t), e = oh(i, 1);
        } catch {
        }
    }
  ), e;
}, Py = function(t) {
  if (!t || typeof t != "object")
    return !1;
  if (!Ry) {
    var e = oh(dR(t), 8, -1);
    return wR(Ef, e) > -1 ? e : e !== "Object" ? !1 : yR(t);
  }
  return u_ ? gR(t) : null;
}, bR = Py, AR = function(t) {
  return !!bR(t);
};
(function(n) {
  var t = GE, e = jE, r = Py, i = AR;
  function s(Z) {
    return Z.call.bind(Z);
  }
  var a = typeof BigInt < "u", c = typeof Symbol < "u", _ = s(Object.prototype.toString), p = s(Number.prototype.valueOf), f = s(String.prototype.valueOf), d = s(Boolean.prototype.valueOf);
  if (a)
    var y = s(BigInt.prototype.valueOf);
  if (c)
    var b = s(Symbol.prototype.valueOf);
  function v(Z, tr) {
    if (typeof Z != "object")
      return !1;
    try {
      return tr(Z), !0;
    } catch {
      return !1;
    }
  }
  n.isArgumentsObject = t, n.isGeneratorFunction = e, n.isTypedArray = i;
  function R(Z) {
    return typeof Promise < "u" && Z instanceof Promise || Z !== null && typeof Z == "object" && typeof Z.then == "function" && typeof Z.catch == "function";
  }
  n.isPromise = R;
  function M(Z) {
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(Z) : i(Z) || Y(Z);
  }
  n.isArrayBufferView = M;
  function A(Z) {
    return r(Z) === "Uint8Array";
  }
  n.isUint8Array = A;
  function B(Z) {
    return r(Z) === "Uint8ClampedArray";
  }
  n.isUint8ClampedArray = B;
  function N(Z) {
    return r(Z) === "Uint16Array";
  }
  n.isUint16Array = N;
  function G(Z) {
    return r(Z) === "Uint32Array";
  }
  n.isUint32Array = G;
  function D(Z) {
    return r(Z) === "Int8Array";
  }
  n.isInt8Array = D;
  function $(Z) {
    return r(Z) === "Int16Array";
  }
  n.isInt16Array = $;
  function X(Z) {
    return r(Z) === "Int32Array";
  }
  n.isInt32Array = X;
  function V(Z) {
    return r(Z) === "Float32Array";
  }
  n.isFloat32Array = V;
  function nt(Z) {
    return r(Z) === "Float64Array";
  }
  n.isFloat64Array = nt;
  function ft(Z) {
    return r(Z) === "BigInt64Array";
  }
  n.isBigInt64Array = ft;
  function pt(Z) {
    return r(Z) === "BigUint64Array";
  }
  n.isBigUint64Array = pt;
  function At(Z) {
    return _(Z) === "[object Map]";
  }
  At.working = typeof Map < "u" && At(/* @__PURE__ */ new Map());
  function Nt(Z) {
    return typeof Map > "u" ? !1 : At.working ? At(Z) : Z instanceof Map;
  }
  n.isMap = Nt;
  function kt(Z) {
    return _(Z) === "[object Set]";
  }
  kt.working = typeof Set < "u" && kt(/* @__PURE__ */ new Set());
  function it(Z) {
    return typeof Set > "u" ? !1 : kt.working ? kt(Z) : Z instanceof Set;
  }
  n.isSet = it;
  function ot(Z) {
    return _(Z) === "[object WeakMap]";
  }
  ot.working = typeof WeakMap < "u" && ot(/* @__PURE__ */ new WeakMap());
  function dt(Z) {
    return typeof WeakMap > "u" ? !1 : ot.working ? ot(Z) : Z instanceof WeakMap;
  }
  n.isWeakMap = dt;
  function bt(Z) {
    return _(Z) === "[object WeakSet]";
  }
  bt.working = typeof WeakSet < "u" && bt(/* @__PURE__ */ new WeakSet());
  function yt(Z) {
    return bt(Z);
  }
  n.isWeakSet = yt;
  function It(Z) {
    return _(Z) === "[object ArrayBuffer]";
  }
  It.working = typeof ArrayBuffer < "u" && It(new ArrayBuffer());
  function Dt(Z) {
    return typeof ArrayBuffer > "u" ? !1 : It.working ? It(Z) : Z instanceof ArrayBuffer;
  }
  n.isArrayBuffer = Dt;
  function k(Z) {
    return _(Z) === "[object DataView]";
  }
  k.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && k(new DataView(new ArrayBuffer(1), 0, 1));
  function Y(Z) {
    return typeof DataView > "u" ? !1 : k.working ? k(Z) : Z instanceof DataView;
  }
  n.isDataView = Y;
  var Q = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
  function _t(Z) {
    return _(Z) === "[object SharedArrayBuffer]";
  }
  function O(Z) {
    return typeof Q > "u" ? !1 : (typeof _t.working > "u" && (_t.working = _t(new Q())), _t.working ? _t(Z) : Z instanceof Q);
  }
  n.isSharedArrayBuffer = O;
  function I(Z) {
    return _(Z) === "[object AsyncFunction]";
  }
  n.isAsyncFunction = I;
  function H(Z) {
    return _(Z) === "[object Map Iterator]";
  }
  n.isMapIterator = H;
  function rt(Z) {
    return _(Z) === "[object Set Iterator]";
  }
  n.isSetIterator = rt;
  function at(Z) {
    return _(Z) === "[object Generator]";
  }
  n.isGeneratorObject = at;
  function m(Z) {
    return _(Z) === "[object WebAssembly.Module]";
  }
  n.isWebAssemblyCompiledModule = m;
  function E(Z) {
    return v(Z, p);
  }
  n.isNumberObject = E;
  function J(Z) {
    return v(Z, f);
  }
  n.isStringObject = J;
  function st(Z) {
    return v(Z, d);
  }
  n.isBooleanObject = st;
  function xt(Z) {
    return a && v(Z, y);
  }
  n.isBigIntObject = xt;
  function wt(Z) {
    return c && v(Z, b);
  }
  n.isSymbolObject = wt;
  function Pt(Z) {
    return E(Z) || J(Z) || st(Z) || xt(Z) || wt(Z);
  }
  n.isBoxedPrimitive = Pt;
  function Ce(Z) {
    return typeof Uint8Array < "u" && (Dt(Z) || O(Z));
  }
  n.isAnyArrayBuffer = Ce, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(Z) {
    Object.defineProperty(n, Z, {
      enumerable: !1,
      value: function() {
        throw new Error(Z + " is not supported in userland");
      }
    });
  });
})(oy);
var mR = function(t) {
  return t && typeof t == "object" && typeof t.copy == "function" && typeof t.fill == "function" && typeof t.readUInt8 == "function";
}, Rf = { exports: {} };
typeof Object.create == "function" ? Rf.exports = function(t, e) {
  e && (t.super_ = e, t.prototype = Object.create(e.prototype, {
    constructor: {
      value: t,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : Rf.exports = function(t, e) {
  if (e) {
    t.super_ = e;
    var r = function() {
    };
    r.prototype = e.prototype, t.prototype = new r(), t.prototype.constructor = t;
  }
};
var Na = Rf.exports;
(function(n) {
  var t = Object.getOwnPropertyDescriptors || function(Y) {
    for (var Q = Object.keys(Y), _t = {}, O = 0; O < Q.length; O++)
      _t[Q[O]] = Object.getOwnPropertyDescriptor(Y, Q[O]);
    return _t;
  }, e = /%[sdj%]/g;
  n.format = function(k) {
    if (!D(k)) {
      for (var Y = [], Q = 0; Q < arguments.length; Q++)
        Y.push(a(arguments[Q]));
      return Y.join(" ");
    }
    for (var Q = 1, _t = arguments, O = _t.length, I = String(k).replace(e, function(rt) {
      if (rt === "%%") return "%";
      if (Q >= O) return rt;
      switch (rt) {
        case "%s":
          return String(_t[Q++]);
        case "%d":
          return Number(_t[Q++]);
        case "%j":
          try {
            return JSON.stringify(_t[Q++]);
          } catch {
            return "[Circular]";
          }
        default:
          return rt;
      }
    }), H = _t[Q]; Q < O; H = _t[++Q])
      B(H) || !nt(H) ? I += " " + H : I += " " + a(H);
    return I;
  }, n.deprecate = function(k, Y) {
    if (typeof vt < "u" && vt.noDeprecation === !0)
      return k;
    if (typeof vt > "u")
      return function() {
        return n.deprecate(k, Y).apply(this, arguments);
      };
    var Q = !1;
    function _t() {
      if (!Q) {
        if (vt.throwDeprecation)
          throw new Error(Y);
        vt.traceDeprecation ? console.trace(Y) : console.error(Y), Q = !0;
      }
      return k.apply(this, arguments);
    }
    return _t;
  };
  var r = {}, i = /^$/;
  if (vt.env.NODE_DEBUG) {
    var s = vt.env.NODE_DEBUG;
    s = s.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), i = new RegExp("^" + s + "$", "i");
  }
  n.debuglog = function(k) {
    if (k = k.toUpperCase(), !r[k])
      if (i.test(k)) {
        var Y = vt.pid;
        r[k] = function() {
          var Q = n.format.apply(n, arguments);
          console.error("%s %d: %s", k, Y, Q);
        };
      } else
        r[k] = function() {
        };
    return r[k];
  };
  function a(k, Y) {
    var Q = {
      seen: [],
      stylize: _
    };
    return arguments.length >= 3 && (Q.depth = arguments[2]), arguments.length >= 4 && (Q.colors = arguments[3]), A(Y) ? Q.showHidden = Y : Y && n._extend(Q, Y), X(Q.showHidden) && (Q.showHidden = !1), X(Q.depth) && (Q.depth = 2), X(Q.colors) && (Q.colors = !1), X(Q.customInspect) && (Q.customInspect = !0), Q.colors && (Q.stylize = c), f(Q, k, Q.depth);
  }
  n.inspect = a, a.colors = {
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    white: [37, 39],
    grey: [90, 39],
    black: [30, 39],
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [31, 39],
    yellow: [33, 39]
  }, a.styles = {
    special: "cyan",
    number: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    date: "magenta",
    // "name": intentionally not styling
    regexp: "red"
  };
  function c(k, Y) {
    var Q = a.styles[Y];
    return Q ? "\x1B[" + a.colors[Q][0] + "m" + k + "\x1B[" + a.colors[Q][1] + "m" : k;
  }
  function _(k, Y) {
    return k;
  }
  function p(k) {
    var Y = {};
    return k.forEach(function(Q, _t) {
      Y[Q] = !0;
    }), Y;
  }
  function f(k, Y, Q) {
    if (k.customInspect && Y && At(Y.inspect) && // Filter out the util module, it's inspect function is special
    Y.inspect !== n.inspect && // Also filter out any prototype objects using the circular check.
    !(Y.constructor && Y.constructor.prototype === Y)) {
      var _t = Y.inspect(Q, k);
      return D(_t) || (_t = f(k, _t, Q)), _t;
    }
    var O = d(k, Y);
    if (O)
      return O;
    var I = Object.keys(Y), H = p(I);
    if (k.showHidden && (I = Object.getOwnPropertyNames(Y)), pt(Y) && (I.indexOf("message") >= 0 || I.indexOf("description") >= 0))
      return y(Y);
    if (I.length === 0) {
      if (At(Y)) {
        var rt = Y.name ? ": " + Y.name : "";
        return k.stylize("[Function" + rt + "]", "special");
      }
      if (V(Y))
        return k.stylize(RegExp.prototype.toString.call(Y), "regexp");
      if (ft(Y))
        return k.stylize(Date.prototype.toString.call(Y), "date");
      if (pt(Y))
        return y(Y);
    }
    var at = "", m = !1, E = ["{", "}"];
    if (M(Y) && (m = !0, E = ["[", "]"]), At(Y)) {
      var J = Y.name ? ": " + Y.name : "";
      at = " [Function" + J + "]";
    }
    if (V(Y) && (at = " " + RegExp.prototype.toString.call(Y)), ft(Y) && (at = " " + Date.prototype.toUTCString.call(Y)), pt(Y) && (at = " " + y(Y)), I.length === 0 && (!m || Y.length == 0))
      return E[0] + at + E[1];
    if (Q < 0)
      return V(Y) ? k.stylize(RegExp.prototype.toString.call(Y), "regexp") : k.stylize("[Object]", "special");
    k.seen.push(Y);
    var st;
    return m ? st = b(k, Y, Q, H, I) : st = I.map(function(xt) {
      return v(k, Y, Q, H, xt, m);
    }), k.seen.pop(), R(st, at, E);
  }
  function d(k, Y) {
    if (X(Y))
      return k.stylize("undefined", "undefined");
    if (D(Y)) {
      var Q = "'" + JSON.stringify(Y).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return k.stylize(Q, "string");
    }
    if (G(Y))
      return k.stylize("" + Y, "number");
    if (A(Y))
      return k.stylize("" + Y, "boolean");
    if (B(Y))
      return k.stylize("null", "null");
  }
  function y(k) {
    return "[" + Error.prototype.toString.call(k) + "]";
  }
  function b(k, Y, Q, _t, O) {
    for (var I = [], H = 0, rt = Y.length; H < rt; ++H)
      bt(Y, String(H)) ? I.push(v(
        k,
        Y,
        Q,
        _t,
        String(H),
        !0
      )) : I.push("");
    return O.forEach(function(at) {
      at.match(/^\d+$/) || I.push(v(
        k,
        Y,
        Q,
        _t,
        at,
        !0
      ));
    }), I;
  }
  function v(k, Y, Q, _t, O, I) {
    var H, rt, at;
    if (at = Object.getOwnPropertyDescriptor(Y, O) || { value: Y[O] }, at.get ? at.set ? rt = k.stylize("[Getter/Setter]", "special") : rt = k.stylize("[Getter]", "special") : at.set && (rt = k.stylize("[Setter]", "special")), bt(_t, O) || (H = "[" + O + "]"), rt || (k.seen.indexOf(at.value) < 0 ? (B(Q) ? rt = f(k, at.value, null) : rt = f(k, at.value, Q - 1), rt.indexOf(`
`) > -1 && (I ? rt = rt.split(`
`).map(function(m) {
      return "  " + m;
    }).join(`
`).slice(2) : rt = `
` + rt.split(`
`).map(function(m) {
      return "   " + m;
    }).join(`
`))) : rt = k.stylize("[Circular]", "special")), X(H)) {
      if (I && O.match(/^\d+$/))
        return rt;
      H = JSON.stringify("" + O), H.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (H = H.slice(1, -1), H = k.stylize(H, "name")) : (H = H.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), H = k.stylize(H, "string"));
    }
    return H + ": " + rt;
  }
  function R(k, Y, Q) {
    var _t = k.reduce(function(O, I) {
      return I.indexOf(`
`) >= 0, O + I.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    return _t > 60 ? Q[0] + (Y === "" ? "" : Y + `
 `) + " " + k.join(`,
  `) + " " + Q[1] : Q[0] + Y + " " + k.join(", ") + " " + Q[1];
  }
  n.types = oy;
  function M(k) {
    return Array.isArray(k);
  }
  n.isArray = M;
  function A(k) {
    return typeof k == "boolean";
  }
  n.isBoolean = A;
  function B(k) {
    return k === null;
  }
  n.isNull = B;
  function N(k) {
    return k == null;
  }
  n.isNullOrUndefined = N;
  function G(k) {
    return typeof k == "number";
  }
  n.isNumber = G;
  function D(k) {
    return typeof k == "string";
  }
  n.isString = D;
  function $(k) {
    return typeof k == "symbol";
  }
  n.isSymbol = $;
  function X(k) {
    return k === void 0;
  }
  n.isUndefined = X;
  function V(k) {
    return nt(k) && kt(k) === "[object RegExp]";
  }
  n.isRegExp = V, n.types.isRegExp = V;
  function nt(k) {
    return typeof k == "object" && k !== null;
  }
  n.isObject = nt;
  function ft(k) {
    return nt(k) && kt(k) === "[object Date]";
  }
  n.isDate = ft, n.types.isDate = ft;
  function pt(k) {
    return nt(k) && (kt(k) === "[object Error]" || k instanceof Error);
  }
  n.isError = pt, n.types.isNativeError = pt;
  function At(k) {
    return typeof k == "function";
  }
  n.isFunction = At;
  function Nt(k) {
    return k === null || typeof k == "boolean" || typeof k == "number" || typeof k == "string" || typeof k == "symbol" || // ES6 symbol
    typeof k > "u";
  }
  n.isPrimitive = Nt, n.isBuffer = mR;
  function kt(k) {
    return Object.prototype.toString.call(k);
  }
  function it(k) {
    return k < 10 ? "0" + k.toString(10) : k.toString(10);
  }
  var ot = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  function dt() {
    var k = /* @__PURE__ */ new Date(), Y = [
      it(k.getHours()),
      it(k.getMinutes()),
      it(k.getSeconds())
    ].join(":");
    return [k.getDate(), ot[k.getMonth()], Y].join(" ");
  }
  n.log = function() {
    console.log("%s - %s", dt(), n.format.apply(n, arguments));
  }, n.inherits = Na, n._extend = function(k, Y) {
    if (!Y || !nt(Y)) return k;
    for (var Q = Object.keys(Y), _t = Q.length; _t--; )
      k[Q[_t]] = Y[Q[_t]];
    return k;
  };
  function bt(k, Y) {
    return Object.prototype.hasOwnProperty.call(k, Y);
  }
  var yt = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
  n.promisify = function(Y) {
    if (typeof Y != "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (yt && Y[yt]) {
      var Q = Y[yt];
      if (typeof Q != "function")
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(Q, yt, {
        value: Q,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), Q;
    }
    function Q() {
      for (var _t, O, I = new Promise(function(at, m) {
        _t = at, O = m;
      }), H = [], rt = 0; rt < arguments.length; rt++)
        H.push(arguments[rt]);
      H.push(function(at, m) {
        at ? O(at) : _t(m);
      });
      try {
        Y.apply(this, H);
      } catch (at) {
        O(at);
      }
      return I;
    }
    return Object.setPrototypeOf(Q, Object.getPrototypeOf(Y)), yt && Object.defineProperty(Q, yt, {
      value: Q,
      enumerable: !1,
      writable: !1,
      configurable: !0
    }), Object.defineProperties(
      Q,
      t(Y)
    );
  }, n.promisify.custom = yt;
  function It(k, Y) {
    if (!k) {
      var Q = new Error("Promise was rejected with a falsy value");
      Q.reason = k, k = Q;
    }
    return Y(k);
  }
  function Dt(k) {
    if (typeof k != "function")
      throw new TypeError('The "original" argument must be of type Function');
    function Y() {
      for (var Q = [], _t = 0; _t < arguments.length; _t++)
        Q.push(arguments[_t]);
      var O = Q.pop();
      if (typeof O != "function")
        throw new TypeError("The last argument must be of type Function");
      var I = this, H = function() {
        return O.apply(I, arguments);
      };
      k.apply(this, Q).then(
        function(rt) {
          vt.nextTick(H.bind(null, null, rt));
        },
        function(rt) {
          vt.nextTick(It.bind(null, rt, H));
        }
      );
    }
    return Object.setPrototypeOf(Y, Object.getPrototypeOf(k)), Object.defineProperties(
      Y,
      t(k)
    ), Y;
  }
  n.callbackify = Dt;
})(Xf);
var Ru, Vp;
function SR() {
  if (Vp) return Ru;
  Vp = 1;
  function n(v, R) {
    var M = Object.keys(v);
    if (Object.getOwnPropertySymbols) {
      var A = Object.getOwnPropertySymbols(v);
      R && (A = A.filter(function(B) {
        return Object.getOwnPropertyDescriptor(v, B).enumerable;
      })), M.push.apply(M, A);
    }
    return M;
  }
  function t(v) {
    for (var R = 1; R < arguments.length; R++) {
      var M = arguments[R] != null ? arguments[R] : {};
      R % 2 ? n(Object(M), !0).forEach(function(A) {
        e(v, A, M[A]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(v, Object.getOwnPropertyDescriptors(M)) : n(Object(M)).forEach(function(A) {
        Object.defineProperty(v, A, Object.getOwnPropertyDescriptor(M, A));
      });
    }
    return v;
  }
  function e(v, R, M) {
    return R = a(R), R in v ? Object.defineProperty(v, R, { value: M, enumerable: !0, configurable: !0, writable: !0 }) : v[R] = M, v;
  }
  function r(v, R) {
    if (!(v instanceof R))
      throw new TypeError("Cannot call a class as a function");
  }
  function i(v, R) {
    for (var M = 0; M < R.length; M++) {
      var A = R[M];
      A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(v, a(A.key), A);
    }
  }
  function s(v, R, M) {
    return R && i(v.prototype, R), Object.defineProperty(v, "prototype", { writable: !1 }), v;
  }
  function a(v) {
    var R = c(v, "string");
    return typeof R == "symbol" ? R : String(R);
  }
  function c(v, R) {
    if (typeof v != "object" || v === null) return v;
    var M = v[Symbol.toPrimitive];
    if (M !== void 0) {
      var A = M.call(v, R || "default");
      if (typeof A != "object") return A;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (R === "string" ? String : Number)(v);
  }
  var _ = il, p = _.Buffer, f = Xf, d = f.inspect, y = d && d.custom || "inspect";
  function b(v, R, M) {
    p.prototype.copy.call(v, R, M);
  }
  return Ru = /* @__PURE__ */ function() {
    function v() {
      r(this, v), this.head = null, this.tail = null, this.length = 0;
    }
    return s(v, [{
      key: "push",
      value: function(M) {
        var A = {
          data: M,
          next: null
        };
        this.length > 0 ? this.tail.next = A : this.head = A, this.tail = A, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(M) {
        var A = {
          data: M,
          next: this.head
        };
        this.length === 0 && (this.tail = A), this.head = A, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var M = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, M;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(M) {
        if (this.length === 0) return "";
        for (var A = this.head, B = "" + A.data; A = A.next; ) B += M + A.data;
        return B;
      }
    }, {
      key: "concat",
      value: function(M) {
        if (this.length === 0) return p.alloc(0);
        for (var A = p.allocUnsafe(M >>> 0), B = this.head, N = 0; B; )
          b(B.data, A, N), N += B.data.length, B = B.next;
        return A;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(M, A) {
        var B;
        return M < this.head.data.length ? (B = this.head.data.slice(0, M), this.head.data = this.head.data.slice(M)) : M === this.head.data.length ? B = this.shift() : B = A ? this._getString(M) : this._getBuffer(M), B;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(M) {
        var A = this.head, B = 1, N = A.data;
        for (M -= N.length; A = A.next; ) {
          var G = A.data, D = M > G.length ? G.length : M;
          if (D === G.length ? N += G : N += G.slice(0, M), M -= D, M === 0) {
            D === G.length ? (++B, A.next ? this.head = A.next : this.head = this.tail = null) : (this.head = A, A.data = G.slice(D));
            break;
          }
          ++B;
        }
        return this.length -= B, N;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(M) {
        var A = p.allocUnsafe(M), B = this.head, N = 1;
        for (B.data.copy(A), M -= B.data.length; B = B.next; ) {
          var G = B.data, D = M > G.length ? G.length : M;
          if (G.copy(A, A.length - M, 0, D), M -= D, M === 0) {
            D === G.length ? (++N, B.next ? this.head = B.next : this.head = this.tail = null) : (this.head = B, B.data = G.slice(D));
            break;
          }
          ++N;
        }
        return this.length -= N, A;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: y,
      value: function(M, A) {
        return d(this, t(t({}, A), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), v;
  }(), Ru;
}
function ER(n, t) {
  var e = this, r = this._readableState && this._readableState.destroyed, i = this._writableState && this._writableState.destroyed;
  return r || i ? (t ? t(n) : n && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, vt.nextTick(Pf, this, n)) : vt.nextTick(Pf, this, n)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(n || null, function(s) {
    !t && s ? e._writableState ? e._writableState.errorEmitted ? vt.nextTick(f_, e) : (e._writableState.errorEmitted = !0, vt.nextTick(jp, e, s)) : vt.nextTick(jp, e, s) : t ? (vt.nextTick(f_, e), t(s)) : vt.nextTick(f_, e);
  }), this);
}
function jp(n, t) {
  Pf(n, t), f_(n);
}
function f_(n) {
  n._writableState && !n._writableState.emitClose || n._readableState && !n._readableState.emitClose || n.emit("close");
}
function RR() {
  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
}
function Pf(n, t) {
  n.emit("error", t);
}
function PR(n, t) {
  var e = n._readableState, r = n._writableState;
  e && e.autoDestroy || r && r.autoDestroy ? n.destroy(t) : n.emit("error", t);
}
var vy = {
  destroy: ER,
  undestroy: RR,
  errorOrDestroy: PR
}, Ss = {};
function vR(n, t) {
  n.prototype = Object.create(t.prototype), n.prototype.constructor = n, n.__proto__ = t;
}
var My = {};
function Xe(n, t, e) {
  e || (e = Error);
  function r(s, a, c) {
    return typeof t == "string" ? t : t(s, a, c);
  }
  var i = /* @__PURE__ */ function(s) {
    vR(a, s);
    function a(c, _, p) {
      return s.call(this, r(c, _, p)) || this;
    }
    return a;
  }(e);
  i.prototype.name = e.name, i.prototype.code = n, My[n] = i;
}
function Hp(n, t) {
  if (Array.isArray(n)) {
    var e = n.length;
    return n = n.map(function(r) {
      return String(r);
    }), e > 2 ? "one of ".concat(t, " ").concat(n.slice(0, e - 1).join(", "), ", or ") + n[e - 1] : e === 2 ? "one of ".concat(t, " ").concat(n[0], " or ").concat(n[1]) : "of ".concat(t, " ").concat(n[0]);
  } else
    return "of ".concat(t, " ").concat(String(n));
}
function MR(n, t, e) {
  return n.substr(0, t.length) === t;
}
function xR(n, t, e) {
  return (e === void 0 || e > n.length) && (e = n.length), n.substring(e - t.length, e) === t;
}
function BR(n, t, e) {
  return typeof e != "number" && (e = 0), e + t.length > n.length ? !1 : n.indexOf(t, e) !== -1;
}
Xe("ERR_INVALID_OPT_VALUE", function(n, t) {
  return 'The value "' + t + '" is invalid for option "' + n + '"';
}, TypeError);
Xe("ERR_INVALID_ARG_TYPE", function(n, t, e) {
  var r;
  typeof t == "string" && MR(t, "not ") ? (r = "must not be", t = t.replace(/^not /, "")) : r = "must be";
  var i;
  if (xR(n, " argument"))
    i = "The ".concat(n, " ").concat(r, " ").concat(Hp(t, "type"));
  else {
    var s = BR(n, ".") ? "property" : "argument";
    i = 'The "'.concat(n, '" ').concat(s, " ").concat(r, " ").concat(Hp(t, "type"));
  }
  return i += ". Received type ".concat(typeof e), i;
}, TypeError);
Xe("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
Xe("ERR_METHOD_NOT_IMPLEMENTED", function(n) {
  return "The " + n + " method is not implemented";
});
Xe("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
Xe("ERR_STREAM_DESTROYED", function(n) {
  return "Cannot call " + n + " after a stream was destroyed";
});
Xe("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
Xe("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
Xe("ERR_STREAM_WRITE_AFTER_END", "write after end");
Xe("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
Xe("ERR_UNKNOWN_ENCODING", function(n) {
  return "Unknown encoding: " + n;
}, TypeError);
Xe("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
Ss.codes = My;
var CR = Ss.codes.ERR_INVALID_OPT_VALUE;
function IR(n, t, e) {
  return n.highWaterMark != null ? n.highWaterMark : t ? n[e] : null;
}
function NR(n, t, e, r) {
  var i = IR(t, r, e);
  if (i != null) {
    if (!(isFinite(i) && Math.floor(i) === i) || i < 0) {
      var s = r ? e : "highWaterMark";
      throw new CR(s, i);
    }
    return Math.floor(i);
  }
  return n.objectMode ? 16 : 16 * 1024;
}
var xy = {
  getHighWaterMark: NR
}, OR = TR;
function TR(n, t) {
  if (Pu("noDeprecation"))
    return n;
  var e = !1;
  function r() {
    if (!e) {
      if (Pu("throwDeprecation"))
        throw new Error(t);
      Pu("traceDeprecation") ? console.trace(t) : console.warn(t), e = !0;
    }
    return n.apply(this, arguments);
  }
  return r;
}
function Pu(n) {
  try {
    if (!Fn.localStorage) return !1;
  } catch {
    return !1;
  }
  var t = Fn.localStorage[n];
  return t == null ? !1 : String(t).toLowerCase() === "true";
}
var vu, Yp;
function By() {
  if (Yp) return vu;
  Yp = 1, vu = V;
  function n(O) {
    var I = this;
    this.next = null, this.entry = null, this.finish = function() {
      _t(I, O);
    };
  }
  var t;
  V.WritableState = $;
  var e = {
    deprecate: OR
  }, r = sy, i = il.Buffer, s = (typeof Fn < "u" ? Fn : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function a(O) {
    return i.from(O);
  }
  function c(O) {
    return i.isBuffer(O) || O instanceof s;
  }
  var _ = vy, p = xy, f = p.getHighWaterMark, d = Ss.codes, y = d.ERR_INVALID_ARG_TYPE, b = d.ERR_METHOD_NOT_IMPLEMENTED, v = d.ERR_MULTIPLE_CALLBACK, R = d.ERR_STREAM_CANNOT_PIPE, M = d.ERR_STREAM_DESTROYED, A = d.ERR_STREAM_NULL_VALUES, B = d.ERR_STREAM_WRITE_AFTER_END, N = d.ERR_UNKNOWN_ENCODING, G = _.errorOrDestroy;
  Na(V, r);
  function D() {
  }
  function $(O, I, H) {
    t = t || Ba(), O = O || {}, typeof H != "boolean" && (H = I instanceof t), this.objectMode = !!O.objectMode, H && (this.objectMode = this.objectMode || !!O.writableObjectMode), this.highWaterMark = f(this, O, "writableHighWaterMark", H), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var rt = O.decodeStrings === !1;
    this.decodeStrings = !rt, this.defaultEncoding = O.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(at) {
      ot(I, at);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = O.emitClose !== !1, this.autoDestroy = !!O.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new n(this);
  }
  $.prototype.getBuffer = function() {
    for (var I = this.bufferedRequest, H = []; I; )
      H.push(I), I = I.next;
    return H;
  }, function() {
    try {
      Object.defineProperty($.prototype, "buffer", {
        get: e.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var X;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (X = Function.prototype[Symbol.hasInstance], Object.defineProperty(V, Symbol.hasInstance, {
    value: function(I) {
      return X.call(this, I) ? !0 : this !== V ? !1 : I && I._writableState instanceof $;
    }
  })) : X = function(I) {
    return I instanceof this;
  };
  function V(O) {
    t = t || Ba();
    var I = this instanceof t;
    if (!I && !X.call(V, this)) return new V(O);
    this._writableState = new $(O, this, I), this.writable = !0, O && (typeof O.write == "function" && (this._write = O.write), typeof O.writev == "function" && (this._writev = O.writev), typeof O.destroy == "function" && (this._destroy = O.destroy), typeof O.final == "function" && (this._final = O.final)), r.call(this);
  }
  V.prototype.pipe = function() {
    G(this, new R());
  };
  function nt(O, I) {
    var H = new B();
    G(O, H), vt.nextTick(I, H);
  }
  function ft(O, I, H, rt) {
    var at;
    return H === null ? at = new A() : typeof H != "string" && !I.objectMode && (at = new y("chunk", ["string", "Buffer"], H)), at ? (G(O, at), vt.nextTick(rt, at), !1) : !0;
  }
  V.prototype.write = function(O, I, H) {
    var rt = this._writableState, at = !1, m = !rt.objectMode && c(O);
    return m && !i.isBuffer(O) && (O = a(O)), typeof I == "function" && (H = I, I = null), m ? I = "buffer" : I || (I = rt.defaultEncoding), typeof H != "function" && (H = D), rt.ending ? nt(this, H) : (m || ft(this, rt, O, H)) && (rt.pendingcb++, at = At(this, rt, m, O, I, H)), at;
  }, V.prototype.cork = function() {
    this._writableState.corked++;
  }, V.prototype.uncork = function() {
    var O = this._writableState;
    O.corked && (O.corked--, !O.writing && !O.corked && !O.bufferProcessing && O.bufferedRequest && yt(this, O));
  }, V.prototype.setDefaultEncoding = function(I) {
    if (typeof I == "string" && (I = I.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((I + "").toLowerCase()) > -1)) throw new N(I);
    return this._writableState.defaultEncoding = I, this;
  }, Object.defineProperty(V.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function pt(O, I, H) {
    return !O.objectMode && O.decodeStrings !== !1 && typeof I == "string" && (I = i.from(I, H)), I;
  }
  Object.defineProperty(V.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function At(O, I, H, rt, at, m) {
    if (!H) {
      var E = pt(I, rt, at);
      rt !== E && (H = !0, at = "buffer", rt = E);
    }
    var J = I.objectMode ? 1 : rt.length;
    I.length += J;
    var st = I.length < I.highWaterMark;
    if (st || (I.needDrain = !0), I.writing || I.corked) {
      var xt = I.lastBufferedRequest;
      I.lastBufferedRequest = {
        chunk: rt,
        encoding: at,
        isBuf: H,
        callback: m,
        next: null
      }, xt ? xt.next = I.lastBufferedRequest : I.bufferedRequest = I.lastBufferedRequest, I.bufferedRequestCount += 1;
    } else
      Nt(O, I, !1, J, rt, at, m);
    return st;
  }
  function Nt(O, I, H, rt, at, m, E) {
    I.writelen = rt, I.writecb = E, I.writing = !0, I.sync = !0, I.destroyed ? I.onwrite(new M("write")) : H ? O._writev(at, I.onwrite) : O._write(at, m, I.onwrite), I.sync = !1;
  }
  function kt(O, I, H, rt, at) {
    --I.pendingcb, H ? (vt.nextTick(at, rt), vt.nextTick(Y, O, I), O._writableState.errorEmitted = !0, G(O, rt)) : (at(rt), O._writableState.errorEmitted = !0, G(O, rt), Y(O, I));
  }
  function it(O) {
    O.writing = !1, O.writecb = null, O.length -= O.writelen, O.writelen = 0;
  }
  function ot(O, I) {
    var H = O._writableState, rt = H.sync, at = H.writecb;
    if (typeof at != "function") throw new v();
    if (it(H), I) kt(O, H, rt, I, at);
    else {
      var m = It(H) || O.destroyed;
      !m && !H.corked && !H.bufferProcessing && H.bufferedRequest && yt(O, H), rt ? vt.nextTick(dt, O, H, m, at) : dt(O, H, m, at);
    }
  }
  function dt(O, I, H, rt) {
    H || bt(O, I), I.pendingcb--, rt(), Y(O, I);
  }
  function bt(O, I) {
    I.length === 0 && I.needDrain && (I.needDrain = !1, O.emit("drain"));
  }
  function yt(O, I) {
    I.bufferProcessing = !0;
    var H = I.bufferedRequest;
    if (O._writev && H && H.next) {
      var rt = I.bufferedRequestCount, at = new Array(rt), m = I.corkedRequestsFree;
      m.entry = H;
      for (var E = 0, J = !0; H; )
        at[E] = H, H.isBuf || (J = !1), H = H.next, E += 1;
      at.allBuffers = J, Nt(O, I, !0, I.length, at, "", m.finish), I.pendingcb++, I.lastBufferedRequest = null, m.next ? (I.corkedRequestsFree = m.next, m.next = null) : I.corkedRequestsFree = new n(I), I.bufferedRequestCount = 0;
    } else {
      for (; H; ) {
        var st = H.chunk, xt = H.encoding, wt = H.callback, Pt = I.objectMode ? 1 : st.length;
        if (Nt(O, I, !1, Pt, st, xt, wt), H = H.next, I.bufferedRequestCount--, I.writing)
          break;
      }
      H === null && (I.lastBufferedRequest = null);
    }
    I.bufferedRequest = H, I.bufferProcessing = !1;
  }
  V.prototype._write = function(O, I, H) {
    H(new b("_write()"));
  }, V.prototype._writev = null, V.prototype.end = function(O, I, H) {
    var rt = this._writableState;
    return typeof O == "function" ? (H = O, O = null, I = null) : typeof I == "function" && (H = I, I = null), O != null && this.write(O, I), rt.corked && (rt.corked = 1, this.uncork()), rt.ending || Q(this, rt, H), this;
  }, Object.defineProperty(V.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function It(O) {
    return O.ending && O.length === 0 && O.bufferedRequest === null && !O.finished && !O.writing;
  }
  function Dt(O, I) {
    O._final(function(H) {
      I.pendingcb--, H && G(O, H), I.prefinished = !0, O.emit("prefinish"), Y(O, I);
    });
  }
  function k(O, I) {
    !I.prefinished && !I.finalCalled && (typeof O._final == "function" && !I.destroyed ? (I.pendingcb++, I.finalCalled = !0, vt.nextTick(Dt, O, I)) : (I.prefinished = !0, O.emit("prefinish")));
  }
  function Y(O, I) {
    var H = It(I);
    if (H && (k(O, I), I.pendingcb === 0 && (I.finished = !0, O.emit("finish"), I.autoDestroy))) {
      var rt = O._readableState;
      (!rt || rt.autoDestroy && rt.endEmitted) && O.destroy();
    }
    return H;
  }
  function Q(O, I, H) {
    I.ending = !0, Y(O, I), H && (I.finished ? vt.nextTick(H) : O.once("finish", H)), I.ended = !0, O.writable = !1;
  }
  function _t(O, I, H) {
    var rt = O.entry;
    for (O.entry = null; rt; ) {
      var at = rt.callback;
      I.pendingcb--, at(H), rt = rt.next;
    }
    I.corkedRequestsFree.next = O;
  }
  return Object.defineProperty(V.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(I) {
      this._writableState && (this._writableState.destroyed = I);
    }
  }), V.prototype.destroy = _.destroy, V.prototype._undestroy = _.undestroy, V.prototype._destroy = function(O, I) {
    I(O);
  }, vu;
}
var Mu, Qp;
function Ba() {
  if (Qp) return Mu;
  Qp = 1;
  var n = Object.keys || function(p) {
    var f = [];
    for (var d in p) f.push(d);
    return f;
  };
  Mu = a;
  var t = Iy(), e = By();
  Na(a, t);
  for (var r = n(e.prototype), i = 0; i < r.length; i++) {
    var s = r[i];
    a.prototype[s] || (a.prototype[s] = e.prototype[s]);
  }
  function a(p) {
    if (!(this instanceof a)) return new a(p);
    t.call(this, p), e.call(this, p), this.allowHalfOpen = !0, p && (p.readable === !1 && (this.readable = !1), p.writable === !1 && (this.writable = !1), p.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", c)));
  }
  Object.defineProperty(a.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(a.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(a.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function c() {
    this._writableState.ended || vt.nextTick(_, this);
  }
  function _(p) {
    p.end();
  }
  return Object.defineProperty(a.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(f) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = f, this._writableState.destroyed = f);
    }
  }), Mu;
}
var xu = {}, Qc = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var Wp;
function zR() {
  return Wp || (Wp = 1, function(n, t) {
    var e = il, r = e.Buffer;
    function i(a, c) {
      for (var _ in a)
        c[_] = a[_];
    }
    r.from && r.alloc && r.allocUnsafe && r.allocUnsafeSlow ? n.exports = e : (i(e, t), t.Buffer = s);
    function s(a, c, _) {
      return r(a, c, _);
    }
    s.prototype = Object.create(r.prototype), i(r, s), s.from = function(a, c, _) {
      if (typeof a == "number")
        throw new TypeError("Argument must not be a number");
      return r(a, c, _);
    }, s.alloc = function(a, c, _) {
      if (typeof a != "number")
        throw new TypeError("Argument must be a number");
      var p = r(a);
      return c !== void 0 ? typeof _ == "string" ? p.fill(c, _) : p.fill(c) : p.fill(0), p;
    }, s.allocUnsafe = function(a) {
      if (typeof a != "number")
        throw new TypeError("Argument must be a number");
      return r(a);
    }, s.allocUnsafeSlow = function(a) {
      if (typeof a != "number")
        throw new TypeError("Argument must be a number");
      return e.SlowBuffer(a);
    };
  }(Qc, Qc.exports)), Qc.exports;
}
var Jp;
function $p() {
  if (Jp) return xu;
  Jp = 1;
  var n = zR().Buffer, t = n.isEncoding || function(A) {
    switch (A = "" + A, A && A.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function e(A) {
    if (!A) return "utf8";
    for (var B; ; )
      switch (A) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return A;
        default:
          if (B) return;
          A = ("" + A).toLowerCase(), B = !0;
      }
  }
  function r(A) {
    var B = e(A);
    if (typeof B != "string" && (n.isEncoding === t || !t(A))) throw new Error("Unknown encoding: " + A);
    return B || A;
  }
  xu.StringDecoder = i;
  function i(A) {
    this.encoding = r(A);
    var B;
    switch (this.encoding) {
      case "utf16le":
        this.text = d, this.end = y, B = 4;
        break;
      case "utf8":
        this.fillLast = _, B = 4;
        break;
      case "base64":
        this.text = b, this.end = v, B = 3;
        break;
      default:
        this.write = R, this.end = M;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = n.allocUnsafe(B);
  }
  i.prototype.write = function(A) {
    if (A.length === 0) return "";
    var B, N;
    if (this.lastNeed) {
      if (B = this.fillLast(A), B === void 0) return "";
      N = this.lastNeed, this.lastNeed = 0;
    } else
      N = 0;
    return N < A.length ? B ? B + this.text(A, N) : this.text(A, N) : B || "";
  }, i.prototype.end = f, i.prototype.text = p, i.prototype.fillLast = function(A) {
    if (this.lastNeed <= A.length)
      return A.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    A.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, A.length), this.lastNeed -= A.length;
  };
  function s(A) {
    return A <= 127 ? 0 : A >> 5 === 6 ? 2 : A >> 4 === 14 ? 3 : A >> 3 === 30 ? 4 : A >> 6 === 2 ? -1 : -2;
  }
  function a(A, B, N) {
    var G = B.length - 1;
    if (G < N) return 0;
    var D = s(B[G]);
    return D >= 0 ? (D > 0 && (A.lastNeed = D - 1), D) : --G < N || D === -2 ? 0 : (D = s(B[G]), D >= 0 ? (D > 0 && (A.lastNeed = D - 2), D) : --G < N || D === -2 ? 0 : (D = s(B[G]), D >= 0 ? (D > 0 && (D === 2 ? D = 0 : A.lastNeed = D - 3), D) : 0));
  }
  function c(A, B, N) {
    if ((B[0] & 192) !== 128)
      return A.lastNeed = 0, "�";
    if (A.lastNeed > 1 && B.length > 1) {
      if ((B[1] & 192) !== 128)
        return A.lastNeed = 1, "�";
      if (A.lastNeed > 2 && B.length > 2 && (B[2] & 192) !== 128)
        return A.lastNeed = 2, "�";
    }
  }
  function _(A) {
    var B = this.lastTotal - this.lastNeed, N = c(this, A);
    if (N !== void 0) return N;
    if (this.lastNeed <= A.length)
      return A.copy(this.lastChar, B, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    A.copy(this.lastChar, B, 0, A.length), this.lastNeed -= A.length;
  }
  function p(A, B) {
    var N = a(this, A, B);
    if (!this.lastNeed) return A.toString("utf8", B);
    this.lastTotal = N;
    var G = A.length - (N - this.lastNeed);
    return A.copy(this.lastChar, 0, G), A.toString("utf8", B, G);
  }
  function f(A) {
    var B = A && A.length ? this.write(A) : "";
    return this.lastNeed ? B + "�" : B;
  }
  function d(A, B) {
    if ((A.length - B) % 2 === 0) {
      var N = A.toString("utf16le", B);
      if (N) {
        var G = N.charCodeAt(N.length - 1);
        if (G >= 55296 && G <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = A[A.length - 2], this.lastChar[1] = A[A.length - 1], N.slice(0, -1);
      }
      return N;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = A[A.length - 1], A.toString("utf16le", B, A.length - 1);
  }
  function y(A) {
    var B = A && A.length ? this.write(A) : "";
    if (this.lastNeed) {
      var N = this.lastTotal - this.lastNeed;
      return B + this.lastChar.toString("utf16le", 0, N);
    }
    return B;
  }
  function b(A, B) {
    var N = (A.length - B) % 3;
    return N === 0 ? A.toString("base64", B) : (this.lastNeed = 3 - N, this.lastTotal = 3, N === 1 ? this.lastChar[0] = A[A.length - 1] : (this.lastChar[0] = A[A.length - 2], this.lastChar[1] = A[A.length - 1]), A.toString("base64", B, A.length - N));
  }
  function v(A) {
    var B = A && A.length ? this.write(A) : "";
    return this.lastNeed ? B + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : B;
  }
  function R(A) {
    return A.toString(this.encoding);
  }
  function M(A) {
    return A && A.length ? this.write(A) : "";
  }
  return xu;
}
var qp = Ss.codes.ERR_STREAM_PREMATURE_CLOSE;
function kR(n) {
  var t = !1;
  return function() {
    if (!t) {
      t = !0;
      for (var e = arguments.length, r = new Array(e), i = 0; i < e; i++)
        r[i] = arguments[i];
      n.apply(this, r);
    }
  };
}
function UR() {
}
function FR(n) {
  return n.setHeader && typeof n.abort == "function";
}
function Cy(n, t, e) {
  if (typeof t == "function") return Cy(n, null, t);
  t || (t = {}), e = kR(e || UR);
  var r = t.readable || t.readable !== !1 && n.readable, i = t.writable || t.writable !== !1 && n.writable, s = function() {
    n.writable || c();
  }, a = n._writableState && n._writableState.finished, c = function() {
    i = !1, a = !0, r || e.call(n);
  }, _ = n._readableState && n._readableState.endEmitted, p = function() {
    r = !1, _ = !0, i || e.call(n);
  }, f = function(v) {
    e.call(n, v);
  }, d = function() {
    var v;
    if (r && !_)
      return (!n._readableState || !n._readableState.ended) && (v = new qp()), e.call(n, v);
    if (i && !a)
      return (!n._writableState || !n._writableState.ended) && (v = new qp()), e.call(n, v);
  }, y = function() {
    n.req.on("finish", c);
  };
  return FR(n) ? (n.on("complete", c), n.on("abort", d), n.req ? y() : n.on("request", y)) : i && !n._writableState && (n.on("end", s), n.on("close", s)), n.on("end", p), n.on("finish", c), t.error !== !1 && n.on("error", f), n.on("close", d), function() {
    n.removeListener("complete", c), n.removeListener("abort", d), n.removeListener("request", y), n.req && n.req.removeListener("finish", c), n.removeListener("end", s), n.removeListener("close", s), n.removeListener("finish", c), n.removeListener("end", p), n.removeListener("error", f), n.removeListener("close", d);
  };
}
var ah = Cy, Bu, Zp;
function GR() {
  if (Zp) return Bu;
  Zp = 1;
  var n;
  function t(N, G, D) {
    return G = e(G), G in N ? Object.defineProperty(N, G, { value: D, enumerable: !0, configurable: !0, writable: !0 }) : N[G] = D, N;
  }
  function e(N) {
    var G = r(N, "string");
    return typeof G == "symbol" ? G : String(G);
  }
  function r(N, G) {
    if (typeof N != "object" || N === null) return N;
    var D = N[Symbol.toPrimitive];
    if (D !== void 0) {
      var $ = D.call(N, G || "default");
      if (typeof $ != "object") return $;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (G === "string" ? String : Number)(N);
  }
  var i = ah, s = Symbol("lastResolve"), a = Symbol("lastReject"), c = Symbol("error"), _ = Symbol("ended"), p = Symbol("lastPromise"), f = Symbol("handlePromise"), d = Symbol("stream");
  function y(N, G) {
    return {
      value: N,
      done: G
    };
  }
  function b(N) {
    var G = N[s];
    if (G !== null) {
      var D = N[d].read();
      D !== null && (N[p] = null, N[s] = null, N[a] = null, G(y(D, !1)));
    }
  }
  function v(N) {
    vt.nextTick(b, N);
  }
  function R(N, G) {
    return function(D, $) {
      N.then(function() {
        if (G[_]) {
          D(y(void 0, !0));
          return;
        }
        G[f](D, $);
      }, $);
    };
  }
  var M = Object.getPrototypeOf(function() {
  }), A = Object.setPrototypeOf((n = {
    get stream() {
      return this[d];
    },
    next: function() {
      var G = this, D = this[c];
      if (D !== null)
        return Promise.reject(D);
      if (this[_])
        return Promise.resolve(y(void 0, !0));
      if (this[d].destroyed)
        return new Promise(function(nt, ft) {
          vt.nextTick(function() {
            G[c] ? ft(G[c]) : nt(y(void 0, !0));
          });
        });
      var $ = this[p], X;
      if ($)
        X = new Promise(R($, this));
      else {
        var V = this[d].read();
        if (V !== null)
          return Promise.resolve(y(V, !1));
        X = new Promise(this[f]);
      }
      return this[p] = X, X;
    }
  }, t(n, Symbol.asyncIterator, function() {
    return this;
  }), t(n, "return", function() {
    var G = this;
    return new Promise(function(D, $) {
      G[d].destroy(null, function(X) {
        if (X) {
          $(X);
          return;
        }
        D(y(void 0, !0));
      });
    });
  }), n), M), B = function(G) {
    var D, $ = Object.create(A, (D = {}, t(D, d, {
      value: G,
      writable: !0
    }), t(D, s, {
      value: null,
      writable: !0
    }), t(D, a, {
      value: null,
      writable: !0
    }), t(D, c, {
      value: null,
      writable: !0
    }), t(D, _, {
      value: G._readableState.endEmitted,
      writable: !0
    }), t(D, f, {
      value: function(V, nt) {
        var ft = $[d].read();
        ft ? ($[p] = null, $[s] = null, $[a] = null, V(y(ft, !1))) : ($[s] = V, $[a] = nt);
      },
      writable: !0
    }), D));
    return $[p] = null, i(G, function(X) {
      if (X && X.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var V = $[a];
        V !== null && ($[p] = null, $[s] = null, $[a] = null, V(X)), $[c] = X;
        return;
      }
      var nt = $[s];
      nt !== null && ($[p] = null, $[s] = null, $[a] = null, nt(y(void 0, !0))), $[_] = !0;
    }), G.on("readable", v.bind(null, $)), $;
  };
  return Bu = B, Bu;
}
var Cu, Xp;
function LR() {
  return Xp || (Xp = 1, Cu = function() {
    throw new Error("Readable.from is not available in the browser");
  }), Cu;
}
var Iu, td;
function Iy() {
  if (td) return Iu;
  td = 1, Iu = nt;
  var n;
  nt.ReadableState = V, iy.EventEmitter;
  var t = function(E, J) {
    return E.listeners(J).length;
  }, e = sy, r = il.Buffer, i = (typeof Fn < "u" ? Fn : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function s(m) {
    return r.from(m);
  }
  function a(m) {
    return r.isBuffer(m) || m instanceof i;
  }
  var c = Xf, _;
  c && c.debuglog ? _ = c.debuglog("stream") : _ = function() {
  };
  var p = SR(), f = vy, d = xy, y = d.getHighWaterMark, b = Ss.codes, v = b.ERR_INVALID_ARG_TYPE, R = b.ERR_STREAM_PUSH_AFTER_EOF, M = b.ERR_METHOD_NOT_IMPLEMENTED, A = b.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, B, N, G;
  Na(nt, e);
  var D = f.errorOrDestroy, $ = ["error", "close", "destroy", "pause", "resume"];
  function X(m, E, J) {
    if (typeof m.prependListener == "function") return m.prependListener(E, J);
    !m._events || !m._events[E] ? m.on(E, J) : Array.isArray(m._events[E]) ? m._events[E].unshift(J) : m._events[E] = [J, m._events[E]];
  }
  function V(m, E, J) {
    n = n || Ba(), m = m || {}, typeof J != "boolean" && (J = E instanceof n), this.objectMode = !!m.objectMode, J && (this.objectMode = this.objectMode || !!m.readableObjectMode), this.highWaterMark = y(this, m, "readableHighWaterMark", J), this.buffer = new p(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = m.emitClose !== !1, this.autoDestroy = !!m.autoDestroy, this.destroyed = !1, this.defaultEncoding = m.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, m.encoding && (B || (B = $p().StringDecoder), this.decoder = new B(m.encoding), this.encoding = m.encoding);
  }
  function nt(m) {
    if (n = n || Ba(), !(this instanceof nt)) return new nt(m);
    var E = this instanceof n;
    this._readableState = new V(m, this, E), this.readable = !0, m && (typeof m.read == "function" && (this._read = m.read), typeof m.destroy == "function" && (this._destroy = m.destroy)), e.call(this);
  }
  Object.defineProperty(nt.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(E) {
      this._readableState && (this._readableState.destroyed = E);
    }
  }), nt.prototype.destroy = f.destroy, nt.prototype._undestroy = f.undestroy, nt.prototype._destroy = function(m, E) {
    E(m);
  }, nt.prototype.push = function(m, E) {
    var J = this._readableState, st;
    return J.objectMode ? st = !0 : typeof m == "string" && (E = E || J.defaultEncoding, E !== J.encoding && (m = r.from(m, E), E = ""), st = !0), ft(this, m, E, !1, st);
  }, nt.prototype.unshift = function(m) {
    return ft(this, m, null, !0, !1);
  };
  function ft(m, E, J, st, xt) {
    _("readableAddChunk", E);
    var wt = m._readableState;
    if (E === null)
      wt.reading = !1, ot(m, wt);
    else {
      var Pt;
      if (xt || (Pt = At(wt, E)), Pt)
        D(m, Pt);
      else if (wt.objectMode || E && E.length > 0)
        if (typeof E != "string" && !wt.objectMode && Object.getPrototypeOf(E) !== r.prototype && (E = s(E)), st)
          wt.endEmitted ? D(m, new A()) : pt(m, wt, E, !0);
        else if (wt.ended)
          D(m, new R());
        else {
          if (wt.destroyed)
            return !1;
          wt.reading = !1, wt.decoder && !J ? (E = wt.decoder.write(E), wt.objectMode || E.length !== 0 ? pt(m, wt, E, !1) : yt(m, wt)) : pt(m, wt, E, !1);
        }
      else st || (wt.reading = !1, yt(m, wt));
    }
    return !wt.ended && (wt.length < wt.highWaterMark || wt.length === 0);
  }
  function pt(m, E, J, st) {
    E.flowing && E.length === 0 && !E.sync ? (E.awaitDrain = 0, m.emit("data", J)) : (E.length += E.objectMode ? 1 : J.length, st ? E.buffer.unshift(J) : E.buffer.push(J), E.needReadable && dt(m)), yt(m, E);
  }
  function At(m, E) {
    var J;
    return !a(E) && typeof E != "string" && E !== void 0 && !m.objectMode && (J = new v("chunk", ["string", "Buffer", "Uint8Array"], E)), J;
  }
  nt.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, nt.prototype.setEncoding = function(m) {
    B || (B = $p().StringDecoder);
    var E = new B(m);
    this._readableState.decoder = E, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var J = this._readableState.buffer.head, st = ""; J !== null; )
      st += E.write(J.data), J = J.next;
    return this._readableState.buffer.clear(), st !== "" && this._readableState.buffer.push(st), this._readableState.length = st.length, this;
  };
  var Nt = 1073741824;
  function kt(m) {
    return m >= Nt ? m = Nt : (m--, m |= m >>> 1, m |= m >>> 2, m |= m >>> 4, m |= m >>> 8, m |= m >>> 16, m++), m;
  }
  function it(m, E) {
    return m <= 0 || E.length === 0 && E.ended ? 0 : E.objectMode ? 1 : m !== m ? E.flowing && E.length ? E.buffer.head.data.length : E.length : (m > E.highWaterMark && (E.highWaterMark = kt(m)), m <= E.length ? m : E.ended ? E.length : (E.needReadable = !0, 0));
  }
  nt.prototype.read = function(m) {
    _("read", m), m = parseInt(m, 10);
    var E = this._readableState, J = m;
    if (m !== 0 && (E.emittedReadable = !1), m === 0 && E.needReadable && ((E.highWaterMark !== 0 ? E.length >= E.highWaterMark : E.length > 0) || E.ended))
      return _("read: emitReadable", E.length, E.ended), E.length === 0 && E.ended ? H(this) : dt(this), null;
    if (m = it(m, E), m === 0 && E.ended)
      return E.length === 0 && H(this), null;
    var st = E.needReadable;
    _("need readable", st), (E.length === 0 || E.length - m < E.highWaterMark) && (st = !0, _("length less than watermark", st)), E.ended || E.reading ? (st = !1, _("reading or ended", st)) : st && (_("do read"), E.reading = !0, E.sync = !0, E.length === 0 && (E.needReadable = !0), this._read(E.highWaterMark), E.sync = !1, E.reading || (m = it(J, E)));
    var xt;
    return m > 0 ? xt = I(m, E) : xt = null, xt === null ? (E.needReadable = E.length <= E.highWaterMark, m = 0) : (E.length -= m, E.awaitDrain = 0), E.length === 0 && (E.ended || (E.needReadable = !0), J !== m && E.ended && H(this)), xt !== null && this.emit("data", xt), xt;
  };
  function ot(m, E) {
    if (_("onEofChunk"), !E.ended) {
      if (E.decoder) {
        var J = E.decoder.end();
        J && J.length && (E.buffer.push(J), E.length += E.objectMode ? 1 : J.length);
      }
      E.ended = !0, E.sync ? dt(m) : (E.needReadable = !1, E.emittedReadable || (E.emittedReadable = !0, bt(m)));
    }
  }
  function dt(m) {
    var E = m._readableState;
    _("emitReadable", E.needReadable, E.emittedReadable), E.needReadable = !1, E.emittedReadable || (_("emitReadable", E.flowing), E.emittedReadable = !0, vt.nextTick(bt, m));
  }
  function bt(m) {
    var E = m._readableState;
    _("emitReadable_", E.destroyed, E.length, E.ended), !E.destroyed && (E.length || E.ended) && (m.emit("readable"), E.emittedReadable = !1), E.needReadable = !E.flowing && !E.ended && E.length <= E.highWaterMark, O(m);
  }
  function yt(m, E) {
    E.readingMore || (E.readingMore = !0, vt.nextTick(It, m, E));
  }
  function It(m, E) {
    for (; !E.reading && !E.ended && (E.length < E.highWaterMark || E.flowing && E.length === 0); ) {
      var J = E.length;
      if (_("maybeReadMore read 0"), m.read(0), J === E.length)
        break;
    }
    E.readingMore = !1;
  }
  nt.prototype._read = function(m) {
    D(this, new M("_read()"));
  }, nt.prototype.pipe = function(m, E) {
    var J = this, st = this._readableState;
    switch (st.pipesCount) {
      case 0:
        st.pipes = m;
        break;
      case 1:
        st.pipes = [st.pipes, m];
        break;
      default:
        st.pipes.push(m);
        break;
    }
    st.pipesCount += 1, _("pipe count=%d opts=%j", st.pipesCount, E);
    var xt = (!E || E.end !== !1) && m !== vt.stdout && m !== vt.stderr, wt = xt ? Ce : Ge;
    st.endEmitted ? vt.nextTick(wt) : J.once("end", wt), m.on("unpipe", Pt);
    function Pt(rr, re) {
      _("onunpipe"), rr === J && re && re.hasUnpiped === !1 && (re.hasUnpiped = !0, yi());
    }
    function Ce() {
      _("onend"), m.end();
    }
    var Z = Dt(J);
    m.on("drain", Z);
    var tr = !1;
    function yi() {
      _("cleanup"), m.removeListener("close", er), m.removeListener("finish", _e), m.removeListener("drain", Z), m.removeListener("error", fn), m.removeListener("unpipe", Pt), J.removeListener("end", Ce), J.removeListener("end", Ge), J.removeListener("data", bi), tr = !0, st.awaitDrain && (!m._writableState || m._writableState.needDrain) && Z();
    }
    J.on("data", bi);
    function bi(rr) {
      _("ondata");
      var re = m.write(rr);
      _("dest.write", re), re === !1 && ((st.pipesCount === 1 && st.pipes === m || st.pipesCount > 1 && at(st.pipes, m) !== -1) && !tr && (_("false write response, pause", st.awaitDrain), st.awaitDrain++), J.pause());
    }
    function fn(rr) {
      _("onerror", rr), Ge(), m.removeListener("error", fn), t(m, "error") === 0 && D(m, rr);
    }
    X(m, "error", fn);
    function er() {
      m.removeListener("finish", _e), Ge();
    }
    m.once("close", er);
    function _e() {
      _("onfinish"), m.removeListener("close", er), Ge();
    }
    m.once("finish", _e);
    function Ge() {
      _("unpipe"), J.unpipe(m);
    }
    return m.emit("pipe", J), st.flowing || (_("pipe resume"), J.resume()), m;
  };
  function Dt(m) {
    return function() {
      var J = m._readableState;
      _("pipeOnDrain", J.awaitDrain), J.awaitDrain && J.awaitDrain--, J.awaitDrain === 0 && t(m, "data") && (J.flowing = !0, O(m));
    };
  }
  nt.prototype.unpipe = function(m) {
    var E = this._readableState, J = {
      hasUnpiped: !1
    };
    if (E.pipesCount === 0) return this;
    if (E.pipesCount === 1)
      return m && m !== E.pipes ? this : (m || (m = E.pipes), E.pipes = null, E.pipesCount = 0, E.flowing = !1, m && m.emit("unpipe", this, J), this);
    if (!m) {
      var st = E.pipes, xt = E.pipesCount;
      E.pipes = null, E.pipesCount = 0, E.flowing = !1;
      for (var wt = 0; wt < xt; wt++) st[wt].emit("unpipe", this, {
        hasUnpiped: !1
      });
      return this;
    }
    var Pt = at(E.pipes, m);
    return Pt === -1 ? this : (E.pipes.splice(Pt, 1), E.pipesCount -= 1, E.pipesCount === 1 && (E.pipes = E.pipes[0]), m.emit("unpipe", this, J), this);
  }, nt.prototype.on = function(m, E) {
    var J = e.prototype.on.call(this, m, E), st = this._readableState;
    return m === "data" ? (st.readableListening = this.listenerCount("readable") > 0, st.flowing !== !1 && this.resume()) : m === "readable" && !st.endEmitted && !st.readableListening && (st.readableListening = st.needReadable = !0, st.flowing = !1, st.emittedReadable = !1, _("on readable", st.length, st.reading), st.length ? dt(this) : st.reading || vt.nextTick(Y, this)), J;
  }, nt.prototype.addListener = nt.prototype.on, nt.prototype.removeListener = function(m, E) {
    var J = e.prototype.removeListener.call(this, m, E);
    return m === "readable" && vt.nextTick(k, this), J;
  }, nt.prototype.removeAllListeners = function(m) {
    var E = e.prototype.removeAllListeners.apply(this, arguments);
    return (m === "readable" || m === void 0) && vt.nextTick(k, this), E;
  };
  function k(m) {
    var E = m._readableState;
    E.readableListening = m.listenerCount("readable") > 0, E.resumeScheduled && !E.paused ? E.flowing = !0 : m.listenerCount("data") > 0 && m.resume();
  }
  function Y(m) {
    _("readable nexttick read 0"), m.read(0);
  }
  nt.prototype.resume = function() {
    var m = this._readableState;
    return m.flowing || (_("resume"), m.flowing = !m.readableListening, Q(this, m)), m.paused = !1, this;
  };
  function Q(m, E) {
    E.resumeScheduled || (E.resumeScheduled = !0, vt.nextTick(_t, m, E));
  }
  function _t(m, E) {
    _("resume", E.reading), E.reading || m.read(0), E.resumeScheduled = !1, m.emit("resume"), O(m), E.flowing && !E.reading && m.read(0);
  }
  nt.prototype.pause = function() {
    return _("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (_("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function O(m) {
    var E = m._readableState;
    for (_("flow", E.flowing); E.flowing && m.read() !== null; ) ;
  }
  nt.prototype.wrap = function(m) {
    var E = this, J = this._readableState, st = !1;
    m.on("end", function() {
      if (_("wrapped end"), J.decoder && !J.ended) {
        var Pt = J.decoder.end();
        Pt && Pt.length && E.push(Pt);
      }
      E.push(null);
    }), m.on("data", function(Pt) {
      if (_("wrapped data"), J.decoder && (Pt = J.decoder.write(Pt)), !(J.objectMode && Pt == null) && !(!J.objectMode && (!Pt || !Pt.length))) {
        var Ce = E.push(Pt);
        Ce || (st = !0, m.pause());
      }
    });
    for (var xt in m)
      this[xt] === void 0 && typeof m[xt] == "function" && (this[xt] = /* @__PURE__ */ function(Ce) {
        return function() {
          return m[Ce].apply(m, arguments);
        };
      }(xt));
    for (var wt = 0; wt < $.length; wt++)
      m.on($[wt], this.emit.bind(this, $[wt]));
    return this._read = function(Pt) {
      _("wrapped _read", Pt), st && (st = !1, m.resume());
    }, this;
  }, typeof Symbol == "function" && (nt.prototype[Symbol.asyncIterator] = function() {
    return N === void 0 && (N = GR()), N(this);
  }), Object.defineProperty(nt.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(nt.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(nt.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(E) {
      this._readableState && (this._readableState.flowing = E);
    }
  }), nt._fromList = I, Object.defineProperty(nt.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function I(m, E) {
    if (E.length === 0) return null;
    var J;
    return E.objectMode ? J = E.buffer.shift() : !m || m >= E.length ? (E.decoder ? J = E.buffer.join("") : E.buffer.length === 1 ? J = E.buffer.first() : J = E.buffer.concat(E.length), E.buffer.clear()) : J = E.buffer.consume(m, E.decoder), J;
  }
  function H(m) {
    var E = m._readableState;
    _("endReadable", E.endEmitted), E.endEmitted || (E.ended = !0, vt.nextTick(rt, E, m));
  }
  function rt(m, E) {
    if (_("endReadableNT", m.endEmitted, m.length), !m.endEmitted && m.length === 0 && (m.endEmitted = !0, E.readable = !1, E.emit("end"), m.autoDestroy)) {
      var J = E._writableState;
      (!J || J.autoDestroy && J.finished) && E.destroy();
    }
  }
  typeof Symbol == "function" && (nt.from = function(m, E) {
    return G === void 0 && (G = LR()), G(nt, m, E);
  });
  function at(m, E) {
    for (var J = 0, st = m.length; J < st; J++)
      if (m[J] === E) return J;
    return -1;
  }
  return Iu;
}
var Ny = Gn, cl = Ss.codes, DR = cl.ERR_METHOD_NOT_IMPLEMENTED, KR = cl.ERR_MULTIPLE_CALLBACK, VR = cl.ERR_TRANSFORM_ALREADY_TRANSFORMING, jR = cl.ERR_TRANSFORM_WITH_LENGTH_0, _l = Ba();
Na(Gn, _l);
function HR(n, t) {
  var e = this._transformState;
  e.transforming = !1;
  var r = e.writecb;
  if (r === null)
    return this.emit("error", new KR());
  e.writechunk = null, e.writecb = null, t != null && this.push(t), r(n);
  var i = this._readableState;
  i.reading = !1, (i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);
}
function Gn(n) {
  if (!(this instanceof Gn)) return new Gn(n);
  _l.call(this, n), this._transformState = {
    afterTransform: HR.bind(this),
    needTransform: !1,
    transforming: !1,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = !0, this._readableState.sync = !1, n && (typeof n.transform == "function" && (this._transform = n.transform), typeof n.flush == "function" && (this._flush = n.flush)), this.on("prefinish", YR);
}
function YR() {
  var n = this;
  typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(t, e) {
    ed(n, t, e);
  }) : ed(this, null, null);
}
Gn.prototype.push = function(n, t) {
  return this._transformState.needTransform = !1, _l.prototype.push.call(this, n, t);
};
Gn.prototype._transform = function(n, t, e) {
  e(new DR("_transform()"));
};
Gn.prototype._write = function(n, t, e) {
  var r = this._transformState;
  if (r.writecb = e, r.writechunk = n, r.writeencoding = t, !r.transforming) {
    var i = this._readableState;
    (r.needTransform || i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);
  }
};
Gn.prototype._read = function(n) {
  var t = this._transformState;
  t.writechunk !== null && !t.transforming ? (t.transforming = !0, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) : t.needTransform = !0;
};
Gn.prototype._destroy = function(n, t) {
  _l.prototype._destroy.call(this, n, function(e) {
    t(e);
  });
};
function ed(n, t, e) {
  if (t) return n.emit("error", t);
  if (e != null && n.push(e), n._writableState.length) throw new jR();
  if (n._transformState.transforming) throw new VR();
  return n.push(null);
}
var QR = uc, Oy = Ny;
Na(uc, Oy);
function uc(n) {
  if (!(this instanceof uc)) return new uc(n);
  Oy.call(this, n);
}
uc.prototype._transform = function(n, t, e) {
  e(null, n);
};
var Nu;
function WR(n) {
  var t = !1;
  return function() {
    t || (t = !0, n.apply(void 0, arguments));
  };
}
var Ty = Ss.codes, JR = Ty.ERR_MISSING_ARGS, $R = Ty.ERR_STREAM_DESTROYED;
function rd(n) {
  if (n) throw n;
}
function qR(n) {
  return n.setHeader && typeof n.abort == "function";
}
function ZR(n, t, e, r) {
  r = WR(r);
  var i = !1;
  n.on("close", function() {
    i = !0;
  }), Nu === void 0 && (Nu = ah), Nu(n, {
    readable: t,
    writable: e
  }, function(a) {
    if (a) return r(a);
    i = !0, r();
  });
  var s = !1;
  return function(a) {
    if (!i && !s) {
      if (s = !0, qR(n)) return n.abort();
      if (typeof n.destroy == "function") return n.destroy();
      r(a || new $R("pipe"));
    }
  };
}
function nd(n) {
  n();
}
function XR(n, t) {
  return n.pipe(t);
}
function tP(n) {
  return !n.length || typeof n[n.length - 1] != "function" ? rd : n.pop();
}
function eP() {
  for (var n = arguments.length, t = new Array(n), e = 0; e < n; e++)
    t[e] = arguments[e];
  var r = tP(t);
  if (Array.isArray(t[0]) && (t = t[0]), t.length < 2)
    throw new JR("streams");
  var i, s = t.map(function(a, c) {
    var _ = c < t.length - 1, p = c > 0;
    return ZR(a, _, p, function(f) {
      i || (i = f), f && s.forEach(nd), !_ && (s.forEach(nd), r(i));
    });
  });
  return t.reduce(XR);
}
var rP = eP;
(function(n, t) {
  t = n.exports = Iy(), t.Stream = t, t.Readable = t, t.Writable = By(), t.Duplex = Ba(), t.Transform = Ny, t.PassThrough = QR, t.finished = ah, t.pipeline = rP;
})(df, df.exports);
var zy = df.exports;
const { Transform: nP } = zy;
var iP = (n) => class ky extends nP {
  constructor(e, r, i, s, a) {
    super(a), this._rate = e, this._capacity = r, this._delimitedSuffix = i, this._hashBitLength = s, this._options = a, this._state = new n(), this._state.initialize(e, r), this._finalized = !1;
  }
  _transform(e, r, i) {
    let s = null;
    try {
      this.update(e, r);
    } catch (a) {
      s = a;
    }
    i(s);
  }
  _flush(e) {
    let r = null;
    try {
      this.push(this.digest());
    } catch (i) {
      r = i;
    }
    e(r);
  }
  update(e, r) {
    if (!ne.isBuffer(e) && typeof e != "string") throw new TypeError("Data must be a string or a buffer");
    if (this._finalized) throw new Error("Digest already called");
    return ne.isBuffer(e) || (e = ne.from(e, r)), this._state.absorb(e), this;
  }
  digest(e) {
    if (this._finalized) throw new Error("Digest already called");
    this._finalized = !0, this._delimitedSuffix && this._state.absorbLastFewBits(this._delimitedSuffix);
    let r = this._state.squeeze(this._hashBitLength / 8);
    return e !== void 0 && (r = r.toString(e)), this._resetState(), r;
  }
  // remove result from memory
  _resetState() {
    return this._state.initialize(this._rate, this._capacity), this;
  }
  // because sometimes we need hash right now and little later
  _clone() {
    const e = new ky(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options);
    return this._state.copy(e._state), e._finalized = this._finalized, e;
  }
};
const { Transform: sP } = zy;
var oP = (n) => class Uy extends sP {
  constructor(e, r, i, s) {
    super(s), this._rate = e, this._capacity = r, this._delimitedSuffix = i, this._options = s, this._state = new n(), this._state.initialize(e, r), this._finalized = !1;
  }
  _transform(e, r, i) {
    let s = null;
    try {
      this.update(e, r);
    } catch (a) {
      s = a;
    }
    i(s);
  }
  _flush() {
  }
  _read(e) {
    this.push(this.squeeze(e));
  }
  update(e, r) {
    if (!ne.isBuffer(e) && typeof e != "string") throw new TypeError("Data must be a string or a buffer");
    if (this._finalized) throw new Error("Squeeze already called");
    return ne.isBuffer(e) || (e = ne.from(e, r)), this._state.absorb(e), this;
  }
  squeeze(e, r) {
    this._finalized || (this._finalized = !0, this._state.absorbLastFewBits(this._delimitedSuffix));
    let i = this._state.squeeze(e);
    return r !== void 0 && (i = i.toString(r)), i;
  }
  _resetState() {
    return this._state.initialize(this._rate, this._capacity), this;
  }
  _clone() {
    const e = new Uy(this._rate, this._capacity, this._delimitedSuffix, this._options);
    return this._state.copy(e._state), e._finalized = this._finalized, e;
  }
};
const aP = iP, cP = oP;
var _P = function(n) {
  const t = aP(n), e = cP(n);
  return function(r, i) {
    switch (typeof r == "string" ? r.toLowerCase() : r) {
      case "keccak224":
        return new t(1152, 448, null, 224, i);
      case "keccak256":
        return new t(1088, 512, null, 256, i);
      case "keccak384":
        return new t(832, 768, null, 384, i);
      case "keccak512":
        return new t(576, 1024, null, 512, i);
      case "sha3-224":
        return new t(1152, 448, 6, 224, i);
      case "sha3-256":
        return new t(1088, 512, 6, 256, i);
      case "sha3-384":
        return new t(832, 768, 6, 384, i);
      case "sha3-512":
        return new t(576, 1024, 6, 512, i);
      case "shake128":
        return new e(1344, 256, 31, i);
      case "shake256":
        return new e(1088, 512, 31, i);
      default:
        throw new Error("Invald algorithm: " + r);
    }
  };
}, Fy = {};
const id = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
Fy.p1600 = function(n) {
  for (let t = 0; t < 24; ++t) {
    const e = n[0] ^ n[10] ^ n[20] ^ n[30] ^ n[40], r = n[1] ^ n[11] ^ n[21] ^ n[31] ^ n[41], i = n[2] ^ n[12] ^ n[22] ^ n[32] ^ n[42], s = n[3] ^ n[13] ^ n[23] ^ n[33] ^ n[43], a = n[4] ^ n[14] ^ n[24] ^ n[34] ^ n[44], c = n[5] ^ n[15] ^ n[25] ^ n[35] ^ n[45], _ = n[6] ^ n[16] ^ n[26] ^ n[36] ^ n[46], p = n[7] ^ n[17] ^ n[27] ^ n[37] ^ n[47], f = n[8] ^ n[18] ^ n[28] ^ n[38] ^ n[48], d = n[9] ^ n[19] ^ n[29] ^ n[39] ^ n[49];
    let y = f ^ (i << 1 | s >>> 31), b = d ^ (s << 1 | i >>> 31);
    const v = n[0] ^ y, R = n[1] ^ b, M = n[10] ^ y, A = n[11] ^ b, B = n[20] ^ y, N = n[21] ^ b, G = n[30] ^ y, D = n[31] ^ b, $ = n[40] ^ y, X = n[41] ^ b;
    y = e ^ (a << 1 | c >>> 31), b = r ^ (c << 1 | a >>> 31);
    const V = n[2] ^ y, nt = n[3] ^ b, ft = n[12] ^ y, pt = n[13] ^ b, At = n[22] ^ y, Nt = n[23] ^ b, kt = n[32] ^ y, it = n[33] ^ b, ot = n[42] ^ y, dt = n[43] ^ b;
    y = i ^ (_ << 1 | p >>> 31), b = s ^ (p << 1 | _ >>> 31);
    const bt = n[4] ^ y, yt = n[5] ^ b, It = n[14] ^ y, Dt = n[15] ^ b, k = n[24] ^ y, Y = n[25] ^ b, Q = n[34] ^ y, _t = n[35] ^ b, O = n[44] ^ y, I = n[45] ^ b;
    y = a ^ (f << 1 | d >>> 31), b = c ^ (d << 1 | f >>> 31);
    const H = n[6] ^ y, rt = n[7] ^ b, at = n[16] ^ y, m = n[17] ^ b, E = n[26] ^ y, J = n[27] ^ b, st = n[36] ^ y, xt = n[37] ^ b, wt = n[46] ^ y, Pt = n[47] ^ b;
    y = _ ^ (e << 1 | r >>> 31), b = p ^ (r << 1 | e >>> 31);
    const Ce = n[8] ^ y, Z = n[9] ^ b, tr = n[18] ^ y, yi = n[19] ^ b, bi = n[28] ^ y, fn = n[29] ^ b, er = n[38] ^ y, _e = n[39] ^ b, Ge = n[48] ^ y, rr = n[49] ^ b, re = v, ka = R, g = A << 4 | M >>> 28, l = M << 4 | A >>> 28, h = B << 3 | N >>> 29, S = N << 3 | B >>> 29, C = D << 9 | G >>> 23, K = G << 9 | D >>> 23, q = $ << 18 | X >>> 14, mt = X << 18 | $ >>> 14, Kt = V << 1 | nt >>> 31, Gt = nt << 1 | V >>> 31, Vt = pt << 12 | ft >>> 20, Ft = ft << 12 | pt >>> 20, hl = At << 10 | Nt >>> 22, pl = Nt << 10 | At >>> 22, dl = it << 13 | kt >>> 19, wl = kt << 13 | it >>> 19, gl = ot << 2 | dt >>> 30, yl = dt << 2 | ot >>> 30, bl = yt << 30 | bt >>> 2, Al = bt << 30 | yt >>> 2, ml = It << 6 | Dt >>> 26, Sl = Dt << 6 | It >>> 26, El = Y << 11 | k >>> 21, Rl = k << 11 | Y >>> 21, Pl = Q << 15 | _t >>> 17, vl = _t << 15 | Q >>> 17, Ml = I << 29 | O >>> 3, xl = O << 29 | I >>> 3, Bl = H << 28 | rt >>> 4, Cl = rt << 28 | H >>> 4, Il = m << 23 | at >>> 9, Nl = at << 23 | m >>> 9, Ol = E << 25 | J >>> 7, Tl = J << 25 | E >>> 7, zl = st << 21 | xt >>> 11, kl = xt << 21 | st >>> 11, Ul = Pt << 24 | wt >>> 8, Fl = wt << 24 | Pt >>> 8, Gl = Ce << 27 | Z >>> 5, Ll = Z << 27 | Ce >>> 5, Dl = tr << 20 | yi >>> 12, Kl = yi << 20 | tr >>> 12, Vl = fn << 7 | bi >>> 25, jl = bi << 7 | fn >>> 25, Hl = er << 8 | _e >>> 24, Yl = _e << 8 | er >>> 24, Ql = Ge << 14 | rr >>> 18, Wl = rr << 14 | Ge >>> 18;
    n[0] = re ^ ~Vt & El, n[1] = ka ^ ~Ft & Rl, n[10] = Bl ^ ~Dl & h, n[11] = Cl ^ ~Kl & S, n[20] = Kt ^ ~ml & Ol, n[21] = Gt ^ ~Sl & Tl, n[30] = Gl ^ ~g & hl, n[31] = Ll ^ ~l & pl, n[40] = bl ^ ~Il & Vl, n[41] = Al ^ ~Nl & jl, n[2] = Vt ^ ~El & zl, n[3] = Ft ^ ~Rl & kl, n[12] = Dl ^ ~h & dl, n[13] = Kl ^ ~S & wl, n[22] = ml ^ ~Ol & Hl, n[23] = Sl ^ ~Tl & Yl, n[32] = g ^ ~hl & Pl, n[33] = l ^ ~pl & vl, n[42] = Il ^ ~Vl & C, n[43] = Nl ^ ~jl & K, n[4] = El ^ ~zl & Ql, n[5] = Rl ^ ~kl & Wl, n[14] = h ^ ~dl & Ml, n[15] = S ^ ~wl & xl, n[24] = Ol ^ ~Hl & q, n[25] = Tl ^ ~Yl & mt, n[34] = hl ^ ~Pl & Ul, n[35] = pl ^ ~vl & Fl, n[44] = Vl ^ ~C & gl, n[45] = jl ^ ~K & yl, n[6] = zl ^ ~Ql & re, n[7] = kl ^ ~Wl & ka, n[16] = dl ^ ~Ml & Bl, n[17] = wl ^ ~xl & Cl, n[26] = Hl ^ ~q & Kt, n[27] = Yl ^ ~mt & Gt, n[36] = Pl ^ ~Ul & Gl, n[37] = vl ^ ~Fl & Ll, n[46] = C ^ ~gl & bl, n[47] = K ^ ~yl & Al, n[8] = Ql ^ ~re & Vt, n[9] = Wl ^ ~ka & Ft, n[18] = Ml ^ ~Bl & Dl, n[19] = xl ^ ~Cl & Kl, n[28] = q ^ ~Kt & ml, n[29] = mt ^ ~Gt & Sl, n[38] = Ul ^ ~Gl & g, n[39] = Fl ^ ~Ll & l, n[48] = gl ^ ~bl & Il, n[49] = yl ^ ~Al & Nl, n[0] ^= id[t * 2], n[1] ^= id[t * 2 + 1];
  }
};
const I_ = Fy;
function Oa() {
  this.state = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ], this.blockSize = null, this.count = 0, this.squeezing = !1;
}
Oa.prototype.initialize = function(n, t) {
  for (let e = 0; e < 50; ++e) this.state[e] = 0;
  this.blockSize = n / 8, this.count = 0, this.squeezing = !1;
};
Oa.prototype.absorb = function(n) {
  for (let t = 0; t < n.length; ++t)
    this.state[~~(this.count / 4)] ^= n[t] << 8 * (this.count % 4), this.count += 1, this.count === this.blockSize && (I_.p1600(this.state), this.count = 0);
};
Oa.prototype.absorbLastFewBits = function(n) {
  this.state[~~(this.count / 4)] ^= n << 8 * (this.count % 4), n & 128 && this.count === this.blockSize - 1 && I_.p1600(this.state), this.state[~~((this.blockSize - 1) / 4)] ^= 128 << 8 * ((this.blockSize - 1) % 4), I_.p1600(this.state), this.count = 0, this.squeezing = !0;
};
Oa.prototype.squeeze = function(n) {
  this.squeezing || this.absorbLastFewBits(1);
  const t = ne.alloc(n);
  for (let e = 0; e < n; ++e)
    t[e] = this.state[~~(this.count / 4)] >>> 8 * (this.count % 4) & 255, this.count += 1, this.count === this.blockSize && (I_.p1600(this.state), this.count = 0);
  return t;
};
Oa.prototype.copy = function(n) {
  for (let t = 0; t < 50; ++t) n.state[t] = this.state[t];
  n.blockSize = this.blockSize, n.count = this.count, n.squeezing = this.squeezing;
};
var lP = Oa, uP = _P(lP);
const sd = /* @__PURE__ */ H0(uP);
var Gy = { exports: {} };
(function(n, t) {
  (function(e, r) {
    n.exports = r();
  })(Fn, function() {
    var e = function(s, a) {
      if (a = a || {}, typeof s != "function")
        throw new i("fetch must be a function");
      if (typeof a != "object")
        throw new i("defaults must be an object");
      if (a.retries !== void 0 && !r(a.retries))
        throw new i("retries must be a positive integer");
      if (a.retryDelay !== void 0 && !r(a.retryDelay) && typeof a.retryDelay != "function")
        throw new i("retryDelay must be a positive integer or a function returning a positive integer");
      if (a.retryOn !== void 0 && !Array.isArray(a.retryOn) && typeof a.retryOn != "function")
        throw new i("retryOn property expects an array or function");
      var c = {
        retries: 3,
        retryDelay: 1e3,
        retryOn: []
      };
      return a = Object.assign(c, a), function(p, f) {
        var d = a.retries, y = a.retryDelay, b = a.retryOn;
        if (f && f.retries !== void 0)
          if (r(f.retries))
            d = f.retries;
          else
            throw new i("retries must be a positive integer");
        if (f && f.retryDelay !== void 0)
          if (r(f.retryDelay) || typeof f.retryDelay == "function")
            y = f.retryDelay;
          else
            throw new i("retryDelay must be a positive integer or a function returning a positive integer");
        if (f && f.retryOn)
          if (Array.isArray(f.retryOn) || typeof f.retryOn == "function")
            b = f.retryOn;
          else
            throw new i("retryOn property expects an array or function");
        return new Promise(function(v, R) {
          var M = function(B) {
            var N = typeof Request < "u" && p instanceof Request ? p.clone() : p;
            s(N, f).then(function(G) {
              if (Array.isArray(b) && b.indexOf(G.status) === -1)
                v(G);
              else if (typeof b == "function")
                try {
                  return Promise.resolve(b(B, null, G)).then(function(D) {
                    D ? A(B, null, G) : v(G);
                  }).catch(R);
                } catch (D) {
                  R(D);
                }
              else
                B < d ? A(B, null, G) : v(G);
            }).catch(function(G) {
              if (typeof b == "function")
                try {
                  Promise.resolve(b(B, G, null)).then(function(D) {
                    D ? A(B, G, null) : R(G);
                  }).catch(function(D) {
                    R(D);
                  });
                } catch (D) {
                  R(D);
                }
              else B < d ? A(B, G, null) : R(G);
            });
          };
          function A(B, N, G) {
            var D = typeof y == "function" ? y(B, N, G) : y;
            setTimeout(function() {
              M(++B);
            }, D);
          }
          M(0);
        });
      };
    };
    function r(s) {
      return Number.isInteger(s) && s >= 0;
    }
    function i(s) {
      this.name = "ArgumentError", this.message = s;
    }
    return e;
  });
})(Gy);
var fP = Gy.exports;
const hP = /* @__PURE__ */ H0(fP), pP = () => (async (n) => {
  try {
    return typeof MessageChannel < "u" && new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(n);
  } catch {
    return !1;
  }
})(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 4, 1, 3, 1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16, 2, 0, 26, 11]));
var N_ = typeof ba < "u" ? ba : typeof self < "u" ? self : typeof window < "u" ? window : {};
function Ly(n, t) {
  return new Promise((e) => {
    n.addEventListener("message", function r({ data: i }) {
      (i == null ? void 0 : i.type) === t && (n.removeEventListener("message", r), e(i));
    });
  });
}
Ly(self, "wasm_bindgen_worker_init").then(async ({ init: n, receiver: t }) => {
  const e = await Promise.resolve().then(function() {
    return kP;
  });
  await e.default(n), postMessage({ type: "wasm_bindgen_worker_ready" }), e.wbg_rayon_start_worker(t);
});
async function dP(n, t, e) {
  if (e.numThreads() === 0)
    throw new Error("num_threads must be > 0.");
  const r = {
    type: "wasm_bindgen_worker_init",
    init: { module_or_path: n, memory: t },
    receiver: e.receiver()
  };
  await Promise.all(
    Array.from({ length: e.numThreads() }, async () => {
      let i;
      try {
        i = new Worker(
          new URL(
            /* @vite-ignore */
            "/workerHelpers.js",
            import.meta.url
          ),
          {
            type: "module"
          }
        );
      } catch {
        const c = await (await fetch("/workerHelpers.js")).blob(), _ = URL.createObjectURL(c);
        i = new Worker(_);
      }
      return i.postMessage(r), await Ly(i, "wasm_bindgen_worker_ready"), i;
    })
  ), e.build();
}
let o;
function Qa(n) {
  const t = o.__externref_table_alloc();
  return o.__wbindgen_export_2.set(t, n), t;
}
function Cs(n, t) {
  try {
    return n.apply(this, t);
  } catch (e) {
    const r = Qa(e);
    o.__wbindgen_exn_store(r);
  }
}
const Dy = typeof TextDecoder < "u" ? new TextDecoder("utf-8", { ignoreBOM: !0, fatal: !0 }) : { decode: () => {
  throw Error("TextDecoder not available");
} };
typeof TextDecoder < "u" && Dy.decode();
let Wa = null;
function xo() {
  return (Wa === null || Wa.buffer !== o.memory.buffer) && (Wa = new Uint8Array(o.memory.buffer)), Wa;
}
function Wn(n, t) {
  return n = n >>> 0, Dy.decode(xo().slice(n, n + t));
}
let z = 0;
const Ky = typeof TextEncoder < "u" ? new TextEncoder("utf-8") : { encode: () => {
  throw Error("TextEncoder not available");
} }, wP = function(n, t) {
  const e = Ky.encode(n);
  return t.set(e), {
    read: n.length,
    written: e.length
  };
};
function Wc(n, t, e) {
  if (e === void 0) {
    const c = Ky.encode(n), _ = t(c.length, 1) >>> 0;
    return xo().subarray(_, _ + c.length).set(c), z = c.length, _;
  }
  let r = n.length, i = t(r, 1) >>> 0;
  const s = xo();
  let a = 0;
  for (; a < r; a++) {
    const c = n.charCodeAt(a);
    if (c > 127) break;
    s[i + a] = c;
  }
  if (a !== r) {
    a !== 0 && (n = n.slice(a)), i = e(i, r, r = a + n.length * 3, 1) >>> 0;
    const c = xo().subarray(i + a, i + r), _ = wP(n, c);
    a += _.written, i = e(i, r, a, 1) >>> 0;
  }
  return z = a, i;
}
let Ja = null;
function gr() {
  return (Ja === null || Ja.buffer !== o.memory.buffer) && (Ja = new DataView(o.memory.buffer)), Ja;
}
function Ai(n) {
  return n == null;
}
function vf(n) {
  const t = typeof n;
  if (t == "number" || t == "boolean" || n == null)
    return `${n}`;
  if (t == "string")
    return `"${n}"`;
  if (t == "symbol") {
    const i = n.description;
    return i == null ? "Symbol" : `Symbol(${i})`;
  }
  if (t == "function") {
    const i = n.name;
    return typeof i == "string" && i.length > 0 ? `Function(${i})` : "Function";
  }
  if (Array.isArray(n)) {
    const i = n.length;
    let s = "[";
    i > 0 && (s += vf(n[0]));
    for (let a = 1; a < i; a++)
      s += ", " + vf(n[a]);
    return s += "]", s;
  }
  const e = /\[object ([^\]]+)\]/.exec(toString.call(n));
  let r;
  if (e && e.length > 1)
    r = e[1];
  else
    return toString.call(n);
  if (r == "Object")
    try {
      return "Object(" + JSON.stringify(n) + ")";
    } catch {
      return "Object";
    }
  return n instanceof Error ? `${n.name}: ${n.message}
${n.stack}` : r;
}
function x(n, t) {
  if (!(n instanceof t))
    throw new Error(`expected instance of ${t.name}`);
}
function u(n) {
  const t = o.__wbindgen_export_2.get(n);
  return o.__externref_table_dealloc(n), t;
}
function L(n, t) {
  return n = n >>> 0, xo().subarray(n / 1, n / 1 + t);
}
function F(n, t) {
  const e = t(n.length * 1, 1) >>> 0;
  return xo().set(n, e / 1), z = n.length, e;
}
function Vy() {
  o.init_panic_hook();
}
function gP(n) {
  x(n, fc);
  const t = o.set_server_key(n.__wbg_ptr);
  if (t[1])
    throw u(t[0]);
}
function yP(n) {
  let t, e;
  try {
    const r = o.shortint_pke_params_name(n);
    return t = r[0], e = r[1], Wn(r[0], r[1]);
  } finally {
    o.__wbindgen_free(t, e, 1);
  }
}
function bP(n) {
  let t, e;
  try {
    const r = o.shortint_params_name(n);
    return t = r[0], e = r[1], Wn(r[0], r[1]);
  } finally {
    o.__wbindgen_free(t, e, 1);
  }
}
function jy(n) {
  return o.initThreadPool(n);
}
function AP(n) {
  o.wbg_rayon_start_worker(n);
}
const mP = Object.freeze({
  Big: 0,
  0: "Big",
  Small: 1,
  1: "Small"
}), SP = Object.freeze({
  Default: 0,
  0: "Default",
  TfheLib: 1,
  1: "TfheLib",
  DefaultKsPbs: 2,
  2: "DefaultKsPbs",
  TfheLibKsPbs: 3,
  3: "TfheLibKsPbs"
}), EP = Object.freeze({
  Bool: 0,
  0: "Bool",
  Uint2: 1,
  1: "Uint2",
  Uint4: 2,
  2: "Uint4",
  Uint6: 3,
  3: "Uint6",
  Uint8: 4,
  4: "Uint8",
  Uint10: 5,
  5: "Uint10",
  Uint12: 6,
  6: "Uint12",
  Uint14: 7,
  7: "Uint14",
  Uint16: 8,
  8: "Uint16",
  Uint32: 9,
  9: "Uint32",
  Uint64: 10,
  10: "Uint64",
  Uint128: 11,
  11: "Uint128",
  Uint160: 12,
  12: "Uint160",
  Uint256: 13,
  13: "Uint256",
  Uint512: 14,
  14: "Uint512",
  Uint1024: 15,
  15: "Uint1024",
  Uint2048: 16,
  16: "Uint2048",
  Int2: 17,
  17: "Int2",
  Int4: 18,
  18: "Int4",
  Int6: 19,
  19: "Int6",
  Int8: 20,
  20: "Int8",
  Int10: 21,
  21: "Int10",
  Int12: 22,
  22: "Int12",
  Int14: 23,
  23: "Int14",
  Int16: 24,
  24: "Int16",
  Int32: 25,
  25: "Int32",
  Int64: 26,
  26: "Int64",
  Int128: 27,
  27: "Int128",
  Int160: 28,
  28: "Int160",
  Int256: 29,
  29: "Int256",
  AsciiString: 30,
  30: "AsciiString"
}), RP = Object.freeze({
  PARAM_PKE_MESSAGE_2_CARRY_2_KS_PBS_TUNIFORM_2M128: 0,
  0: "PARAM_PKE_MESSAGE_2_CARRY_2_KS_PBS_TUNIFORM_2M128",
  V1_0_PARAM_PKE_MESSAGE_2_CARRY_2_KS_PBS_TUNIFORM_2M128: 1,
  1: "V1_0_PARAM_PKE_MESSAGE_2_CARRY_2_KS_PBS_TUNIFORM_2M128",
  V1_0_PARAM_PKE_MESSAGE_2_CARRY_2_KS_PBS_TUNIFORM_2M128_ZKV1: 2,
  2: "V1_0_PARAM_PKE_MESSAGE_2_CARRY_2_KS_PBS_TUNIFORM_2M128_ZKV1",
  V0_11_PARAM_PKE_MESSAGE_2_CARRY_2_KS_PBS_TUNIFORM_2M64: 3,
  3: "V0_11_PARAM_PKE_MESSAGE_2_CARRY_2_KS_PBS_TUNIFORM_2M64",
  V0_11_PARAM_PKE_MESSAGE_2_CARRY_2_KS_PBS_TUNIFORM_2M64_ZKV1: 4,
  4: "V0_11_PARAM_PKE_MESSAGE_2_CARRY_2_KS_PBS_TUNIFORM_2M64_ZKV1"
}), PP = Object.freeze({
  Big: 0,
  0: "Big",
  Small: 1,
  1: "Small"
}), vP = Object.freeze({
  KeyswitchBootstrap: 0,
  0: "KeyswitchBootstrap",
  BootstrapKeyswitch: 1,
  1: "BootstrapKeyswitch"
}), MP = Object.freeze({
  PARAM_MESSAGE_2_CARRY_2_KS_PBS_TUNIFORM_2M128: 0,
  0: "PARAM_MESSAGE_2_CARRY_2_KS_PBS_TUNIFORM_2M128",
  V1_0_PARAM_MESSAGE_1_CARRY_0_KS_PBS_GAUSSIAN_2M128: 1,
  1: "V1_0_PARAM_MESSAGE_1_CARRY_0_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_1_CARRY_1_KS_PBS_GAUSSIAN_2M128: 2,
  2: "V1_0_PARAM_MESSAGE_1_CARRY_1_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_2_CARRY_0_KS_PBS_GAUSSIAN_2M128: 3,
  3: "V1_0_PARAM_MESSAGE_2_CARRY_0_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_1_CARRY_2_KS_PBS_GAUSSIAN_2M128: 4,
  4: "V1_0_PARAM_MESSAGE_1_CARRY_2_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_2_CARRY_1_KS_PBS_GAUSSIAN_2M128: 5,
  5: "V1_0_PARAM_MESSAGE_2_CARRY_1_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_3_CARRY_0_KS_PBS_GAUSSIAN_2M128: 6,
  6: "V1_0_PARAM_MESSAGE_3_CARRY_0_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_1_CARRY_3_KS_PBS_GAUSSIAN_2M128: 7,
  7: "V1_0_PARAM_MESSAGE_1_CARRY_3_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_2_CARRY_2_KS_PBS_GAUSSIAN_2M128: 8,
  8: "V1_0_PARAM_MESSAGE_2_CARRY_2_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_3_CARRY_1_KS_PBS_GAUSSIAN_2M128: 9,
  9: "V1_0_PARAM_MESSAGE_3_CARRY_1_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_4_CARRY_0_KS_PBS_GAUSSIAN_2M128: 10,
  10: "V1_0_PARAM_MESSAGE_4_CARRY_0_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_1_CARRY_4_KS_PBS_GAUSSIAN_2M128: 11,
  11: "V1_0_PARAM_MESSAGE_1_CARRY_4_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_2_CARRY_3_KS_PBS_GAUSSIAN_2M128: 12,
  12: "V1_0_PARAM_MESSAGE_2_CARRY_3_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_3_CARRY_2_KS_PBS_GAUSSIAN_2M128: 13,
  13: "V1_0_PARAM_MESSAGE_3_CARRY_2_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_4_CARRY_1_KS_PBS_GAUSSIAN_2M128: 14,
  14: "V1_0_PARAM_MESSAGE_4_CARRY_1_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_5_CARRY_0_KS_PBS_GAUSSIAN_2M128: 15,
  15: "V1_0_PARAM_MESSAGE_5_CARRY_0_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_1_CARRY_5_KS_PBS_GAUSSIAN_2M128: 16,
  16: "V1_0_PARAM_MESSAGE_1_CARRY_5_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_2_CARRY_4_KS_PBS_GAUSSIAN_2M128: 17,
  17: "V1_0_PARAM_MESSAGE_2_CARRY_4_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_3_CARRY_3_KS_PBS_GAUSSIAN_2M128: 18,
  18: "V1_0_PARAM_MESSAGE_3_CARRY_3_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_4_CARRY_2_KS_PBS_GAUSSIAN_2M128: 19,
  19: "V1_0_PARAM_MESSAGE_4_CARRY_2_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_5_CARRY_1_KS_PBS_GAUSSIAN_2M128: 20,
  20: "V1_0_PARAM_MESSAGE_5_CARRY_1_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_6_CARRY_0_KS_PBS_GAUSSIAN_2M128: 21,
  21: "V1_0_PARAM_MESSAGE_6_CARRY_0_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_1_CARRY_6_KS_PBS_GAUSSIAN_2M128: 22,
  22: "V1_0_PARAM_MESSAGE_1_CARRY_6_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_2_CARRY_5_KS_PBS_GAUSSIAN_2M128: 23,
  23: "V1_0_PARAM_MESSAGE_2_CARRY_5_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_3_CARRY_4_KS_PBS_GAUSSIAN_2M128: 24,
  24: "V1_0_PARAM_MESSAGE_3_CARRY_4_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_4_CARRY_3_KS_PBS_GAUSSIAN_2M128: 25,
  25: "V1_0_PARAM_MESSAGE_4_CARRY_3_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_5_CARRY_2_KS_PBS_GAUSSIAN_2M128: 26,
  26: "V1_0_PARAM_MESSAGE_5_CARRY_2_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_6_CARRY_1_KS_PBS_GAUSSIAN_2M128: 27,
  27: "V1_0_PARAM_MESSAGE_6_CARRY_1_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_7_CARRY_0_KS_PBS_GAUSSIAN_2M128: 28,
  28: "V1_0_PARAM_MESSAGE_7_CARRY_0_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_1_CARRY_7_KS_PBS_GAUSSIAN_2M128: 29,
  29: "V1_0_PARAM_MESSAGE_1_CARRY_7_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_2_CARRY_6_KS_PBS_GAUSSIAN_2M128: 30,
  30: "V1_0_PARAM_MESSAGE_2_CARRY_6_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_3_CARRY_5_KS_PBS_GAUSSIAN_2M128: 31,
  31: "V1_0_PARAM_MESSAGE_3_CARRY_5_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_4_CARRY_4_KS_PBS_GAUSSIAN_2M128: 32,
  32: "V1_0_PARAM_MESSAGE_4_CARRY_4_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_5_CARRY_3_KS_PBS_GAUSSIAN_2M128: 33,
  33: "V1_0_PARAM_MESSAGE_5_CARRY_3_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_6_CARRY_2_KS_PBS_GAUSSIAN_2M128: 34,
  34: "V1_0_PARAM_MESSAGE_6_CARRY_2_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_7_CARRY_1_KS_PBS_GAUSSIAN_2M128: 35,
  35: "V1_0_PARAM_MESSAGE_7_CARRY_1_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_8_CARRY_0_KS_PBS_GAUSSIAN_2M128: 36,
  36: "V1_0_PARAM_MESSAGE_8_CARRY_0_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_1_CARRY_1_PBS_KS_GAUSSIAN_2M128: 37,
  37: "V1_0_PARAM_MESSAGE_1_CARRY_1_PBS_KS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_2_CARRY_2_PBS_KS_GAUSSIAN_2M128: 38,
  38: "V1_0_PARAM_MESSAGE_2_CARRY_2_PBS_KS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_3_CARRY_3_PBS_KS_GAUSSIAN_2M128: 39,
  39: "V1_0_PARAM_MESSAGE_3_CARRY_3_PBS_KS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_4_CARRY_4_PBS_KS_GAUSSIAN_2M128: 40,
  40: "V1_0_PARAM_MESSAGE_4_CARRY_4_PBS_KS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_1_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 41,
  41: "V1_0_PARAM_MESSAGE_1_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_1_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 42,
  42: "V1_0_PARAM_MESSAGE_1_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_1_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 43,
  43: "V1_0_PARAM_MESSAGE_1_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_1_CARRY_5_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 44,
  44: "V1_0_PARAM_MESSAGE_1_CARRY_5_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_1_CARRY_6_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 45,
  45: "V1_0_PARAM_MESSAGE_1_CARRY_6_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_1_CARRY_7_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 46,
  46: "V1_0_PARAM_MESSAGE_1_CARRY_7_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_2_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 47,
  47: "V1_0_PARAM_MESSAGE_2_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_2_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 48,
  48: "V1_0_PARAM_MESSAGE_2_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_2_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 49,
  49: "V1_0_PARAM_MESSAGE_2_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_2_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 50,
  50: "V1_0_PARAM_MESSAGE_2_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_2_CARRY_5_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 51,
  51: "V1_0_PARAM_MESSAGE_2_CARRY_5_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_2_CARRY_6_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 52,
  52: "V1_0_PARAM_MESSAGE_2_CARRY_6_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_3_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 53,
  53: "V1_0_PARAM_MESSAGE_3_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_3_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 54,
  54: "V1_0_PARAM_MESSAGE_3_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_3_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 55,
  55: "V1_0_PARAM_MESSAGE_3_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_3_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 56,
  56: "V1_0_PARAM_MESSAGE_3_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_3_CARRY_5_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 57,
  57: "V1_0_PARAM_MESSAGE_3_CARRY_5_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_4_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 58,
  58: "V1_0_PARAM_MESSAGE_4_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_4_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 59,
  59: "V1_0_PARAM_MESSAGE_4_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_4_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 60,
  60: "V1_0_PARAM_MESSAGE_4_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_4_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 61,
  61: "V1_0_PARAM_MESSAGE_4_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_5_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 62,
  62: "V1_0_PARAM_MESSAGE_5_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_5_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 63,
  63: "V1_0_PARAM_MESSAGE_5_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_5_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 64,
  64: "V1_0_PARAM_MESSAGE_5_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_6_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 65,
  65: "V1_0_PARAM_MESSAGE_6_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_6_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 66,
  66: "V1_0_PARAM_MESSAGE_6_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_7_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 67,
  67: "V1_0_PARAM_MESSAGE_7_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_1_CARRY_1_COMPACT_PK_PBS_KS_GAUSSIAN_2M128: 68,
  68: "V1_0_PARAM_MESSAGE_1_CARRY_1_COMPACT_PK_PBS_KS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_2_CARRY_2_COMPACT_PK_PBS_KS_GAUSSIAN_2M128: 69,
  69: "V1_0_PARAM_MESSAGE_2_CARRY_2_COMPACT_PK_PBS_KS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_3_CARRY_3_COMPACT_PK_PBS_KS_GAUSSIAN_2M128: 70,
  70: "V1_0_PARAM_MESSAGE_3_CARRY_3_COMPACT_PK_PBS_KS_GAUSSIAN_2M128",
  V1_0_PARAM_MESSAGE_4_CARRY_4_COMPACT_PK_PBS_KS_GAUSSIAN_2M128: 71,
  71: "V1_0_PARAM_MESSAGE_4_CARRY_4_COMPACT_PK_PBS_KS_GAUSSIAN_2M128",
  V0_11_PARAM_MESSAGE_1_CARRY_0_KS_PBS_GAUSSIAN_2M64: 72,
  72: "V0_11_PARAM_MESSAGE_1_CARRY_0_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_1_CARRY_1_KS_PBS_GAUSSIAN_2M64: 73,
  73: "V0_11_PARAM_MESSAGE_1_CARRY_1_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_2_CARRY_0_KS_PBS_GAUSSIAN_2M64: 74,
  74: "V0_11_PARAM_MESSAGE_2_CARRY_0_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_1_CARRY_2_KS_PBS_GAUSSIAN_2M64: 75,
  75: "V0_11_PARAM_MESSAGE_1_CARRY_2_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_2_CARRY_1_KS_PBS_GAUSSIAN_2M64: 76,
  76: "V0_11_PARAM_MESSAGE_2_CARRY_1_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_3_CARRY_0_KS_PBS_GAUSSIAN_2M64: 77,
  77: "V0_11_PARAM_MESSAGE_3_CARRY_0_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_1_CARRY_3_KS_PBS_GAUSSIAN_2M64: 78,
  78: "V0_11_PARAM_MESSAGE_1_CARRY_3_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_2_CARRY_2_KS_PBS_GAUSSIAN_2M64: 79,
  79: "V0_11_PARAM_MESSAGE_2_CARRY_2_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_3_CARRY_1_KS_PBS_GAUSSIAN_2M64: 80,
  80: "V0_11_PARAM_MESSAGE_3_CARRY_1_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_4_CARRY_0_KS_PBS_GAUSSIAN_2M64: 81,
  81: "V0_11_PARAM_MESSAGE_4_CARRY_0_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_1_CARRY_4_KS_PBS_GAUSSIAN_2M64: 82,
  82: "V0_11_PARAM_MESSAGE_1_CARRY_4_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_2_CARRY_3_KS_PBS_GAUSSIAN_2M64: 83,
  83: "V0_11_PARAM_MESSAGE_2_CARRY_3_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_3_CARRY_2_KS_PBS_GAUSSIAN_2M64: 84,
  84: "V0_11_PARAM_MESSAGE_3_CARRY_2_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_4_CARRY_1_KS_PBS_GAUSSIAN_2M64: 85,
  85: "V0_11_PARAM_MESSAGE_4_CARRY_1_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_5_CARRY_0_KS_PBS_GAUSSIAN_2M64: 86,
  86: "V0_11_PARAM_MESSAGE_5_CARRY_0_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_1_CARRY_5_KS_PBS_GAUSSIAN_2M64: 87,
  87: "V0_11_PARAM_MESSAGE_1_CARRY_5_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_2_CARRY_4_KS_PBS_GAUSSIAN_2M64: 88,
  88: "V0_11_PARAM_MESSAGE_2_CARRY_4_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_3_CARRY_3_KS_PBS_GAUSSIAN_2M64: 89,
  89: "V0_11_PARAM_MESSAGE_3_CARRY_3_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_4_CARRY_2_KS_PBS_GAUSSIAN_2M64: 90,
  90: "V0_11_PARAM_MESSAGE_4_CARRY_2_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_5_CARRY_1_KS_PBS_GAUSSIAN_2M64: 91,
  91: "V0_11_PARAM_MESSAGE_5_CARRY_1_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_6_CARRY_0_KS_PBS_GAUSSIAN_2M64: 92,
  92: "V0_11_PARAM_MESSAGE_6_CARRY_0_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_1_CARRY_6_KS_PBS_GAUSSIAN_2M64: 93,
  93: "V0_11_PARAM_MESSAGE_1_CARRY_6_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_2_CARRY_5_KS_PBS_GAUSSIAN_2M64: 94,
  94: "V0_11_PARAM_MESSAGE_2_CARRY_5_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_3_CARRY_4_KS_PBS_GAUSSIAN_2M64: 95,
  95: "V0_11_PARAM_MESSAGE_3_CARRY_4_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_4_CARRY_3_KS_PBS_GAUSSIAN_2M64: 96,
  96: "V0_11_PARAM_MESSAGE_4_CARRY_3_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_5_CARRY_2_KS_PBS_GAUSSIAN_2M64: 97,
  97: "V0_11_PARAM_MESSAGE_5_CARRY_2_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_6_CARRY_1_KS_PBS_GAUSSIAN_2M64: 98,
  98: "V0_11_PARAM_MESSAGE_6_CARRY_1_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_7_CARRY_0_KS_PBS_GAUSSIAN_2M64: 99,
  99: "V0_11_PARAM_MESSAGE_7_CARRY_0_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_1_CARRY_7_KS_PBS_GAUSSIAN_2M64: 100,
  100: "V0_11_PARAM_MESSAGE_1_CARRY_7_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_2_CARRY_6_KS_PBS_GAUSSIAN_2M64: 101,
  101: "V0_11_PARAM_MESSAGE_2_CARRY_6_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_3_CARRY_5_KS_PBS_GAUSSIAN_2M64: 102,
  102: "V0_11_PARAM_MESSAGE_3_CARRY_5_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_4_CARRY_4_KS_PBS_GAUSSIAN_2M64: 103,
  103: "V0_11_PARAM_MESSAGE_4_CARRY_4_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_5_CARRY_3_KS_PBS_GAUSSIAN_2M64: 104,
  104: "V0_11_PARAM_MESSAGE_5_CARRY_3_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_6_CARRY_2_KS_PBS_GAUSSIAN_2M64: 105,
  105: "V0_11_PARAM_MESSAGE_6_CARRY_2_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_7_CARRY_1_KS_PBS_GAUSSIAN_2M64: 106,
  106: "V0_11_PARAM_MESSAGE_7_CARRY_1_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_8_CARRY_0_KS_PBS_GAUSSIAN_2M64: 107,
  107: "V0_11_PARAM_MESSAGE_8_CARRY_0_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_1_CARRY_1_PBS_KS_GAUSSIAN_2M64: 108,
  108: "V0_11_PARAM_MESSAGE_1_CARRY_1_PBS_KS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_2_CARRY_2_PBS_KS_GAUSSIAN_2M64: 109,
  109: "V0_11_PARAM_MESSAGE_2_CARRY_2_PBS_KS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_3_CARRY_3_PBS_KS_GAUSSIAN_2M64: 110,
  110: "V0_11_PARAM_MESSAGE_3_CARRY_3_PBS_KS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_4_CARRY_4_PBS_KS_GAUSSIAN_2M64: 111,
  111: "V0_11_PARAM_MESSAGE_4_CARRY_4_PBS_KS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_1_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 112,
  112: "V0_11_PARAM_MESSAGE_1_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_1_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 113,
  113: "V0_11_PARAM_MESSAGE_1_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_1_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 114,
  114: "V0_11_PARAM_MESSAGE_1_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_1_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 115,
  115: "V0_11_PARAM_MESSAGE_1_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_1_CARRY_5_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 116,
  116: "V0_11_PARAM_MESSAGE_1_CARRY_5_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_1_CARRY_6_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 117,
  117: "V0_11_PARAM_MESSAGE_1_CARRY_6_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_1_CARRY_7_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 118,
  118: "V0_11_PARAM_MESSAGE_1_CARRY_7_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_2_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 119,
  119: "V0_11_PARAM_MESSAGE_2_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_2_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 120,
  120: "V0_11_PARAM_MESSAGE_2_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_2_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 121,
  121: "V0_11_PARAM_MESSAGE_2_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_2_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 122,
  122: "V0_11_PARAM_MESSAGE_2_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_2_CARRY_5_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 123,
  123: "V0_11_PARAM_MESSAGE_2_CARRY_5_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_2_CARRY_6_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 124,
  124: "V0_11_PARAM_MESSAGE_2_CARRY_6_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_3_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 125,
  125: "V0_11_PARAM_MESSAGE_3_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_3_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 126,
  126: "V0_11_PARAM_MESSAGE_3_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_3_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 127,
  127: "V0_11_PARAM_MESSAGE_3_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_3_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 128,
  128: "V0_11_PARAM_MESSAGE_3_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_3_CARRY_5_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 129,
  129: "V0_11_PARAM_MESSAGE_3_CARRY_5_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_4_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 130,
  130: "V0_11_PARAM_MESSAGE_4_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_4_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 131,
  131: "V0_11_PARAM_MESSAGE_4_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_4_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 132,
  132: "V0_11_PARAM_MESSAGE_4_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_4_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 133,
  133: "V0_11_PARAM_MESSAGE_4_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_5_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 134,
  134: "V0_11_PARAM_MESSAGE_5_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_5_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 135,
  135: "V0_11_PARAM_MESSAGE_5_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_5_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 136,
  136: "V0_11_PARAM_MESSAGE_5_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_6_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 137,
  137: "V0_11_PARAM_MESSAGE_6_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_6_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 138,
  138: "V0_11_PARAM_MESSAGE_6_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_7_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 139,
  139: "V0_11_PARAM_MESSAGE_7_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_1_CARRY_1_COMPACT_PK_PBS_KS_GAUSSIAN_2M64: 140,
  140: "V0_11_PARAM_MESSAGE_1_CARRY_1_COMPACT_PK_PBS_KS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_2_CARRY_2_COMPACT_PK_PBS_KS_GAUSSIAN_2M64: 141,
  141: "V0_11_PARAM_MESSAGE_2_CARRY_2_COMPACT_PK_PBS_KS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_3_CARRY_3_COMPACT_PK_PBS_KS_GAUSSIAN_2M64: 142,
  142: "V0_11_PARAM_MESSAGE_3_CARRY_3_COMPACT_PK_PBS_KS_GAUSSIAN_2M64",
  V0_11_PARAM_MESSAGE_4_CARRY_4_COMPACT_PK_PBS_KS_GAUSSIAN_2M64: 143,
  143: "V0_11_PARAM_MESSAGE_4_CARRY_4_COMPACT_PK_PBS_KS_GAUSSIAN_2M64"
}), Hy = Object.freeze({
  Proof: 0,
  0: "Proof",
  Verify: 1,
  1: "Verify"
}), xP = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_boolean_free(n >>> 0, 1));
let BP = class {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, xP.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_boolean_free(t, 0);
  }
  /**
   * @param {number} parameter_choice
   * @returns {BooleanParameters}
   */
  static get_parameters(t) {
    const e = o.boolean_get_parameters(t);
    if (e[2])
      throw u(e[1]);
    return ki.__wrap(e[0]);
  }
  /**
   * @param {number} std_dev
   * @returns {BooleanNoiseDistribution}
   */
  static new_gaussian_from_std_dev(t) {
    const e = o.boolean_new_gaussian_from_std_dev(t);
    return zi.__wrap(e);
  }
  /**
   * @param {number} bound_log2
   * @returns {BooleanNoiseDistribution}
   */
  static try_new_t_uniform(t) {
    const e = o.boolean_try_new_t_uniform(t);
    if (e[2])
      throw u(e[1]);
    return zi.__wrap(e[0]);
  }
  /**
   * @param {number} lwe_dimension
   * @param {number} glwe_dimension
   * @param {number} polynomial_size
   * @param {BooleanNoiseDistribution} lwe_noise_distribution
   * @param {BooleanNoiseDistribution} glwe_noise_distribution
   * @param {number} pbs_base_log
   * @param {number} pbs_level
   * @param {number} ks_base_log
   * @param {number} ks_level
   * @param {BooleanEncryptionKeyChoice} encryption_key_choice
   * @returns {BooleanParameters}
   */
  static new_parameters(t, e, r, i, s, a, c, _, p, f) {
    x(i, zi), x(s, zi);
    const d = o.boolean_new_parameters(t, e, r, i.__wbg_ptr, s.__wbg_ptr, a, c, _, p, f);
    return ki.__wrap(d);
  }
  /**
   * @param {bigint} seed_high_bytes
   * @param {bigint} seed_low_bytes
   * @param {BooleanParameters} parameters
   * @returns {BooleanClientKey}
   */
  static new_client_key_from_seed_and_parameters(t, e, r) {
    x(r, ki);
    const i = o.boolean_new_client_key_from_seed_and_parameters(t, e, r.__wbg_ptr);
    return He.__wrap(i);
  }
  /**
   * @param {BooleanParameters} parameters
   * @returns {BooleanClientKey}
   */
  static new_client_key(t) {
    x(t, ki);
    const e = o.boolean_new_client_key(t.__wbg_ptr);
    return He.__wrap(e);
  }
  /**
   * @param {BooleanClientKey} client_key
   * @returns {BooleanPublicKey}
   */
  static new_public_key(t) {
    x(t, He);
    const e = o.boolean_new_public_key(t.__wbg_ptr);
    return Ui.__wrap(e);
  }
  /**
   * @param {BooleanClientKey} client_key
   * @returns {BooleanCompressedServerKey}
   */
  static new_compressed_server_key(t) {
    x(t, He);
    const e = o.boolean_new_compressed_server_key(t.__wbg_ptr);
    return Bo.__wrap(e);
  }
  /**
   * @param {BooleanClientKey} client_key
   * @param {boolean} message
   * @returns {BooleanCiphertext}
   */
  static encrypt(t, e) {
    x(t, He);
    const r = o.boolean_encrypt(t.__wbg_ptr, e);
    return Ar.__wrap(r);
  }
  /**
   * @param {BooleanClientKey} client_key
   * @param {boolean} message
   * @returns {BooleanCompressedCiphertext}
   */
  static encrypt_compressed(t, e) {
    x(t, He);
    const r = o.boolean_encrypt_compressed(t.__wbg_ptr, e);
    return Ti.__wrap(r);
  }
  /**
   * @param {BooleanCompressedCiphertext} compressed_ciphertext
   * @returns {BooleanCiphertext}
   */
  static decompress_ciphertext(t) {
    x(t, Ti);
    const e = o.boolean_decompress_ciphertext(t.__wbg_ptr);
    return Ar.__wrap(e);
  }
  /**
   * @param {BooleanPublicKey} public_key
   * @param {boolean} message
   * @returns {BooleanCiphertext}
   */
  static encrypt_with_public_key(t, e) {
    x(t, Ui);
    const r = o.boolean_encrypt_with_public_key(t.__wbg_ptr, e);
    return Ar.__wrap(r);
  }
  /**
   * @param {boolean} message
   * @returns {BooleanCiphertext}
   */
  static trivial_encrypt(t) {
    const e = o.boolean_trivial_encrypt(t);
    return Ar.__wrap(e);
  }
  /**
   * @param {BooleanClientKey} client_key
   * @param {BooleanCiphertext} ct
   * @returns {boolean}
   */
  static decrypt(t, e) {
    return x(t, He), x(e, Ar), o.boolean_decrypt(t.__wbg_ptr, e.__wbg_ptr) !== 0;
  }
  /**
   * @param {BooleanCiphertext} ciphertext
   * @returns {Uint8Array}
   */
  static serialize_ciphertext(t) {
    x(t, Ar);
    const e = o.boolean_serialize_ciphertext(t.__wbg_ptr);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {BooleanCiphertext}
   */
  static deserialize_ciphertext(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.boolean_deserialize_ciphertext(e, r);
    if (i[2])
      throw u(i[1]);
    return Ar.__wrap(i[0]);
  }
  /**
   * @param {BooleanCompressedCiphertext} ciphertext
   * @returns {Uint8Array}
   */
  static serialize_compressed_ciphertext(t) {
    x(t, Ti);
    const e = o.boolean_serialize_compressed_ciphertext(t.__wbg_ptr);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {BooleanCompressedCiphertext}
   */
  static deserialize_compressed_ciphertext(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.boolean_deserialize_compressed_ciphertext(e, r);
    if (i[2])
      throw u(i[1]);
    return Ti.__wrap(i[0]);
  }
  /**
   * @param {BooleanClientKey} client_key
   * @returns {Uint8Array}
   */
  static serialize_client_key(t) {
    x(t, He);
    const e = o.boolean_serialize_client_key(t.__wbg_ptr);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {BooleanClientKey}
   */
  static deserialize_client_key(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.boolean_deserialize_client_key(e, r);
    if (i[2])
      throw u(i[1]);
    return He.__wrap(i[0]);
  }
  /**
   * @param {BooleanPublicKey} public_key
   * @returns {Uint8Array}
   */
  static serialize_public_key(t) {
    x(t, Ui);
    const e = o.boolean_serialize_public_key(t.__wbg_ptr);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {BooleanPublicKey}
   */
  static deserialize_public_key(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.boolean_deserialize_public_key(e, r);
    if (i[2])
      throw u(i[1]);
    return Ui.__wrap(i[0]);
  }
  /**
   * @param {BooleanCompressedServerKey} server_key
   * @returns {Uint8Array}
   */
  static serialize_compressed_server_key(t) {
    x(t, Bo);
    const e = o.boolean_serialize_compressed_server_key(t.__wbg_ptr);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {BooleanCompressedServerKey}
   */
  static deserialize_compressed_server_key(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.boolean_deserialize_compressed_server_key(e, r);
    if (i[2])
      throw u(i[1]);
    return Bo.__wrap(i[0]);
  }
};
const od = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_booleanciphertext_free(n >>> 0, 1));
class Ar {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Ar.prototype);
    return e.__wbg_ptr = t, od.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, od.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_booleanciphertext_free(t, 0);
  }
}
const ad = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_booleanclientkey_free(n >>> 0, 1));
class He {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(He.prototype);
    return e.__wbg_ptr = t, ad.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, ad.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_booleanclientkey_free(t, 0);
  }
}
const cd = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_booleancompressedciphertext_free(n >>> 0, 1));
class Ti {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Ti.prototype);
    return e.__wbg_ptr = t, cd.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, cd.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_booleancompressedciphertext_free(t, 0);
  }
}
const _d = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_booleancompressedserverkey_free(n >>> 0, 1));
class Bo {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Bo.prototype);
    return e.__wbg_ptr = t, _d.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, _d.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_booleancompressedserverkey_free(t, 0);
  }
}
const ld = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_booleannoisedistribution_free(n >>> 0, 1));
class zi {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(zi.prototype);
    return e.__wbg_ptr = t, ld.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, ld.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_booleannoisedistribution_free(t, 0);
  }
}
const ud = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_booleanparameters_free(n >>> 0, 1));
class ki {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(ki.prototype);
    return e.__wbg_ptr = t, ud.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, ud.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_booleanparameters_free(t, 0);
  }
}
const fd = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_booleanpublickey_free(n >>> 0, 1));
class Ui {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Ui.prototype);
    return e.__wbg_ptr = t, fd.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, fd.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_booleanpublickey_free(t, 0);
  }
}
const hd = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_compactciphertextlist_free(n >>> 0, 1));
class hi {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(hi.prototype);
    return e.__wbg_ptr = t, hd.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, hd.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_compactciphertextlist_free(t, 0);
  }
  /**
   * @param {TfheCompactPublicKey} public_key
   * @returns {CompactCiphertextListBuilder}
   */
  static builder(t) {
    x(t, Fe);
    const e = o.compactciphertextlist_builder(t.__wbg_ptr);
    if (e[2])
      throw u(e[1]);
    return Uc.__wrap(e[0]);
  }
  /**
   * @returns {number}
   */
  len() {
    return o.compactciphertextlist_len(this.__wbg_ptr) >>> 0;
  }
  /**
   * @returns {boolean}
   */
  is_empty() {
    return o.compactciphertextlist_is_empty(this.__wbg_ptr) !== 0;
  }
  /**
   * @param {number} index
   * @returns {FheTypes | undefined}
   */
  get_kind_of(t) {
    const e = o.compactciphertextlist_get_kind_of(this.__wbg_ptr, t);
    return e === 31 ? void 0 : e;
  }
  /**
   * @returns {CompactCiphertextListExpander}
   */
  expand() {
    const t = o.compactciphertextlist_expand(this.__wbg_ptr);
    if (t[2])
      throw u(t[1]);
    return Ca.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.compactciphertextlist_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompactCiphertextList}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.compactciphertextlist_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return hi.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.compactciphertextlist_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompactCiphertextList}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.compactciphertextlist_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return hi.__wrap(s[0]);
  }
}
const pd = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_compactciphertextlistbuilder_free(n >>> 0, 1));
class Uc {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Uc.prototype);
    return e.__wbg_ptr = t, pd.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, pd.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_compactciphertextlistbuilder_free(t, 0);
  }
  /**
   * @param {number} value
   */
  push_u2(t) {
    const e = o.compactciphertextlistbuilder_push_u2(this.__wbg_ptr, t);
    if (e[1])
      throw u(e[0]);
  }
  /**
   * @param {number} value
   */
  push_u4(t) {
    const e = o.compactciphertextlistbuilder_push_u4(this.__wbg_ptr, t);
    if (e[1])
      throw u(e[0]);
  }
  /**
   * @param {number} value
   */
  push_u6(t) {
    const e = o.compactciphertextlistbuilder_push_u6(this.__wbg_ptr, t);
    if (e[1])
      throw u(e[0]);
  }
  /**
   * @param {number} value
   */
  push_u8(t) {
    const e = o.compactciphertextlistbuilder_push_u8(this.__wbg_ptr, t);
    if (e[1])
      throw u(e[0]);
  }
  /**
   * @param {number} value
   */
  push_u10(t) {
    const e = o.compactciphertextlistbuilder_push_u10(this.__wbg_ptr, t);
    if (e[1])
      throw u(e[0]);
  }
  /**
   * @param {number} value
   */
  push_u12(t) {
    const e = o.compactciphertextlistbuilder_push_u12(this.__wbg_ptr, t);
    if (e[1])
      throw u(e[0]);
  }
  /**
   * @param {number} value
   */
  push_u14(t) {
    const e = o.compactciphertextlistbuilder_push_u14(this.__wbg_ptr, t);
    if (e[1])
      throw u(e[0]);
  }
  /**
   * @param {number} value
   */
  push_u16(t) {
    const e = o.compactciphertextlistbuilder_push_u16(this.__wbg_ptr, t);
    if (e[1])
      throw u(e[0]);
  }
  /**
   * @param {number} value
   */
  push_u32(t) {
    const e = o.compactciphertextlistbuilder_push_u32(this.__wbg_ptr, t);
    if (e[1])
      throw u(e[0]);
  }
  /**
   * @param {bigint} value
   */
  push_u64(t) {
    const e = o.compactciphertextlistbuilder_push_u64(this.__wbg_ptr, t);
    if (e[1])
      throw u(e[0]);
  }
  /**
   * @param {number} value
   */
  push_i2(t) {
    const e = o.compactciphertextlistbuilder_push_i2(this.__wbg_ptr, t);
    if (e[1])
      throw u(e[0]);
  }
  /**
   * @param {number} value
   */
  push_i4(t) {
    const e = o.compactciphertextlistbuilder_push_i4(this.__wbg_ptr, t);
    if (e[1])
      throw u(e[0]);
  }
  /**
   * @param {number} value
   */
  push_i6(t) {
    const e = o.compactciphertextlistbuilder_push_i6(this.__wbg_ptr, t);
    if (e[1])
      throw u(e[0]);
  }
  /**
   * @param {number} value
   */
  push_i8(t) {
    const e = o.compactciphertextlistbuilder_push_i8(this.__wbg_ptr, t);
    if (e[1])
      throw u(e[0]);
  }
  /**
   * @param {number} value
   */
  push_i10(t) {
    const e = o.compactciphertextlistbuilder_push_i10(this.__wbg_ptr, t);
    if (e[1])
      throw u(e[0]);
  }
  /**
   * @param {number} value
   */
  push_i12(t) {
    const e = o.compactciphertextlistbuilder_push_i12(this.__wbg_ptr, t);
    if (e[1])
      throw u(e[0]);
  }
  /**
   * @param {number} value
   */
  push_i14(t) {
    const e = o.compactciphertextlistbuilder_push_i14(this.__wbg_ptr, t);
    if (e[1])
      throw u(e[0]);
  }
  /**
   * @param {number} value
   */
  push_i16(t) {
    const e = o.compactciphertextlistbuilder_push_i16(this.__wbg_ptr, t);
    if (e[1])
      throw u(e[0]);
  }
  /**
   * @param {number} value
   */
  push_i32(t) {
    const e = o.compactciphertextlistbuilder_push_i32(this.__wbg_ptr, t);
    if (e[1])
      throw u(e[0]);
  }
  /**
   * @param {bigint} value
   */
  push_i64(t) {
    const e = o.compactciphertextlistbuilder_push_i64(this.__wbg_ptr, t);
    if (e[1])
      throw u(e[0]);
  }
  /**
   * @param {any} value
   */
  push_u128(t) {
    const e = o.compactciphertextlistbuilder_push_u128(this.__wbg_ptr, t);
    if (e[1])
      throw u(e[0]);
  }
  /**
   * @param {any} value
   */
  push_u160(t) {
    const e = o.compactciphertextlistbuilder_push_u160(this.__wbg_ptr, t);
    if (e[1])
      throw u(e[0]);
  }
  /**
   * @param {any} value
   */
  push_u256(t) {
    const e = o.compactciphertextlistbuilder_push_u256(this.__wbg_ptr, t);
    if (e[1])
      throw u(e[0]);
  }
  /**
   * @param {any} value
   */
  push_u512(t) {
    const e = o.compactciphertextlistbuilder_push_u512(this.__wbg_ptr, t);
    if (e[1])
      throw u(e[0]);
  }
  /**
   * @param {any} value
   */
  push_u1024(t) {
    const e = o.compactciphertextlistbuilder_push_u1024(this.__wbg_ptr, t);
    if (e[1])
      throw u(e[0]);
  }
  /**
   * @param {any} value
   */
  push_u2048(t) {
    const e = o.compactciphertextlistbuilder_push_u2048(this.__wbg_ptr, t);
    if (e[1])
      throw u(e[0]);
  }
  /**
   * @param {any} value
   */
  push_i128(t) {
    const e = o.compactciphertextlistbuilder_push_i128(this.__wbg_ptr, t);
    if (e[1])
      throw u(e[0]);
  }
  /**
   * @param {any} value
   */
  push_i160(t) {
    const e = o.compactciphertextlistbuilder_push_i160(this.__wbg_ptr, t);
    if (e[1])
      throw u(e[0]);
  }
  /**
   * @param {any} value
   */
  push_i256(t) {
    const e = o.compactciphertextlistbuilder_push_i256(this.__wbg_ptr, t);
    if (e[1])
      throw u(e[0]);
  }
  /**
   * @param {boolean} value
   */
  push_boolean(t) {
    const e = o.compactciphertextlistbuilder_push_boolean(this.__wbg_ptr, t);
    if (e[1])
      throw u(e[0]);
  }
  /**
   * @returns {CompactCiphertextList}
   */
  build() {
    const t = o.compactciphertextlistbuilder_build(this.__wbg_ptr);
    if (t[2])
      throw u(t[1]);
    return hi.__wrap(t[0]);
  }
  /**
   * @returns {CompactCiphertextList}
   */
  build_packed() {
    const t = o.compactciphertextlistbuilder_build_packed(this.__wbg_ptr);
    if (t[2])
      throw u(t[1]);
    return hi.__wrap(t[0]);
  }
  /**
   * @param {CompactPkeCrs} crs
   * @param {Uint8Array} metadata
   * @param {ZkComputeLoad} compute_load
   * @returns {ProvenCompactCiphertextList}
   */
  build_with_proof_packed(t, e, r) {
    x(t, qe);
    const i = F(e, o.__wbindgen_malloc), s = z, a = o.compactciphertextlistbuilder_build_with_proof_packed(this.__wbg_ptr, t.__wbg_ptr, i, s, r);
    if (a[2])
      throw u(a[1]);
    return Co.__wrap(a[0]);
  }
}
const dd = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_compactciphertextlistexpander_free(n >>> 0, 1));
class Ca {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Ca.prototype);
    return e.__wbg_ptr = t, dd.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, dd.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_compactciphertextlistexpander_free(t, 0);
  }
  /**
   * @param {number} index
   * @returns {FheUint2}
   */
  get_uint2(t) {
    const e = o.compactciphertextlistexpander_get_uint2(this.__wbg_ptr, t);
    if (e[2])
      throw u(e[1]);
    return qr.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint4}
   */
  get_uint4(t) {
    const e = o.compactciphertextlistexpander_get_uint4(this.__wbg_ptr, t);
    if (e[2])
      throw u(e[1]);
    return en.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint6}
   */
  get_uint6(t) {
    const e = o.compactciphertextlistexpander_get_uint6(this.__wbg_ptr, t);
    if (e[2])
      throw u(e[1]);
    return nn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint8}
   */
  get_uint8(t) {
    const e = o.compactciphertextlistexpander_get_uint8(this.__wbg_ptr, t);
    if (e[2])
      throw u(e[1]);
    return on.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint10}
   */
  get_uint10(t) {
    const e = o.compactciphertextlistexpander_get_uint10(this.__wbg_ptr, t);
    if (e[2])
      throw u(e[1]);
    return jr.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint12}
   */
  get_uint12(t) {
    const e = o.compactciphertextlistexpander_get_uint12(this.__wbg_ptr, t);
    if (e[2])
      throw u(e[1]);
    return Yr.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint14}
   */
  get_uint14(t) {
    const e = o.compactciphertextlistexpander_get_uint14(this.__wbg_ptr, t);
    if (e[2])
      throw u(e[1]);
    return Wr.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint16}
   */
  get_uint16(t) {
    const e = o.compactciphertextlistexpander_get_uint16(this.__wbg_ptr, t);
    if (e[2])
      throw u(e[1]);
    return Jr.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint32}
   */
  get_uint32(t) {
    const e = o.compactciphertextlistexpander_get_uint32(this.__wbg_ptr, t);
    if (e[2])
      throw u(e[1]);
    return tn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint64}
   */
  get_uint64(t) {
    const e = o.compactciphertextlistexpander_get_uint64(this.__wbg_ptr, t);
    if (e[2])
      throw u(e[1]);
    return sn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint128}
   */
  get_uint128(t) {
    const e = o.compactciphertextlistexpander_get_uint128(this.__wbg_ptr, t);
    if (e[2])
      throw u(e[1]);
    return Qr.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint160}
   */
  get_uint160(t) {
    const e = o.compactciphertextlistexpander_get_uint160(this.__wbg_ptr, t);
    if (e[2])
      throw u(e[1]);
    return $r.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint256}
   */
  get_uint256(t) {
    const e = o.compactciphertextlistexpander_get_uint256(this.__wbg_ptr, t);
    if (e[2])
      throw u(e[1]);
    return Xr.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint512}
   */
  get_uint512(t) {
    const e = o.compactciphertextlistexpander_get_uint512(this.__wbg_ptr, t);
    if (e[2])
      throw u(e[1]);
    return rn.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint1024}
   */
  get_uint1024(t) {
    const e = o.compactciphertextlistexpander_get_uint1024(this.__wbg_ptr, t);
    if (e[2])
      throw u(e[1]);
    return Hr.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheUint2048}
   */
  get_uint2048(t) {
    const e = o.compactciphertextlistexpander_get_uint2048(this.__wbg_ptr, t);
    if (e[2])
      throw u(e[1]);
    return Zr.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt2}
   */
  get_int2(t) {
    const e = o.compactciphertextlistexpander_get_int2(this.__wbg_ptr, t);
    if (e[2])
      throw u(e[1]);
    return Ur.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt4}
   */
  get_int4(t) {
    const e = o.compactciphertextlistexpander_get_int4(this.__wbg_ptr, t);
    if (e[2])
      throw u(e[1]);
    return Lr.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt6}
   */
  get_int6(t) {
    const e = o.compactciphertextlistexpander_get_int6(this.__wbg_ptr, t);
    if (e[2])
      throw u(e[1]);
    return Dr.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt8}
   */
  get_int8(t) {
    const e = o.compactciphertextlistexpander_get_int8(this.__wbg_ptr, t);
    if (e[2])
      throw u(e[1]);
    return Vr.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt10}
   */
  get_int10(t) {
    const e = o.compactciphertextlistexpander_get_int10(this.__wbg_ptr, t);
    if (e[2])
      throw u(e[1]);
    return Ir.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt12}
   */
  get_int12(t) {
    const e = o.compactciphertextlistexpander_get_int12(this.__wbg_ptr, t);
    if (e[2])
      throw u(e[1]);
    return Nr.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt14}
   */
  get_int14(t) {
    const e = o.compactciphertextlistexpander_get_int14(this.__wbg_ptr, t);
    if (e[2])
      throw u(e[1]);
    return Tr.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt16}
   */
  get_int16(t) {
    const e = o.compactciphertextlistexpander_get_int16(this.__wbg_ptr, t);
    if (e[2])
      throw u(e[1]);
    return zr.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt32}
   */
  get_int32(t) {
    const e = o.compactciphertextlistexpander_get_int32(this.__wbg_ptr, t);
    if (e[2])
      throw u(e[1]);
    return Gr.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt64}
   */
  get_int64(t) {
    const e = o.compactciphertextlistexpander_get_int64(this.__wbg_ptr, t);
    if (e[2])
      throw u(e[1]);
    return Kr.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt128}
   */
  get_int128(t) {
    const e = o.compactciphertextlistexpander_get_int128(this.__wbg_ptr, t);
    if (e[2])
      throw u(e[1]);
    return Or.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt160}
   */
  get_int160(t) {
    const e = o.compactciphertextlistexpander_get_int160(this.__wbg_ptr, t);
    if (e[2])
      throw u(e[1]);
    return kr.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheInt256}
   */
  get_int256(t) {
    const e = o.compactciphertextlistexpander_get_int256(this.__wbg_ptr, t);
    if (e[2])
      throw u(e[1]);
    return Fr.__wrap(e[0]);
  }
  /**
   * @param {number} index
   * @returns {FheBool}
   */
  get_bool(t) {
    const e = o.compactciphertextlistexpander_get_bool(this.__wbg_ptr, t);
    if (e[2])
      throw u(e[1]);
    return Cr.__wrap(e[0]);
  }
  /**
   * @returns {number}
   */
  len() {
    return o.compactciphertextlistexpander_len(this.__wbg_ptr) >>> 0;
  }
  /**
   * @returns {boolean}
   */
  is_empty() {
    return o.compactciphertextlistexpander_is_empty(this.__wbg_ptr) !== 0;
  }
  /**
   * @param {number} index
   * @returns {FheTypes | undefined}
   */
  get_kind_of(t) {
    const e = o.compactciphertextlistexpander_get_kind_of(this.__wbg_ptr, t);
    return e === 31 ? void 0 : e;
  }
}
const wd = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_compactpkecrs_free(n >>> 0, 1));
class qe {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(qe.prototype);
    return e.__wbg_ptr = t, wd.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, wd.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_compactpkecrs_free(t, 0);
  }
  /**
   * @param {boolean} compress
   * @returns {Uint8Array}
   */
  serialize(t) {
    const e = o.compactpkecrs_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompactPkeCrs}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.compactpkecrs_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return qe.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.compactpkecrs_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompactPkeCrs}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.compactpkecrs_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return qe.__wrap(s[0]);
  }
  /**
   * @param {TfheConfig} config
   * @param {number} max_num_bits
   * @returns {CompactPkeCrs}
   */
  static from_config(t, e) {
    x(t, bs);
    const r = o.compactpkecrs_from_config(t.__wbg_ptr, e);
    if (r[2])
      throw u(r[1]);
    return qe.__wrap(r[0]);
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompactPkeCrs}
   */
  static deserialize_from_public_params(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.compactpkecrs_deserialize_from_public_params(e, r);
    if (i[2])
      throw u(i[1]);
    return qe.__wrap(i[0]);
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompactPkeCrs}
   */
  static safe_deserialize_from_public_params(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.compactpkecrs_safe_deserialize_from_public_params(r, i, e);
    if (s[2])
      throw u(s[1]);
    return qe.__wrap(s[0]);
  }
}
const gd = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_compressedfhebool_free(n >>> 0, 1));
class Gs {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Gs.prototype);
    return e.__wbg_ptr = t, gd.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, gd.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_compressedfhebool_free(t, 0);
  }
  /**
   * @param {boolean} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheBool}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.compressedfhebool_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Gs.__wrap(r[0]);
  }
  /**
   * @returns {FheBool}
   */
  decompress() {
    const t = o.compressedfhebool_decompress(this.__wbg_ptr);
    if (t[2])
      throw u(t[1]);
    return Cr.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.compressedfhebool_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheBool}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.compressedfhebool_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return Gs.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.compressedfhebool_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheBool}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.compressedfhebool_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return Gs.__wrap(s[0]);
  }
}
const yd = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_compressedfheint10_free(n >>> 0, 1));
class Ls {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Ls.prototype);
    return e.__wbg_ptr = t, yd.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, yd.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_compressedfheint10_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt10}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.compressedfheint10_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Ls.__wrap(r[0]);
  }
  /**
   * @returns {FheInt10}
   */
  decompress() {
    const t = o.compressedfheint10_decompress(this.__wbg_ptr);
    if (t[2])
      throw u(t[1]);
    return Ir.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.compressedfheint10_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt10}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.compressedfheint10_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return Ls.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.compressedfheint10_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt10}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.compressedfheint10_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return Ls.__wrap(s[0]);
  }
}
const bd = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_compressedfheint12_free(n >>> 0, 1));
class Ds {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Ds.prototype);
    return e.__wbg_ptr = t, bd.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, bd.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_compressedfheint12_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt12}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.compressedfheint12_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Ds.__wrap(r[0]);
  }
  /**
   * @returns {FheInt12}
   */
  decompress() {
    const t = o.compressedfheint12_decompress(this.__wbg_ptr);
    if (t[2])
      throw u(t[1]);
    return Nr.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.compressedfheint12_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt12}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.compressedfheint12_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return Ds.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.compressedfheint12_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt12}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.compressedfheint12_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return Ds.__wrap(s[0]);
  }
}
const Ad = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_compressedfheint128_free(n >>> 0, 1));
class Ks {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Ks.prototype);
    return e.__wbg_ptr = t, Ad.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Ad.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_compressedfheint128_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt128}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.compressedfheint128_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Ks.__wrap(r[0]);
  }
  /**
   * @returns {FheInt128}
   */
  decompress() {
    const t = o.compressedfheint128_decompress(this.__wbg_ptr);
    if (t[2])
      throw u(t[1]);
    return Or.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.compressedfheint128_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt128}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.compressedfheint128_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return Ks.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.compressedfheint128_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt128}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.compressedfheint128_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return Ks.__wrap(s[0]);
  }
}
const md = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_compressedfheint14_free(n >>> 0, 1));
class Vs {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Vs.prototype);
    return e.__wbg_ptr = t, md.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, md.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_compressedfheint14_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt14}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.compressedfheint14_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Vs.__wrap(r[0]);
  }
  /**
   * @returns {FheInt14}
   */
  decompress() {
    const t = o.compressedfheint14_decompress(this.__wbg_ptr);
    if (t[2])
      throw u(t[1]);
    return Tr.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.compressedfheint14_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt14}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.compressedfheint14_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return Vs.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.compressedfheint14_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt14}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.compressedfheint14_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return Vs.__wrap(s[0]);
  }
}
const Sd = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_compressedfheint16_free(n >>> 0, 1));
class js {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(js.prototype);
    return e.__wbg_ptr = t, Sd.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Sd.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_compressedfheint16_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt16}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.compressedfheint16_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return js.__wrap(r[0]);
  }
  /**
   * @returns {FheInt16}
   */
  decompress() {
    const t = o.compressedfheint16_decompress(this.__wbg_ptr);
    if (t[2])
      throw u(t[1]);
    return zr.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.compressedfheint16_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt16}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.compressedfheint16_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return js.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.compressedfheint16_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt16}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.compressedfheint16_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return js.__wrap(s[0]);
  }
}
const Ed = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_compressedfheint160_free(n >>> 0, 1));
class Hs {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Hs.prototype);
    return e.__wbg_ptr = t, Ed.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Ed.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_compressedfheint160_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt160}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.compressedfheint160_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Hs.__wrap(r[0]);
  }
  /**
   * @returns {FheInt160}
   */
  decompress() {
    const t = o.compressedfheint160_decompress(this.__wbg_ptr);
    if (t[2])
      throw u(t[1]);
    return kr.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.compressedfheint160_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt160}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.compressedfheint160_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return Hs.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.compressedfheint160_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt160}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.compressedfheint160_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return Hs.__wrap(s[0]);
  }
}
const Rd = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_compressedfheint2_free(n >>> 0, 1));
class Ys {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Ys.prototype);
    return e.__wbg_ptr = t, Rd.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Rd.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_compressedfheint2_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt2}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.compressedfheint2_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Ys.__wrap(r[0]);
  }
  /**
   * @returns {FheInt2}
   */
  decompress() {
    const t = o.compressedfheint2_decompress(this.__wbg_ptr);
    if (t[2])
      throw u(t[1]);
    return Ur.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.compressedfheint2_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt2}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.compressedfheint2_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return Ys.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.compressedfheint2_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt2}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.compressedfheint2_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return Ys.__wrap(s[0]);
  }
}
const Pd = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_compressedfheint256_free(n >>> 0, 1));
class Qs {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Qs.prototype);
    return e.__wbg_ptr = t, Pd.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Pd.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_compressedfheint256_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt256}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.compressedfheint256_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Qs.__wrap(r[0]);
  }
  /**
   * @returns {FheInt256}
   */
  decompress() {
    const t = o.compressedfheint256_decompress(this.__wbg_ptr);
    if (t[2])
      throw u(t[1]);
    return Fr.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.compressedfheint256_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt256}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.compressedfheint256_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return Qs.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.compressedfheint256_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt256}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.compressedfheint256_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return Qs.__wrap(s[0]);
  }
}
const vd = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_compressedfheint32_free(n >>> 0, 1));
class Ws {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Ws.prototype);
    return e.__wbg_ptr = t, vd.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, vd.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_compressedfheint32_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt32}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.compressedfheint32_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Ws.__wrap(r[0]);
  }
  /**
   * @returns {FheInt32}
   */
  decompress() {
    const t = o.compressedfheint32_decompress(this.__wbg_ptr);
    if (t[2])
      throw u(t[1]);
    return Gr.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.compressedfheint32_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt32}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.compressedfheint32_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return Ws.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.compressedfheint32_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt32}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.compressedfheint32_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return Ws.__wrap(s[0]);
  }
}
const Md = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_compressedfheint4_free(n >>> 0, 1));
class Js {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Js.prototype);
    return e.__wbg_ptr = t, Md.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Md.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_compressedfheint4_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt4}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.compressedfheint4_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Js.__wrap(r[0]);
  }
  /**
   * @returns {FheInt4}
   */
  decompress() {
    const t = o.compressedfheint4_decompress(this.__wbg_ptr);
    if (t[2])
      throw u(t[1]);
    return Lr.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.compressedfheint4_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt4}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.compressedfheint4_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return Js.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.compressedfheint4_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt4}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.compressedfheint4_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return Js.__wrap(s[0]);
  }
}
const xd = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_compressedfheint6_free(n >>> 0, 1));
class $s {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create($s.prototype);
    return e.__wbg_ptr = t, xd.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, xd.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_compressedfheint6_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt6}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.compressedfheint6_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return $s.__wrap(r[0]);
  }
  /**
   * @returns {FheInt6}
   */
  decompress() {
    const t = o.compressedfheint6_decompress(this.__wbg_ptr);
    if (t[2])
      throw u(t[1]);
    return Dr.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.compressedfheint6_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt6}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.compressedfheint6_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return $s.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.compressedfheint6_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt6}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.compressedfheint6_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return $s.__wrap(s[0]);
  }
}
const Bd = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_compressedfheint64_free(n >>> 0, 1));
class qs {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(qs.prototype);
    return e.__wbg_ptr = t, Bd.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Bd.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_compressedfheint64_free(t, 0);
  }
  /**
   * @param {bigint} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt64}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.compressedfheint64_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return qs.__wrap(r[0]);
  }
  /**
   * @returns {FheInt64}
   */
  decompress() {
    const t = o.compressedfheint64_decompress(this.__wbg_ptr);
    if (t[2])
      throw u(t[1]);
    return Kr.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.compressedfheint64_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt64}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.compressedfheint64_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return qs.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.compressedfheint64_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt64}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.compressedfheint64_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return qs.__wrap(s[0]);
  }
}
const Cd = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_compressedfheint8_free(n >>> 0, 1));
class Zs {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Zs.prototype);
    return e.__wbg_ptr = t, Cd.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Cd.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_compressedfheint8_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheInt8}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.compressedfheint8_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Zs.__wrap(r[0]);
  }
  /**
   * @returns {FheInt8}
   */
  decompress() {
    const t = o.compressedfheint8_decompress(this.__wbg_ptr);
    if (t[2])
      throw u(t[1]);
    return Vr.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.compressedfheint8_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheInt8}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.compressedfheint8_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return Zs.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.compressedfheint8_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheInt8}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.compressedfheint8_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return Zs.__wrap(s[0]);
  }
}
const Id = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_compressedfheuint10_free(n >>> 0, 1));
class Xs {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Xs.prototype);
    return e.__wbg_ptr = t, Id.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Id.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_compressedfheuint10_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint10}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.compressedfheuint10_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Xs.__wrap(r[0]);
  }
  /**
   * @returns {FheUint10}
   */
  decompress() {
    const t = o.compressedfheuint10_decompress(this.__wbg_ptr);
    if (t[2])
      throw u(t[1]);
    return jr.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.compressedfheuint10_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint10}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.compressedfheuint10_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return Xs.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.compressedfheuint10_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint10}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.compressedfheuint10_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return Xs.__wrap(s[0]);
  }
}
const Nd = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_compressedfheuint1024_free(n >>> 0, 1));
class to {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(to.prototype);
    return e.__wbg_ptr = t, Nd.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Nd.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_compressedfheuint1024_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint1024}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.compressedfheuint1024_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return to.__wrap(r[0]);
  }
  /**
   * @returns {FheUint1024}
   */
  decompress() {
    const t = o.compressedfheuint1024_decompress(this.__wbg_ptr);
    if (t[2])
      throw u(t[1]);
    return Hr.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.compressedfheuint1024_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint1024}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.compressedfheuint1024_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return to.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.compressedfheuint1024_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint1024}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.compressedfheuint1024_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return to.__wrap(s[0]);
  }
}
const Od = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_compressedfheuint12_free(n >>> 0, 1));
class eo {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(eo.prototype);
    return e.__wbg_ptr = t, Od.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Od.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_compressedfheuint12_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint12}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.compressedfheuint12_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return eo.__wrap(r[0]);
  }
  /**
   * @returns {FheUint12}
   */
  decompress() {
    const t = o.compressedfheuint12_decompress(this.__wbg_ptr);
    if (t[2])
      throw u(t[1]);
    return Yr.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.compressedfheuint12_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint12}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.compressedfheuint12_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return eo.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.compressedfheuint12_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint12}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.compressedfheuint12_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return eo.__wrap(s[0]);
  }
}
const Td = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_compressedfheuint128_free(n >>> 0, 1));
class ro {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(ro.prototype);
    return e.__wbg_ptr = t, Td.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Td.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_compressedfheuint128_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint128}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.compressedfheuint128_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return ro.__wrap(r[0]);
  }
  /**
   * @returns {FheUint128}
   */
  decompress() {
    const t = o.compressedfheuint128_decompress(this.__wbg_ptr);
    if (t[2])
      throw u(t[1]);
    return Qr.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.compressedfheuint128_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint128}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.compressedfheuint128_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return ro.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.compressedfheuint128_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint128}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.compressedfheuint128_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return ro.__wrap(s[0]);
  }
}
const zd = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_compressedfheuint14_free(n >>> 0, 1));
class no {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(no.prototype);
    return e.__wbg_ptr = t, zd.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, zd.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_compressedfheuint14_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint14}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.compressedfheuint14_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return no.__wrap(r[0]);
  }
  /**
   * @returns {FheUint14}
   */
  decompress() {
    const t = o.compressedfheuint14_decompress(this.__wbg_ptr);
    if (t[2])
      throw u(t[1]);
    return Wr.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.compressedfheuint14_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint14}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.compressedfheuint14_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return no.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.compressedfheuint14_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint14}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.compressedfheuint14_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return no.__wrap(s[0]);
  }
}
const kd = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_compressedfheuint16_free(n >>> 0, 1));
class io {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(io.prototype);
    return e.__wbg_ptr = t, kd.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, kd.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_compressedfheuint16_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint16}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.compressedfheuint16_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return io.__wrap(r[0]);
  }
  /**
   * @returns {FheUint16}
   */
  decompress() {
    const t = o.compressedfheuint16_decompress(this.__wbg_ptr);
    if (t[2])
      throw u(t[1]);
    return Jr.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.compressedfheuint16_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint16}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.compressedfheuint16_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return io.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.compressedfheuint16_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint16}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.compressedfheuint16_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return io.__wrap(s[0]);
  }
}
const Ud = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_compressedfheuint160_free(n >>> 0, 1));
class so {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(so.prototype);
    return e.__wbg_ptr = t, Ud.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Ud.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_compressedfheuint160_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint160}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.compressedfheuint160_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return so.__wrap(r[0]);
  }
  /**
   * @returns {FheUint160}
   */
  decompress() {
    const t = o.compressedfheuint160_decompress(this.__wbg_ptr);
    if (t[2])
      throw u(t[1]);
    return $r.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.compressedfheuint160_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint160}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.compressedfheuint160_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return so.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.compressedfheuint160_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint160}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.compressedfheuint160_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return so.__wrap(s[0]);
  }
}
const Fd = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_compressedfheuint2_free(n >>> 0, 1));
class oo {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(oo.prototype);
    return e.__wbg_ptr = t, Fd.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Fd.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_compressedfheuint2_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint2}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.compressedfheuint2_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return oo.__wrap(r[0]);
  }
  /**
   * @returns {FheUint2}
   */
  decompress() {
    const t = o.compressedfheuint2_decompress(this.__wbg_ptr);
    if (t[2])
      throw u(t[1]);
    return qr.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.compressedfheuint2_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint2}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.compressedfheuint2_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return oo.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.compressedfheuint2_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint2}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.compressedfheuint2_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return oo.__wrap(s[0]);
  }
}
const Gd = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_compressedfheuint2048_free(n >>> 0, 1));
class ao {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(ao.prototype);
    return e.__wbg_ptr = t, Gd.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Gd.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_compressedfheuint2048_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint2048}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.compressedfheuint2048_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return ao.__wrap(r[0]);
  }
  /**
   * @returns {FheUint2048}
   */
  decompress() {
    const t = o.compressedfheuint2048_decompress(this.__wbg_ptr);
    if (t[2])
      throw u(t[1]);
    return Zr.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.compressedfheuint2048_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint2048}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.compressedfheuint2048_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return ao.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.compressedfheuint2048_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint2048}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.compressedfheuint2048_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return ao.__wrap(s[0]);
  }
}
const Ld = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_compressedfheuint256_free(n >>> 0, 1));
class co {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(co.prototype);
    return e.__wbg_ptr = t, Ld.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Ld.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_compressedfheuint256_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint256}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.compressedfheuint256_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return co.__wrap(r[0]);
  }
  /**
   * @returns {FheUint256}
   */
  decompress() {
    const t = o.compressedfheuint256_decompress(this.__wbg_ptr);
    if (t[2])
      throw u(t[1]);
    return Xr.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.compressedfheuint256_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint256}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.compressedfheuint256_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return co.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.compressedfheuint256_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint256}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.compressedfheuint256_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return co.__wrap(s[0]);
  }
}
const Dd = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_compressedfheuint32_free(n >>> 0, 1));
class _o {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(_o.prototype);
    return e.__wbg_ptr = t, Dd.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Dd.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_compressedfheuint32_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint32}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.compressedfheuint32_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return _o.__wrap(r[0]);
  }
  /**
   * @returns {FheUint32}
   */
  decompress() {
    const t = o.compressedfheuint32_decompress(this.__wbg_ptr);
    if (t[2])
      throw u(t[1]);
    return tn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.compressedfheuint32_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint32}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.compressedfheuint32_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return _o.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.compressedfheuint32_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint32}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.compressedfheuint32_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return _o.__wrap(s[0]);
  }
}
const Kd = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_compressedfheuint4_free(n >>> 0, 1));
class lo {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(lo.prototype);
    return e.__wbg_ptr = t, Kd.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Kd.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_compressedfheuint4_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint4}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.compressedfheuint4_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return lo.__wrap(r[0]);
  }
  /**
   * @returns {FheUint4}
   */
  decompress() {
    const t = o.compressedfheuint4_decompress(this.__wbg_ptr);
    if (t[2])
      throw u(t[1]);
    return en.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.compressedfheuint4_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint4}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.compressedfheuint4_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return lo.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.compressedfheuint4_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint4}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.compressedfheuint4_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return lo.__wrap(s[0]);
  }
}
const Vd = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_compressedfheuint512_free(n >>> 0, 1));
class uo {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(uo.prototype);
    return e.__wbg_ptr = t, Vd.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Vd.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_compressedfheuint512_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint512}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.compressedfheuint512_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return uo.__wrap(r[0]);
  }
  /**
   * @returns {FheUint512}
   */
  decompress() {
    const t = o.compressedfheuint512_decompress(this.__wbg_ptr);
    if (t[2])
      throw u(t[1]);
    return rn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.compressedfheuint512_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint512}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.compressedfheuint512_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return uo.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.compressedfheuint512_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint512}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.compressedfheuint512_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return uo.__wrap(s[0]);
  }
}
const jd = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_compressedfheuint6_free(n >>> 0, 1));
class fo {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(fo.prototype);
    return e.__wbg_ptr = t, jd.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, jd.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_compressedfheuint6_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint6}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.compressedfheuint6_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return fo.__wrap(r[0]);
  }
  /**
   * @returns {FheUint6}
   */
  decompress() {
    const t = o.compressedfheuint6_decompress(this.__wbg_ptr);
    if (t[2])
      throw u(t[1]);
    return nn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.compressedfheuint6_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint6}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.compressedfheuint6_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return fo.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.compressedfheuint6_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint6}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.compressedfheuint6_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return fo.__wrap(s[0]);
  }
}
const Hd = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_compressedfheuint64_free(n >>> 0, 1));
class ho {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(ho.prototype);
    return e.__wbg_ptr = t, Hd.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Hd.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_compressedfheuint64_free(t, 0);
  }
  /**
   * @param {bigint} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint64}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.compressedfheuint64_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return ho.__wrap(r[0]);
  }
  /**
   * @returns {FheUint64}
   */
  decompress() {
    const t = o.compressedfheuint64_decompress(this.__wbg_ptr);
    if (t[2])
      throw u(t[1]);
    return sn.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.compressedfheuint64_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint64}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.compressedfheuint64_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return ho.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.compressedfheuint64_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint64}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.compressedfheuint64_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return ho.__wrap(s[0]);
  }
}
const Yd = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_compressedfheuint8_free(n >>> 0, 1));
class po {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(po.prototype);
    return e.__wbg_ptr = t, Yd.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Yd.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_compressedfheuint8_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {CompressedFheUint8}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.compressedfheuint8_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return po.__wrap(r[0]);
  }
  /**
   * @returns {FheUint8}
   */
  decompress() {
    const t = o.compressedfheuint8_decompress(this.__wbg_ptr);
    if (t[2])
      throw u(t[1]);
    return on.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.compressedfheuint8_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {CompressedFheUint8}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.compressedfheuint8_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return po.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.compressedfheuint8_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {CompressedFheUint8}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.compressedfheuint8_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return po.__wrap(s[0]);
  }
}
const Qd = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_fhebool_free(n >>> 0, 1));
class Cr {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Cr.prototype);
    return e.__wbg_ptr = t, Qd.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Qd.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_fhebool_free(t, 0);
  }
  /**
   * @param {boolean} value
   * @param {TfheClientKey} client_key
   * @returns {FheBool}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.fhebool_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Cr.__wrap(r[0]);
  }
  /**
   * @param {boolean} value
   * @param {TfhePublicKey} public_key
   * @returns {FheBool}
   */
  static encrypt_with_public_key(t, e) {
    x(e, Mt);
    const r = o.fhebool_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Cr.__wrap(r[0]);
  }
  /**
   * @param {boolean} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheBool}
   */
  static encrypt_with_compressed_public_key(t, e) {
    x(e, Ct);
    const r = o.fhebool_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Cr.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {boolean}
   */
  decrypt(t) {
    x(t, tt);
    const e = o.fhebool_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw u(e[1]);
    return e[0] !== 0;
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.fhebool_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheBool}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.fhebool_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return Cr.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.fhebool_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheBool}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.fhebool_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return Cr.__wrap(s[0]);
  }
}
const Wd = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_fheint10_free(n >>> 0, 1));
class Ir {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Ir.prototype);
    return e.__wbg_ptr = t, Wd.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Wd.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_fheint10_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt10}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.fheint10_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Ir.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt10}
   */
  static encrypt_with_public_key(t, e) {
    x(e, Mt);
    const r = o.fheint10_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Ir.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt10}
   */
  static encrypt_with_compressed_public_key(t, e) {
    x(e, Ct);
    const r = o.fheint10_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Ir.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {number}
   */
  decrypt(t) {
    x(t, tt);
    const e = o.fheint10_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw u(e[1]);
    return e[0];
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.fheint10_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt10}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.fheint10_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return Ir.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.fheint10_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt10}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.fheint10_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return Ir.__wrap(s[0]);
  }
}
const Jd = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_fheint12_free(n >>> 0, 1));
class Nr {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Nr.prototype);
    return e.__wbg_ptr = t, Jd.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Jd.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_fheint12_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt12}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.fheint12_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Nr.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt12}
   */
  static encrypt_with_public_key(t, e) {
    x(e, Mt);
    const r = o.fheint12_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Nr.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt12}
   */
  static encrypt_with_compressed_public_key(t, e) {
    x(e, Ct);
    const r = o.fheint12_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Nr.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {number}
   */
  decrypt(t) {
    x(t, tt);
    const e = o.fheint12_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw u(e[1]);
    return e[0];
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.fheint12_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt12}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.fheint12_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return Nr.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.fheint12_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt12}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.fheint12_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return Nr.__wrap(s[0]);
  }
}
const $d = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_fheint128_free(n >>> 0, 1));
class Or {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Or.prototype);
    return e.__wbg_ptr = t, $d.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, $d.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_fheint128_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt128}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.fheint128_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Or.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt128}
   */
  static encrypt_with_public_key(t, e) {
    x(e, Mt);
    const r = o.fheint128_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Or.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt128}
   */
  static encrypt_with_compressed_public_key(t, e) {
    x(e, Ct);
    const r = o.fheint128_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Or.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    x(t, tt);
    const e = o.fheint128_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw u(e[1]);
    return u(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.fheint128_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt128}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.fheint128_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return Or.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.fheint128_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt128}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.fheint128_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return Or.__wrap(s[0]);
  }
}
const qd = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_fheint14_free(n >>> 0, 1));
class Tr {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Tr.prototype);
    return e.__wbg_ptr = t, qd.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, qd.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_fheint14_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt14}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.fheint14_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Tr.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt14}
   */
  static encrypt_with_public_key(t, e) {
    x(e, Mt);
    const r = o.fheint14_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Tr.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt14}
   */
  static encrypt_with_compressed_public_key(t, e) {
    x(e, Ct);
    const r = o.fheint14_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Tr.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {number}
   */
  decrypt(t) {
    x(t, tt);
    const e = o.fheint14_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw u(e[1]);
    return e[0];
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.fheint14_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt14}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.fheint14_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return Tr.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.fheint14_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt14}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.fheint14_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return Tr.__wrap(s[0]);
  }
}
const Zd = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_fheint16_free(n >>> 0, 1));
class zr {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(zr.prototype);
    return e.__wbg_ptr = t, Zd.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Zd.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_fheint16_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt16}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.fheint16_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return zr.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt16}
   */
  static encrypt_with_public_key(t, e) {
    x(e, Mt);
    const r = o.fheint16_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return zr.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt16}
   */
  static encrypt_with_compressed_public_key(t, e) {
    x(e, Ct);
    const r = o.fheint16_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return zr.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {number}
   */
  decrypt(t) {
    x(t, tt);
    const e = o.fheint16_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw u(e[1]);
    return e[0];
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.fheint16_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt16}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.fheint16_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return zr.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.fheint16_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt16}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.fheint16_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return zr.__wrap(s[0]);
  }
}
const Xd = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_fheint160_free(n >>> 0, 1));
class kr {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(kr.prototype);
    return e.__wbg_ptr = t, Xd.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Xd.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_fheint160_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt160}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.fheint160_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return kr.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt160}
   */
  static encrypt_with_public_key(t, e) {
    x(e, Mt);
    const r = o.fheint160_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return kr.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt160}
   */
  static encrypt_with_compressed_public_key(t, e) {
    x(e, Ct);
    const r = o.fheint160_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return kr.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    x(t, tt);
    const e = o.fheint160_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw u(e[1]);
    return u(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.fheint160_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt160}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.fheint160_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return kr.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.fheint160_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt160}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.fheint160_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return kr.__wrap(s[0]);
  }
}
const tw = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_fheint2_free(n >>> 0, 1));
class Ur {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Ur.prototype);
    return e.__wbg_ptr = t, tw.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, tw.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_fheint2_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt2}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.fheint2_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Ur.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt2}
   */
  static encrypt_with_public_key(t, e) {
    x(e, Mt);
    const r = o.fheint2_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Ur.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt2}
   */
  static encrypt_with_compressed_public_key(t, e) {
    x(e, Ct);
    const r = o.fheint2_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Ur.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {number}
   */
  decrypt(t) {
    x(t, tt);
    const e = o.fheint2_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw u(e[1]);
    return e[0];
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.fheint2_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt2}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.fheint2_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return Ur.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.fheint2_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt2}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.fheint2_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return Ur.__wrap(s[0]);
  }
}
const ew = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_fheint256_free(n >>> 0, 1));
class Fr {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Fr.prototype);
    return e.__wbg_ptr = t, ew.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, ew.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_fheint256_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt256}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.fheint256_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Fr.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt256}
   */
  static encrypt_with_public_key(t, e) {
    x(e, Mt);
    const r = o.fheint256_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Fr.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt256}
   */
  static encrypt_with_compressed_public_key(t, e) {
    x(e, Ct);
    const r = o.fheint256_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Fr.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    x(t, tt);
    const e = o.fheint256_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw u(e[1]);
    return u(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.fheint256_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt256}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.fheint256_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return Fr.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.fheint256_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt256}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.fheint256_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return Fr.__wrap(s[0]);
  }
}
const rw = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_fheint32_free(n >>> 0, 1));
class Gr {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Gr.prototype);
    return e.__wbg_ptr = t, rw.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, rw.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_fheint32_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt32}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.fheint32_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Gr.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt32}
   */
  static encrypt_with_public_key(t, e) {
    x(e, Mt);
    const r = o.fheint32_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Gr.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt32}
   */
  static encrypt_with_compressed_public_key(t, e) {
    x(e, Ct);
    const r = o.fheint32_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Gr.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {number}
   */
  decrypt(t) {
    x(t, tt);
    const e = o.fheint32_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw u(e[1]);
    return e[0];
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.fheint32_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt32}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.fheint32_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return Gr.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.fheint32_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt32}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.fheint32_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return Gr.__wrap(s[0]);
  }
}
const nw = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_fheint4_free(n >>> 0, 1));
class Lr {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Lr.prototype);
    return e.__wbg_ptr = t, nw.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, nw.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_fheint4_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt4}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.fheint4_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Lr.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt4}
   */
  static encrypt_with_public_key(t, e) {
    x(e, Mt);
    const r = o.fheint4_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Lr.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt4}
   */
  static encrypt_with_compressed_public_key(t, e) {
    x(e, Ct);
    const r = o.fheint4_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Lr.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {number}
   */
  decrypt(t) {
    x(t, tt);
    const e = o.fheint4_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw u(e[1]);
    return e[0];
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.fheint4_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt4}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.fheint4_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return Lr.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.fheint4_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt4}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.fheint4_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return Lr.__wrap(s[0]);
  }
}
const iw = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_fheint6_free(n >>> 0, 1));
class Dr {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Dr.prototype);
    return e.__wbg_ptr = t, iw.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, iw.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_fheint6_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt6}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.fheint6_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Dr.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt6}
   */
  static encrypt_with_public_key(t, e) {
    x(e, Mt);
    const r = o.fheint6_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Dr.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt6}
   */
  static encrypt_with_compressed_public_key(t, e) {
    x(e, Ct);
    const r = o.fheint6_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Dr.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {number}
   */
  decrypt(t) {
    x(t, tt);
    const e = o.fheint6_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw u(e[1]);
    return e[0];
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.fheint6_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt6}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.fheint6_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return Dr.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.fheint6_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt6}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.fheint6_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return Dr.__wrap(s[0]);
  }
}
const sw = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_fheint64_free(n >>> 0, 1));
class Kr {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Kr.prototype);
    return e.__wbg_ptr = t, sw.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, sw.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_fheint64_free(t, 0);
  }
  /**
   * @param {bigint} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt64}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.fheint64_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Kr.__wrap(r[0]);
  }
  /**
   * @param {bigint} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt64}
   */
  static encrypt_with_public_key(t, e) {
    x(e, Mt);
    const r = o.fheint64_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Kr.__wrap(r[0]);
  }
  /**
   * @param {bigint} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt64}
   */
  static encrypt_with_compressed_public_key(t, e) {
    x(e, Ct);
    const r = o.fheint64_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Kr.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {bigint}
   */
  decrypt(t) {
    x(t, tt);
    const e = o.fheint64_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw u(e[1]);
    return e[0];
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.fheint64_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt64}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.fheint64_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return Kr.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.fheint64_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt64}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.fheint64_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return Kr.__wrap(s[0]);
  }
}
const ow = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_fheint8_free(n >>> 0, 1));
class Vr {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Vr.prototype);
    return e.__wbg_ptr = t, ow.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, ow.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_fheint8_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {FheInt8}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.fheint8_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Vr.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfhePublicKey} public_key
   * @returns {FheInt8}
   */
  static encrypt_with_public_key(t, e) {
    x(e, Mt);
    const r = o.fheint8_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Vr.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheInt8}
   */
  static encrypt_with_compressed_public_key(t, e) {
    x(e, Ct);
    const r = o.fheint8_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Vr.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {number}
   */
  decrypt(t) {
    x(t, tt);
    const e = o.fheint8_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw u(e[1]);
    return e[0];
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.fheint8_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheInt8}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.fheint8_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return Vr.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.fheint8_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheInt8}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.fheint8_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return Vr.__wrap(s[0]);
  }
}
const aw = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_fheuint10_free(n >>> 0, 1));
class jr {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(jr.prototype);
    return e.__wbg_ptr = t, aw.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, aw.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_fheuint10_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint10}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.fheuint10_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return jr.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint10}
   */
  static encrypt_with_public_key(t, e) {
    x(e, Mt);
    const r = o.fheuint10_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return jr.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint10}
   */
  static encrypt_with_compressed_public_key(t, e) {
    x(e, Ct);
    const r = o.fheuint10_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return jr.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {number}
   */
  decrypt(t) {
    x(t, tt);
    const e = o.fheuint10_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw u(e[1]);
    return e[0];
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.fheuint10_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint10}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.fheuint10_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return jr.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.fheuint10_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint10}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.fheuint10_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return jr.__wrap(s[0]);
  }
}
const cw = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_fheuint1024_free(n >>> 0, 1));
class Hr {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Hr.prototype);
    return e.__wbg_ptr = t, cw.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, cw.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_fheuint1024_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint1024}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.fheuint1024_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Hr.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint1024}
   */
  static encrypt_with_public_key(t, e) {
    x(e, Mt);
    const r = o.fheuint1024_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Hr.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint1024}
   */
  static encrypt_with_compressed_public_key(t, e) {
    x(e, Ct);
    const r = o.fheuint1024_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Hr.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    x(t, tt);
    const e = o.fheuint1024_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw u(e[1]);
    return u(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.fheuint1024_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint1024}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.fheuint1024_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return Hr.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.fheuint1024_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint1024}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.fheuint1024_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return Hr.__wrap(s[0]);
  }
}
const _w = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_fheuint12_free(n >>> 0, 1));
class Yr {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Yr.prototype);
    return e.__wbg_ptr = t, _w.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, _w.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_fheuint12_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint12}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.fheuint12_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Yr.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint12}
   */
  static encrypt_with_public_key(t, e) {
    x(e, Mt);
    const r = o.fheuint12_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Yr.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint12}
   */
  static encrypt_with_compressed_public_key(t, e) {
    x(e, Ct);
    const r = o.fheuint12_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Yr.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {number}
   */
  decrypt(t) {
    x(t, tt);
    const e = o.fheuint12_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw u(e[1]);
    return e[0];
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.fheuint12_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint12}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.fheuint12_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return Yr.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.fheuint12_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint12}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.fheuint12_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return Yr.__wrap(s[0]);
  }
}
const lw = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_fheuint128_free(n >>> 0, 1));
class Qr {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Qr.prototype);
    return e.__wbg_ptr = t, lw.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, lw.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_fheuint128_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint128}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.fheuint128_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Qr.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint128}
   */
  static encrypt_with_public_key(t, e) {
    x(e, Mt);
    const r = o.fheuint128_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Qr.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint128}
   */
  static encrypt_with_compressed_public_key(t, e) {
    x(e, Ct);
    const r = o.fheuint128_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Qr.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    x(t, tt);
    const e = o.fheuint128_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw u(e[1]);
    return u(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.fheuint128_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint128}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.fheuint128_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return Qr.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.fheuint128_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint128}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.fheuint128_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return Qr.__wrap(s[0]);
  }
}
const uw = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_fheuint14_free(n >>> 0, 1));
class Wr {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Wr.prototype);
    return e.__wbg_ptr = t, uw.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, uw.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_fheuint14_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint14}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.fheuint14_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Wr.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint14}
   */
  static encrypt_with_public_key(t, e) {
    x(e, Mt);
    const r = o.fheuint14_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Wr.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint14}
   */
  static encrypt_with_compressed_public_key(t, e) {
    x(e, Ct);
    const r = o.fheuint14_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Wr.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {number}
   */
  decrypt(t) {
    x(t, tt);
    const e = o.fheuint14_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw u(e[1]);
    return e[0];
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.fheuint14_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint14}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.fheuint14_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return Wr.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.fheuint14_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint14}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.fheuint14_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return Wr.__wrap(s[0]);
  }
}
const fw = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_fheuint16_free(n >>> 0, 1));
class Jr {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Jr.prototype);
    return e.__wbg_ptr = t, fw.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, fw.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_fheuint16_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint16}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.fheuint16_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Jr.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint16}
   */
  static encrypt_with_public_key(t, e) {
    x(e, Mt);
    const r = o.fheuint16_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Jr.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint16}
   */
  static encrypt_with_compressed_public_key(t, e) {
    x(e, Ct);
    const r = o.fheuint16_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Jr.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {number}
   */
  decrypt(t) {
    x(t, tt);
    const e = o.fheuint16_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw u(e[1]);
    return e[0];
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.fheuint16_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint16}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.fheuint16_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return Jr.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.fheuint16_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint16}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.fheuint16_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return Jr.__wrap(s[0]);
  }
}
const hw = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_fheuint160_free(n >>> 0, 1));
class $r {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create($r.prototype);
    return e.__wbg_ptr = t, hw.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, hw.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_fheuint160_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint160}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.fheuint160_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return $r.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint160}
   */
  static encrypt_with_public_key(t, e) {
    x(e, Mt);
    const r = o.fheuint160_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return $r.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint160}
   */
  static encrypt_with_compressed_public_key(t, e) {
    x(e, Ct);
    const r = o.fheuint160_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return $r.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    x(t, tt);
    const e = o.fheuint160_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw u(e[1]);
    return u(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.fheuint160_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint160}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.fheuint160_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return $r.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.fheuint160_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint160}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.fheuint160_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return $r.__wrap(s[0]);
  }
}
const pw = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_fheuint2_free(n >>> 0, 1));
class qr {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(qr.prototype);
    return e.__wbg_ptr = t, pw.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, pw.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_fheuint2_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint2}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.fheuint2_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return qr.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint2}
   */
  static encrypt_with_public_key(t, e) {
    x(e, Mt);
    const r = o.fheuint2_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return qr.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint2}
   */
  static encrypt_with_compressed_public_key(t, e) {
    x(e, Ct);
    const r = o.fheuint2_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return qr.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {number}
   */
  decrypt(t) {
    x(t, tt);
    const e = o.fheuint2_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw u(e[1]);
    return e[0];
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.fheuint2_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint2}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.fheuint2_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return qr.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.fheuint2_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint2}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.fheuint2_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return qr.__wrap(s[0]);
  }
}
const dw = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_fheuint2048_free(n >>> 0, 1));
class Zr {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Zr.prototype);
    return e.__wbg_ptr = t, dw.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, dw.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_fheuint2048_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint2048}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.fheuint2048_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Zr.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint2048}
   */
  static encrypt_with_public_key(t, e) {
    x(e, Mt);
    const r = o.fheuint2048_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Zr.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint2048}
   */
  static encrypt_with_compressed_public_key(t, e) {
    x(e, Ct);
    const r = o.fheuint2048_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Zr.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    x(t, tt);
    const e = o.fheuint2048_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw u(e[1]);
    return u(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.fheuint2048_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint2048}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.fheuint2048_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return Zr.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.fheuint2048_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint2048}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.fheuint2048_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return Zr.__wrap(s[0]);
  }
}
const ww = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_fheuint256_free(n >>> 0, 1));
class Xr {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Xr.prototype);
    return e.__wbg_ptr = t, ww.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, ww.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_fheuint256_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint256}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.fheuint256_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Xr.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint256}
   */
  static encrypt_with_public_key(t, e) {
    x(e, Mt);
    const r = o.fheuint256_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Xr.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint256}
   */
  static encrypt_with_compressed_public_key(t, e) {
    x(e, Ct);
    const r = o.fheuint256_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return Xr.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    x(t, tt);
    const e = o.fheuint256_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw u(e[1]);
    return u(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.fheuint256_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint256}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.fheuint256_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return Xr.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.fheuint256_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint256}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.fheuint256_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return Xr.__wrap(s[0]);
  }
}
const gw = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_fheuint32_free(n >>> 0, 1));
class tn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(tn.prototype);
    return e.__wbg_ptr = t, gw.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, gw.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_fheuint32_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint32}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.fheuint32_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return tn.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint32}
   */
  static encrypt_with_public_key(t, e) {
    x(e, Mt);
    const r = o.fheuint32_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return tn.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint32}
   */
  static encrypt_with_compressed_public_key(t, e) {
    x(e, Ct);
    const r = o.fheuint32_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return tn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {number}
   */
  decrypt(t) {
    x(t, tt);
    const e = o.fheuint32_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw u(e[1]);
    return e[0] >>> 0;
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.fheuint32_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint32}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.fheuint32_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return tn.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.fheuint32_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint32}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.fheuint32_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return tn.__wrap(s[0]);
  }
}
const yw = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_fheuint4_free(n >>> 0, 1));
class en {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(en.prototype);
    return e.__wbg_ptr = t, yw.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, yw.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_fheuint4_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint4}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.fheuint4_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return en.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint4}
   */
  static encrypt_with_public_key(t, e) {
    x(e, Mt);
    const r = o.fheuint4_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return en.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint4}
   */
  static encrypt_with_compressed_public_key(t, e) {
    x(e, Ct);
    const r = o.fheuint4_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return en.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {number}
   */
  decrypt(t) {
    x(t, tt);
    const e = o.fheuint4_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw u(e[1]);
    return e[0];
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.fheuint4_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint4}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.fheuint4_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return en.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.fheuint4_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint4}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.fheuint4_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return en.__wrap(s[0]);
  }
}
const bw = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_fheuint512_free(n >>> 0, 1));
class rn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(rn.prototype);
    return e.__wbg_ptr = t, bw.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, bw.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_fheuint512_free(t, 0);
  }
  /**
   * @param {any} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint512}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.fheuint512_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return rn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint512}
   */
  static encrypt_with_public_key(t, e) {
    x(e, Mt);
    const r = o.fheuint512_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return rn.__wrap(r[0]);
  }
  /**
   * @param {any} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint512}
   */
  static encrypt_with_compressed_public_key(t, e) {
    x(e, Ct);
    const r = o.fheuint512_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return rn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {any}
   */
  decrypt(t) {
    x(t, tt);
    const e = o.fheuint512_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw u(e[1]);
    return u(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.fheuint512_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint512}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.fheuint512_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return rn.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.fheuint512_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint512}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.fheuint512_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return rn.__wrap(s[0]);
  }
}
const Aw = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_fheuint6_free(n >>> 0, 1));
class nn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(nn.prototype);
    return e.__wbg_ptr = t, Aw.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Aw.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_fheuint6_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint6}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.fheuint6_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return nn.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint6}
   */
  static encrypt_with_public_key(t, e) {
    x(e, Mt);
    const r = o.fheuint6_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return nn.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint6}
   */
  static encrypt_with_compressed_public_key(t, e) {
    x(e, Ct);
    const r = o.fheuint6_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return nn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {number}
   */
  decrypt(t) {
    x(t, tt);
    const e = o.fheuint6_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw u(e[1]);
    return e[0];
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.fheuint6_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint6}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.fheuint6_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return nn.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.fheuint6_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint6}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.fheuint6_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return nn.__wrap(s[0]);
  }
}
const mw = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_fheuint64_free(n >>> 0, 1));
class sn {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(sn.prototype);
    return e.__wbg_ptr = t, mw.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, mw.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_fheuint64_free(t, 0);
  }
  /**
   * @param {bigint} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint64}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.fheuint64_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return sn.__wrap(r[0]);
  }
  /**
   * @param {bigint} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint64}
   */
  static encrypt_with_public_key(t, e) {
    x(e, Mt);
    const r = o.fheuint64_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return sn.__wrap(r[0]);
  }
  /**
   * @param {bigint} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint64}
   */
  static encrypt_with_compressed_public_key(t, e) {
    x(e, Ct);
    const r = o.fheuint64_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return sn.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {bigint}
   */
  decrypt(t) {
    x(t, tt);
    const e = o.fheuint64_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw u(e[1]);
    return BigInt.asUintN(64, e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.fheuint64_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint64}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.fheuint64_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return sn.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.fheuint64_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint64}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.fheuint64_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return sn.__wrap(s[0]);
  }
}
const Sw = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_fheuint8_free(n >>> 0, 1));
class on {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(on.prototype);
    return e.__wbg_ptr = t, Sw.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Sw.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_fheuint8_free(t, 0);
  }
  /**
   * @param {number} value
   * @param {TfheClientKey} client_key
   * @returns {FheUint8}
   */
  static encrypt_with_client_key(t, e) {
    x(e, tt);
    const r = o.fheuint8_encrypt_with_client_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return on.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfhePublicKey} public_key
   * @returns {FheUint8}
   */
  static encrypt_with_public_key(t, e) {
    x(e, Mt);
    const r = o.fheuint8_encrypt_with_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return on.__wrap(r[0]);
  }
  /**
   * @param {number} value
   * @param {TfheCompressedPublicKey} compressed_public_key
   * @returns {FheUint8}
   */
  static encrypt_with_compressed_public_key(t, e) {
    x(e, Ct);
    const r = o.fheuint8_encrypt_with_compressed_public_key(t, e.__wbg_ptr);
    if (r[2])
      throw u(r[1]);
    return on.__wrap(r[0]);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {number}
   */
  decrypt(t) {
    x(t, tt);
    const e = o.fheuint8_decrypt(this.__wbg_ptr, t.__wbg_ptr);
    if (e[2])
      throw u(e[1]);
    return e[0];
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.fheuint8_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {FheUint8}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.fheuint8_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return on.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.fheuint8_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {FheUint8}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.fheuint8_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return on.__wrap(s[0]);
  }
}
const Ew = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_provencompactciphertextlist_free(n >>> 0, 1));
class Co {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Co.prototype);
    return e.__wbg_ptr = t, Ew.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Ew.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_provencompactciphertextlist_free(t, 0);
  }
  /**
   * @param {TfheCompactPublicKey} public_key
   * @returns {CompactCiphertextListBuilder}
   */
  static builder(t) {
    x(t, Fe);
    const e = o.provencompactciphertextlist_builder(t.__wbg_ptr);
    if (e[2])
      throw u(e[1]);
    return Uc.__wrap(e[0]);
  }
  /**
   * @returns {number}
   */
  len() {
    return o.compactciphertextlistexpander_len(this.__wbg_ptr) >>> 0;
  }
  /**
   * @returns {boolean}
   */
  is_empty() {
    return o.compactciphertextlistexpander_is_empty(this.__wbg_ptr) !== 0;
  }
  /**
   * @param {number} index
   * @returns {FheTypes | undefined}
   */
  get_kind_of(t) {
    const e = o.provencompactciphertextlist_get_kind_of(this.__wbg_ptr, t);
    return e === 31 ? void 0 : e;
  }
  /**
   * @param {CompactPkeCrs} crs
   * @param {TfheCompactPublicKey} public_key
   * @param {Uint8Array} metadata
   * @returns {CompactCiphertextListExpander}
   */
  verify_and_expand(t, e, r) {
    x(t, qe), x(e, Fe);
    const i = F(r, o.__wbindgen_malloc), s = z, a = o.provencompactciphertextlist_verify_and_expand(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, i, s);
    if (a[2])
      throw u(a[1]);
    return Ca.__wrap(a[0]);
  }
  /**
   * @returns {CompactCiphertextListExpander}
   */
  expand_without_verification() {
    const t = o.provencompactciphertextlist_expand_without_verification(this.__wbg_ptr);
    if (t[2])
      throw u(t[1]);
    return Ca.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.provencompactciphertextlist_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {ProvenCompactCiphertextList}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.provencompactciphertextlist_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return Co.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.provencompactciphertextlist_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {ProvenCompactCiphertextList}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.provencompactciphertextlist_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return Co.__wrap(s[0]);
  }
}
const CP = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_shortint_free(n >>> 0, 1));
class IP {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, CP.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_shortint_free(t, 0);
  }
  /**
   * @param {number} std_dev
   * @returns {ShortintNoiseDistribution}
   */
  static new_gaussian_from_std_dev(t) {
    const e = o.shortint_new_gaussian_from_std_dev(t);
    return Ze.__wrap(e);
  }
  /**
   * @param {number} bound_log2
   * @returns {ShortintNoiseDistribution}
   */
  static try_new_t_uniform(t) {
    const e = o.shortint_try_new_t_uniform(t);
    if (e[2])
      throw u(e[1]);
    return Ze.__wrap(e[0]);
  }
  /**
   * @param {number} lwe_dimension
   * @param {number} glwe_dimension
   * @param {number} polynomial_size
   * @param {ShortintNoiseDistribution} lwe_noise_distribution
   * @param {ShortintNoiseDistribution} glwe_noise_distribution
   * @param {number} pbs_base_log
   * @param {number} pbs_level
   * @param {number} ks_base_log
   * @param {number} ks_level
   * @param {bigint} message_modulus
   * @param {bigint} carry_modulus
   * @param {bigint} max_noise_level
   * @param {number} log2_p_fail
   * @param {number} modulus_power_of_2_exponent
   * @param {ShortintEncryptionKeyChoice} encryption_key_choice
   * @returns {ShortintParameters}
   */
  static new_parameters(t, e, r, i, s, a, c, _, p, f, d, y, b, v, R) {
    x(i, Ze), x(s, Ze);
    const M = o.shortint_new_parameters(t, e, r, i.__wbg_ptr, s.__wbg_ptr, a, c, _, p, f, d, y, b, v, R);
    return pi.__wrap(M);
  }
  /**
   * @param {bigint} seed_high_bytes
   * @param {bigint} seed_low_bytes
   * @param {ShortintParameters} parameters
   * @returns {ShortintClientKey}
   */
  static new_client_key_from_seed_and_parameters(t, e, r) {
    x(r, pi);
    const i = o.shortint_new_client_key_from_seed_and_parameters(t, e, r.__wbg_ptr);
    return Oe.__wrap(i);
  }
  /**
   * @param {ShortintParameters} parameters
   * @returns {ShortintClientKey}
   */
  static new_client_key(t) {
    x(t, pi);
    const e = o.shortint_new_client_key(t.__wbg_ptr);
    return Oe.__wrap(e);
  }
  /**
   * @param {ShortintClientKey} client_key
   * @returns {ShortintPublicKey}
   */
  static new_public_key(t) {
    x(t, Oe);
    const e = o.shortint_new_public_key(t.__wbg_ptr);
    return Li.__wrap(e);
  }
  /**
   * @param {ShortintClientKey} client_key
   * @returns {ShortintCompressedPublicKey}
   */
  static new_compressed_public_key(t) {
    x(t, Oe);
    const e = o.shortint_new_compressed_public_key(t.__wbg_ptr);
    return Gi.__wrap(e);
  }
  /**
   * @param {ShortintClientKey} client_key
   * @returns {ShortintCompressedServerKey}
   */
  static new_compressed_server_key(t) {
    x(t, Oe);
    const e = o.shortint_new_compressed_server_key(t.__wbg_ptr);
    return Io.__wrap(e);
  }
  /**
   * @param {ShortintClientKey} client_key
   * @param {bigint} message
   * @returns {ShortintCiphertext}
   */
  static encrypt(t, e) {
    x(t, Oe);
    const r = o.shortint_encrypt(t.__wbg_ptr, e);
    return mr.__wrap(r);
  }
  /**
   * @param {ShortintClientKey} client_key
   * @param {bigint} message
   * @returns {ShortintCompressedCiphertext}
   */
  static encrypt_compressed(t, e) {
    x(t, Oe);
    const r = o.shortint_encrypt_compressed(t.__wbg_ptr, e);
    return Fi.__wrap(r);
  }
  /**
   * @param {ShortintCompressedCiphertext} compressed_ciphertext
   * @returns {ShortintCiphertext}
   */
  static decompress_ciphertext(t) {
    x(t, Fi);
    const e = o.shortint_decompress_ciphertext(t.__wbg_ptr);
    return mr.__wrap(e);
  }
  /**
   * @param {ShortintPublicKey} public_key
   * @param {bigint} message
   * @returns {ShortintCiphertext}
   */
  static encrypt_with_public_key(t, e) {
    x(t, Li);
    const r = o.shortint_encrypt_with_public_key(t.__wbg_ptr, e);
    return mr.__wrap(r);
  }
  /**
   * @param {ShortintCompressedPublicKey} public_key
   * @param {bigint} message
   * @returns {ShortintCiphertext}
   */
  static encrypt_with_compressed_public_key(t, e) {
    x(t, Gi);
    const r = o.shortint_encrypt_with_compressed_public_key(t.__wbg_ptr, e);
    return mr.__wrap(r);
  }
  /**
   * @param {ShortintClientKey} client_key
   * @param {ShortintCiphertext} ct
   * @returns {bigint}
   */
  static decrypt(t, e) {
    x(t, Oe), x(e, mr);
    const r = o.shortint_decrypt(t.__wbg_ptr, e.__wbg_ptr);
    return BigInt.asUintN(64, r);
  }
  /**
   * @param {ShortintCiphertext} ciphertext
   * @returns {Uint8Array}
   */
  static serialize_ciphertext(t) {
    x(t, mr);
    const e = o.shortint_serialize_ciphertext(t.__wbg_ptr);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {ShortintCiphertext}
   */
  static deserialize_ciphertext(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.shortint_deserialize_ciphertext(e, r);
    if (i[2])
      throw u(i[1]);
    return mr.__wrap(i[0]);
  }
  /**
   * @param {ShortintCompressedCiphertext} ciphertext
   * @returns {Uint8Array}
   */
  static serialize_compressed_ciphertext(t) {
    x(t, Fi);
    const e = o.shortint_serialize_compressed_ciphertext(t.__wbg_ptr);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {ShortintCompressedCiphertext}
   */
  static deserialize_compressed_ciphertext(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.shortint_deserialize_compressed_ciphertext(e, r);
    if (i[2])
      throw u(i[1]);
    return Fi.__wrap(i[0]);
  }
  /**
   * @param {ShortintClientKey} client_key
   * @returns {Uint8Array}
   */
  static serialize_client_key(t) {
    x(t, Oe);
    const e = o.shortint_serialize_client_key(t.__wbg_ptr);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {ShortintClientKey}
   */
  static deserialize_client_key(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.shortint_deserialize_client_key(e, r);
    if (i[2])
      throw u(i[1]);
    return Oe.__wrap(i[0]);
  }
  /**
   * @param {ShortintPublicKey} public_key
   * @returns {Uint8Array}
   */
  static serialize_public_key(t) {
    x(t, Li);
    const e = o.shortint_serialize_public_key(t.__wbg_ptr);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {ShortintPublicKey}
   */
  static deserialize_public_key(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.shortint_deserialize_public_key(e, r);
    if (i[2])
      throw u(i[1]);
    return Li.__wrap(i[0]);
  }
  /**
   * @param {ShortintCompressedPublicKey} public_key
   * @returns {Uint8Array}
   */
  static serialize_compressed_public_key(t) {
    x(t, Gi);
    const e = o.shortint_serialize_compressed_public_key(t.__wbg_ptr);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {ShortintCompressedPublicKey}
   */
  static deserialize_compressed_public_key(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.shortint_deserialize_compressed_public_key(e, r);
    if (i[2])
      throw u(i[1]);
    return Gi.__wrap(i[0]);
  }
  /**
   * @param {ShortintCompressedServerKey} server_key
   * @returns {Uint8Array}
   */
  static serialize_compressed_server_key(t) {
    x(t, Io);
    const e = o.shortint_serialize_compressed_server_key(t.__wbg_ptr);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {ShortintCompressedServerKey}
   */
  static deserialize_compressed_server_key(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.shortint_deserialize_compressed_server_key(e, r);
    if (i[2])
      throw u(i[1]);
    return Io.__wrap(i[0]);
  }
}
const Rw = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_shortintciphertext_free(n >>> 0, 1));
class mr {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(mr.prototype);
    return e.__wbg_ptr = t, Rw.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Rw.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_shortintciphertext_free(t, 0);
  }
}
const Pw = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_shortintclientkey_free(n >>> 0, 1));
class Oe {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Oe.prototype);
    return e.__wbg_ptr = t, Pw.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Pw.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_shortintclientkey_free(t, 0);
  }
}
const Ou = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_shortintcompactpublickeyencryptionparameters_free(n >>> 0, 1));
class ys {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(ys.prototype);
    return e.__wbg_ptr = t, Ou.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Ou.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_shortintcompactpublickeyencryptionparameters_free(t, 0);
  }
  /**
   * @param {ShortintCompactPublicKeyEncryptionParametersName} name
   */
  constructor(t) {
    const e = o.shortintcompactpublickeyencryptionparameters_new(t);
    return this.__wbg_ptr = e >>> 0, Ou.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * @param {number} encryption_lwe_dimension
   * @param {ShortintNoiseDistribution} encryption_noise_distribution
   * @param {bigint} message_modulus
   * @param {bigint} carry_modulus
   * @param {number} modulus_power_of_2_exponent
   * @param {number} ks_base_log
   * @param {number} ks_level
   * @param {ShortintEncryptionKeyChoice} encryption_key_choice
   * @returns {ShortintCompactPublicKeyEncryptionParameters}
   */
  static new_parameters(t, e, r, i, s, a, c, _) {
    x(e, Ze);
    const p = o.shortintcompactpublickeyencryptionparameters_new_parameters(t, e.__wbg_ptr, r, i, s, a, c, _);
    if (p[2])
      throw u(p[1]);
    return ys.__wrap(p[0]);
  }
}
const vw = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_shortintcompressedciphertext_free(n >>> 0, 1));
class Fi {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Fi.prototype);
    return e.__wbg_ptr = t, vw.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, vw.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_shortintcompressedciphertext_free(t, 0);
  }
}
const Mw = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_shortintcompressedpublickey_free(n >>> 0, 1));
class Gi {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Gi.prototype);
    return e.__wbg_ptr = t, Mw.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Mw.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_shortintcompressedpublickey_free(t, 0);
  }
}
const xw = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_shortintcompressedserverkey_free(n >>> 0, 1));
class Io {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Io.prototype);
    return e.__wbg_ptr = t, xw.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, xw.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_shortintcompressedserverkey_free(t, 0);
  }
}
const Bw = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_shortintnoisedistribution_free(n >>> 0, 1));
class Ze {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Ze.prototype);
    return e.__wbg_ptr = t, Bw.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Bw.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_shortintnoisedistribution_free(t, 0);
  }
}
const Tu = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_shortintparameters_free(n >>> 0, 1));
class pi {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(pi.prototype);
    return e.__wbg_ptr = t, Tu.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Tu.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_shortintparameters_free(t, 0);
  }
  /**
   * @returns {number}
   */
  lwe_dimension() {
    return o.shortintparameters_lwe_dimension(this.__wbg_ptr) >>> 0;
  }
  /**
   * @param {number} new_value
   */
  set_lwe_dimension(t) {
    o.shortintparameters_set_lwe_dimension(this.__wbg_ptr, t);
  }
  /**
   * @returns {number}
   */
  glwe_dimension() {
    return o.shortintparameters_glwe_dimension(this.__wbg_ptr) >>> 0;
  }
  /**
   * @param {number} new_value
   */
  set_glwe_dimension(t) {
    o.shortintparameters_set_glwe_dimension(this.__wbg_ptr, t);
  }
  /**
   * @returns {number}
   */
  polynomial_size() {
    return o.shortintparameters_polynomial_size(this.__wbg_ptr) >>> 0;
  }
  /**
   * @param {number} new_value
   */
  set_polynomial_size(t) {
    o.shortintparameters_set_polynomial_size(this.__wbg_ptr, t);
  }
  /**
   * @returns {ShortintNoiseDistribution}
   */
  lwe_noise_distribution() {
    const t = o.shortintparameters_glwe_noise_distribution(this.__wbg_ptr);
    return Ze.__wrap(t);
  }
  /**
   * @param {ShortintNoiseDistribution} new_value
   */
  set_lwe_noise_distribution(t) {
    x(t, Ze), o.shortintparameters_set_lwe_noise_distribution(this.__wbg_ptr, t.__wbg_ptr);
  }
  /**
   * @returns {ShortintNoiseDistribution}
   */
  glwe_noise_distribution() {
    const t = o.shortintparameters_glwe_noise_distribution(this.__wbg_ptr);
    return Ze.__wrap(t);
  }
  /**
   * @param {ShortintNoiseDistribution} new_value
   */
  set_glwe_noise_distribution(t) {
    x(t, Ze), o.shortintparameters_set_glwe_noise_distribution(this.__wbg_ptr, t.__wbg_ptr);
  }
  /**
   * @returns {number}
   */
  pbs_base_log() {
    return o.shortintparameters_pbs_base_log(this.__wbg_ptr) >>> 0;
  }
  /**
   * @param {number} new_value
   */
  set_pbs_base_log(t) {
    o.shortintparameters_set_pbs_base_log(this.__wbg_ptr, t);
  }
  /**
   * @returns {number}
   */
  pbs_level() {
    return o.shortintparameters_pbs_level(this.__wbg_ptr) >>> 0;
  }
  /**
   * @param {number} new_value
   */
  set_pbs_level(t) {
    o.shortintparameters_set_pbs_level(this.__wbg_ptr, t);
  }
  /**
   * @returns {number}
   */
  ks_base_log() {
    return o.shortintparameters_ks_base_log(this.__wbg_ptr) >>> 0;
  }
  /**
   * @param {number} new_value
   */
  set_ks_base_log(t) {
    o.shortintparameters_set_ks_base_log(this.__wbg_ptr, t);
  }
  /**
   * @returns {number}
   */
  ks_level() {
    return o.shortintparameters_ks_level(this.__wbg_ptr) >>> 0;
  }
  /**
   * @param {number} new_value
   */
  set_ks_level(t) {
    o.shortintparameters_set_ks_level(this.__wbg_ptr, t);
  }
  /**
   * @returns {bigint}
   */
  message_modulus() {
    const t = o.shortintparameters_message_modulus(this.__wbg_ptr);
    return BigInt.asUintN(64, t);
  }
  /**
   * @param {bigint} new_value
   */
  set_message_modulus(t) {
    o.shortintparameters_set_message_modulus(this.__wbg_ptr, t);
  }
  /**
   * @returns {bigint}
   */
  carry_modulus() {
    const t = o.shortintparameters_carry_modulus(this.__wbg_ptr);
    return BigInt.asUintN(64, t);
  }
  /**
   * @param {bigint} new_value
   */
  set_carry_modulus(t) {
    o.shortintparameters_set_carry_modulus(this.__wbg_ptr, t);
  }
  /**
   * @returns {ShortintEncryptionKeyChoice}
   */
  encryption_key_choice() {
    return o.shortintparameters_encryption_key_choice(this.__wbg_ptr);
  }
  /**
   * @param {ShortintEncryptionKeyChoice} new_value
   */
  set_encryption_key_choice(t) {
    o.shortintparameters_set_encryption_key_choice(this.__wbg_ptr, t);
  }
  /**
   * @param {ShortintParametersName} name
   */
  constructor(t) {
    const e = o.shortintparameters_new(t);
    return this.__wbg_ptr = e >>> 0, Tu.register(this, this.__wbg_ptr, this), this;
  }
}
const Cw = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_shortintpublickey_free(n >>> 0, 1));
class Li {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Li.prototype);
    return e.__wbg_ptr = t, Cw.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Cw.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_shortintpublickey_free(t, 0);
  }
}
const Iw = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_tfheclientkey_free(n >>> 0, 1));
class tt {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(tt.prototype);
    return e.__wbg_ptr = t, Iw.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Iw.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_tfheclientkey_free(t, 0);
  }
  /**
   * @param {TfheConfig} config
   * @returns {TfheClientKey}
   */
  static generate(t) {
    x(t, bs);
    const e = o.tfheclientkey_generate(t.__wbg_ptr);
    if (e[2])
      throw u(e[1]);
    return tt.__wrap(e[0]);
  }
  /**
   * @param {TfheConfig} config
   * @param {any} seed
   * @returns {TfheClientKey}
   */
  static generate_with_seed(t, e) {
    x(t, bs);
    const r = o.tfheclientkey_generate_with_seed(t.__wbg_ptr, e);
    if (r[2])
      throw u(r[1]);
    return tt.__wrap(r[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.tfheclientkey_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {TfheClientKey}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.tfheclientkey_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return tt.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.tfheclientkey_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {TfheClientKey}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.tfheclientkey_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return tt.__wrap(s[0]);
  }
}
const Nw = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_tfhecompactpublickey_free(n >>> 0, 1));
class Fe {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Fe.prototype);
    return e.__wbg_ptr = t, Nw.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Nw.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_tfhecompactpublickey_free(t, 0);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {TfheCompactPublicKey}
   */
  static new(t) {
    x(t, tt);
    const e = o.tfhecompactpublickey_new(t.__wbg_ptr);
    if (e[2])
      throw u(e[1]);
    return Fe.__wrap(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.tfhecompactpublickey_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {TfheCompactPublicKey}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.tfhecompactpublickey_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return Fe.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.tfhecompactpublickey_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {TfheCompactPublicKey}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.tfhecompactpublickey_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return Fe.__wrap(s[0]);
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @param {ShortintCompactPublicKeyEncryptionParameters} conformance_params
   * @returns {TfheCompactPublicKey}
   */
  static safe_deserialize_conformant(t, e, r) {
    const i = F(t, o.__wbindgen_malloc), s = z;
    x(r, ys);
    const a = o.tfhecompactpublickey_safe_deserialize_conformant(i, s, e, r.__wbg_ptr);
    if (a[2])
      throw u(a[1]);
    return Fe.__wrap(a[0]);
  }
}
const Ow = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_tfhecompressedcompactpublickey_free(n >>> 0, 1));
class vi {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(vi.prototype);
    return e.__wbg_ptr = t, Ow.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Ow.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_tfhecompressedcompactpublickey_free(t, 0);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {TfheCompressedCompactPublicKey}
   */
  static new(t) {
    x(t, tt);
    const e = o.tfhecompressedcompactpublickey_new(t.__wbg_ptr);
    if (e[2])
      throw u(e[1]);
    return vi.__wrap(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.tfhecompressedcompactpublickey_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {TfheCompressedCompactPublicKey}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.tfhecompressedcompactpublickey_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return vi.__wrap(i[0]);
  }
  /**
   * @returns {TfheCompactPublicKey}
   */
  decompress() {
    const t = o.tfhecompressedcompactpublickey_decompress(this.__wbg_ptr);
    if (t[2])
      throw u(t[1]);
    return Fe.__wrap(t[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.tfhecompressedcompactpublickey_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {TfheCompressedCompactPublicKey}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.tfhecompressedcompactpublickey_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return vi.__wrap(s[0]);
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @param {ShortintCompactPublicKeyEncryptionParameters} conformance_params
   * @returns {TfheCompressedCompactPublicKey}
   */
  static safe_deserialize_conformant(t, e, r) {
    const i = F(t, o.__wbindgen_malloc), s = z;
    x(r, ys);
    const a = o.tfhecompressedcompactpublickey_safe_deserialize_conformant(i, s, e, r.__wbg_ptr);
    if (a[2])
      throw u(a[1]);
    return vi.__wrap(a[0]);
  }
}
const Tw = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_tfhecompressedpublickey_free(n >>> 0, 1));
class Ct {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Ct.prototype);
    return e.__wbg_ptr = t, Tw.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Tw.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_tfhecompressedpublickey_free(t, 0);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {TfheCompressedPublicKey}
   */
  static new(t) {
    x(t, tt);
    const e = o.tfhecompressedpublickey_new(t.__wbg_ptr);
    if (e[2])
      throw u(e[1]);
    return Ct.__wrap(e[0]);
  }
  /**
   * @returns {TfhePublicKey}
   */
  decompress() {
    const t = o.tfhecompressedpublickey_decompress(this.__wbg_ptr);
    if (t[2])
      throw u(t[1]);
    return Mt.__wrap(t[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.tfhecompressedpublickey_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {TfheCompressedPublicKey}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.tfhecompressedpublickey_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return Ct.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.tfhecompressedpublickey_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {TfheCompressedPublicKey}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.tfhecompressedpublickey_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return Ct.__wrap(s[0]);
  }
}
const zw = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_tfhecompressedserverkey_free(n >>> 0, 1));
class wo {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(wo.prototype);
    return e.__wbg_ptr = t, zw.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, zw.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_tfhecompressedserverkey_free(t, 0);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {TfheCompressedServerKey}
   */
  static new(t) {
    x(t, tt);
    const e = o.tfhecompressedserverkey_new(t.__wbg_ptr);
    if (e[2])
      throw u(e[1]);
    return wo.__wrap(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.tfhecompressedserverkey_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {TfheCompressedServerKey}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.tfhecompressedserverkey_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return wo.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.tfhecompressedserverkey_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {TfheCompressedServerKey}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.tfhecompressedserverkey_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return wo.__wrap(s[0]);
  }
}
const kw = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_tfheconfig_free(n >>> 0, 1));
class bs {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(bs.prototype);
    return e.__wbg_ptr = t, kw.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, kw.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_tfheconfig_free(t, 0);
  }
}
const Uw = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_tfheconfigbuilder_free(n >>> 0, 1));
class Mi {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Mi.prototype);
    return e.__wbg_ptr = t, Uw.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Uw.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_tfheconfigbuilder_free(t, 0);
  }
  /**
   * @returns {TfheConfigBuilder}
   */
  static default() {
    const t = o.tfheconfigbuilder_default();
    return Mi.__wrap(t);
  }
  /**
   * @param {ShortintParameters} block_parameters
   * @returns {TfheConfigBuilder}
   */
  static with_custom_parameters(t) {
    x(t, pi);
    const e = o.tfheconfigbuilder_with_custom_parameters(t.__wbg_ptr);
    return Mi.__wrap(e);
  }
  /**
   * @param {ShortintParameters} block_parameters
   * @returns {TfheConfigBuilder}
   */
  use_custom_parameters(t) {
    const e = this.__destroy_into_raw();
    x(t, pi);
    const r = o.tfheconfigbuilder_use_custom_parameters(e, t.__wbg_ptr);
    return Mi.__wrap(r);
  }
  /**
   * @param {ShortintCompactPublicKeyEncryptionParameters} compact_public_key_parameters
   * @returns {TfheConfigBuilder}
   */
  use_dedicated_compact_public_key_parameters(t) {
    const e = this.__destroy_into_raw();
    x(t, ys);
    const r = o.tfheconfigbuilder_use_dedicated_compact_public_key_parameters(e, t.__wbg_ptr);
    return Mi.__wrap(r);
  }
  /**
   * @returns {TfheConfig}
   */
  build() {
    const t = this.__destroy_into_raw(), e = o.tfheconfigbuilder_build(t);
    return bs.__wrap(e);
  }
}
const Fw = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_tfhepublickey_free(n >>> 0, 1));
class Mt {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Mt.prototype);
    return e.__wbg_ptr = t, Fw.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Fw.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_tfhepublickey_free(t, 0);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {TfhePublicKey}
   */
  static new(t) {
    x(t, tt);
    const e = o.tfhepublickey_new(t.__wbg_ptr);
    if (e[2])
      throw u(e[1]);
    return Mt.__wrap(e[0]);
  }
  /**
   * @returns {Uint8Array}
   */
  serialize() {
    const t = o.tfhepublickey_serialize(this.__wbg_ptr);
    if (t[3])
      throw u(t[2]);
    var e = L(t[0], t[1]).slice();
    return o.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} buffer
   * @returns {TfhePublicKey}
   */
  static deserialize(t) {
    const e = F(t, o.__wbindgen_malloc), r = z, i = o.tfhepublickey_deserialize(e, r);
    if (i[2])
      throw u(i[1]);
    return Mt.__wrap(i[0]);
  }
  /**
   * @param {bigint} serialized_size_limit
   * @returns {Uint8Array}
   */
  safe_serialize(t) {
    const e = o.tfhepublickey_safe_serialize(this.__wbg_ptr, t);
    if (e[3])
      throw u(e[2]);
    var r = L(e[0], e[1]).slice();
    return o.__wbindgen_free(e[0], e[1] * 1, 1), r;
  }
  /**
   * @param {Uint8Array} buffer
   * @param {bigint} serialized_size_limit
   * @returns {TfhePublicKey}
   */
  static safe_deserialize(t, e) {
    const r = F(t, o.__wbindgen_malloc), i = z, s = o.tfhepublickey_safe_deserialize(r, i, e);
    if (s[2])
      throw u(s[1]);
    return Mt.__wrap(s[0]);
  }
}
const Gw = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_tfheserverkey_free(n >>> 0, 1));
class fc {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(fc.prototype);
    return e.__wbg_ptr = t, Gw.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Gw.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_tfheserverkey_free(t, 0);
  }
  /**
   * @param {TfheClientKey} client_key
   * @returns {TfheServerKey}
   */
  static new(t) {
    x(t, tt);
    const e = o.tfheserverkey_new(t.__wbg_ptr);
    if (e[2])
      throw u(e[1]);
    return fc.__wrap(e[0]);
  }
}
const NP = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_tfhe_free(n >>> 0, 1));
class OP {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, NP.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_tfhe_free(t, 0);
  }
}
const Lw = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => o.__wbg_wbg_rayon_poolbuilder_free(n >>> 0, 1));
class ll {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(ll.prototype);
    return e.__wbg_ptr = t, Lw.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Lw.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    o.__wbg_wbg_rayon_poolbuilder_free(t, 0);
  }
  /**
   * @returns {number}
   */
  numThreads() {
    return o.wbg_rayon_poolbuilder_numThreads(this.__wbg_ptr) >>> 0;
  }
  /**
   * @returns {number}
   */
  receiver() {
    return o.wbg_rayon_poolbuilder_receiver(this.__wbg_ptr) >>> 0;
  }
  build() {
    o.wbg_rayon_poolbuilder_build(this.__wbg_ptr);
  }
}
async function TP(n, t) {
  if (typeof Response == "function" && n instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming == "function")
      try {
        return await WebAssembly.instantiateStreaming(n, t);
      } catch (r) {
        if (n.headers.get("Content-Type") != "application/wasm")
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", r);
        else
          throw r;
      }
    const e = await n.arrayBuffer();
    return await WebAssembly.instantiate(e, t);
  } else {
    const e = await WebAssembly.instantiate(n, t);
    return e instanceof WebAssembly.Instance ? { instance: e, module: n } : e;
  }
}
function Yy() {
  const n = {};
  return n.wbg = {}, n.wbg.__wbg_BigInt_470dd987b8190f8e = function(t) {
    return BigInt(t);
  }, n.wbg.__wbg_BigInt_ddea6d2f55558acb = function() {
    return Cs(function(t) {
      return BigInt(t);
    }, arguments);
  }, n.wbg.__wbg_buffer_609cc3eee51ed158 = function(t) {
    return t.buffer;
  }, n.wbg.__wbg_call_672a4d21634d4a24 = function() {
    return Cs(function(t, e) {
      return t.call(e);
    }, arguments);
  }, n.wbg.__wbg_call_7cccdd69e0791ae2 = function() {
    return Cs(function(t, e, r) {
      return t.call(e, r);
    }, arguments);
  }, n.wbg.__wbg_crypto_ed58b8e10a292839 = function(t) {
    return t.crypto;
  }, n.wbg.__wbg_error_7534b8e9a36f1ab4 = function(t, e) {
    let r, i;
    try {
      r = t, i = e, console.error(Wn(t, e));
    } finally {
      o.__wbindgen_free(r, i, 1);
    }
  }, n.wbg.__wbg_getRandomValues_bcb4912f16000dc4 = function() {
    return Cs(function(t, e) {
      t.getRandomValues(e);
    }, arguments);
  }, n.wbg.__wbg_getTime_46267b1c24877e30 = function(t) {
    return t.getTime();
  }, n.wbg.__wbg_instanceof_Window_def73ea0955fc569 = function(t) {
    let e;
    try {
      e = t instanceof Window;
    } catch {
      e = !1;
    }
    return e;
  }, n.wbg.__wbg_msCrypto_0a36e2ec3a343d26 = function(t) {
    return t.msCrypto;
  }, n.wbg.__wbg_new0_f788a2397c7ca929 = function() {
    return /* @__PURE__ */ new Date();
  }, n.wbg.__wbg_new_8a6f238a6ece86ea = function() {
    return new Error();
  }, n.wbg.__wbg_new_a12002a7f91c75be = function(t) {
    return new Uint8Array(t);
  }, n.wbg.__wbg_newnoargs_105ed471475aaf50 = function(t, e) {
    return new Function(Wn(t, e));
  }, n.wbg.__wbg_newwithbyteoffsetandlength_d97e637ebe145a9a = function(t, e, r) {
    return new Uint8Array(t, e >>> 0, r >>> 0);
  }, n.wbg.__wbg_newwithlength_a381634e90c276d4 = function(t) {
    return new Uint8Array(t >>> 0);
  }, n.wbg.__wbg_node_02999533c4ea02e3 = function(t) {
    return t.node;
  }, n.wbg.__wbg_process_5c1d670bc53614b8 = function(t) {
    return t.process;
  }, n.wbg.__wbg_randomFillSync_ab2cfe79ebbf2740 = function() {
    return Cs(function(t, e) {
      t.randomFillSync(e);
    }, arguments);
  }, n.wbg.__wbg_require_79b1e9274cde3c87 = function() {
    return Cs(function() {
      return module.require;
    }, arguments);
  }, n.wbg.__wbg_set_65595bdd868b3009 = function(t, e, r) {
    t.set(e, r >>> 0);
  }, n.wbg.__wbg_stack_0ed75d68575b0f3c = function(t, e) {
    const r = e.stack, i = Wc(r, o.__wbindgen_malloc, o.__wbindgen_realloc), s = z;
    gr().setInt32(t + 4 * 1, s, !0), gr().setInt32(t + 4 * 0, i, !0);
  }, n.wbg.__wbg_startWorkers_2ca11761e08ff5d5 = function(t, e, r) {
    return dP(t, e, ll.__wrap(r));
  }, n.wbg.__wbg_static_accessor_GLOBAL_88a902d13a557d07 = function() {
    const t = typeof N_ > "u" ? null : N_;
    return Ai(t) ? 0 : Qa(t);
  }, n.wbg.__wbg_static_accessor_GLOBAL_THIS_56578be7e9f832b0 = function() {
    const t = typeof globalThis > "u" ? null : globalThis;
    return Ai(t) ? 0 : Qa(t);
  }, n.wbg.__wbg_static_accessor_SELF_37c5d418e4bf5819 = function() {
    const t = typeof self > "u" ? null : self;
    return Ai(t) ? 0 : Qa(t);
  }, n.wbg.__wbg_static_accessor_WINDOW_5de37043a91a9c40 = function() {
    const t = typeof window > "u" ? null : window;
    return Ai(t) ? 0 : Qa(t);
  }, n.wbg.__wbg_subarray_aa9065fa9dc5df96 = function(t, e, r) {
    return t.subarray(e >>> 0, r >>> 0);
  }, n.wbg.__wbg_toString_2f76f493957b63da = function(t, e, r) {
    const i = e.toString(r), s = Wc(i, o.__wbindgen_malloc, o.__wbindgen_realloc), a = z;
    gr().setInt32(t + 4 * 1, a, !0), gr().setInt32(t + 4 * 0, s, !0);
  }, n.wbg.__wbg_toString_c813bbd34d063839 = function(t) {
    return t.toString();
  }, n.wbg.__wbg_versions_c71aa1626a93e0a1 = function(t) {
    return t.versions;
  }, n.wbg.__wbindgen_bigint_from_i128 = function(t, e) {
    return t << BigInt(64) | BigInt.asUintN(64, e);
  }, n.wbg.__wbindgen_bigint_from_i64 = function(t) {
    return t;
  }, n.wbg.__wbindgen_bigint_from_str = function(t, e) {
    return BigInt(Wn(t, e));
  }, n.wbg.__wbindgen_bigint_from_u128 = function(t, e) {
    return BigInt.asUintN(64, t) << BigInt(64) | BigInt.asUintN(64, e);
  }, n.wbg.__wbindgen_bigint_from_u64 = function(t) {
    return BigInt.asUintN(64, t);
  }, n.wbg.__wbindgen_bigint_get_as_i64 = function(t, e) {
    const r = e, i = typeof r == "bigint" ? r : void 0;
    gr().setBigInt64(t + 8 * 1, Ai(i) ? BigInt(0) : i, !0), gr().setInt32(t + 4 * 0, !Ai(i), !0);
  }, n.wbg.__wbindgen_bit_and = function(t, e) {
    return t & e;
  }, n.wbg.__wbindgen_bit_or = function(t, e) {
    return t | e;
  }, n.wbg.__wbindgen_debug_string = function(t, e) {
    const r = vf(e), i = Wc(r, o.__wbindgen_malloc, o.__wbindgen_realloc), s = z;
    gr().setInt32(t + 4 * 1, s, !0), gr().setInt32(t + 4 * 0, i, !0);
  }, n.wbg.__wbindgen_error_new = function(t, e) {
    return new Error(Wn(t, e));
  }, n.wbg.__wbindgen_init_externref_table = function() {
    const t = o.__wbindgen_export_2, e = t.grow(4);
    t.set(0, void 0), t.set(e + 0, void 0), t.set(e + 1, null), t.set(e + 2, !0), t.set(e + 3, !1);
  }, n.wbg.__wbindgen_is_function = function(t) {
    return typeof t == "function";
  }, n.wbg.__wbindgen_is_object = function(t) {
    const e = t;
    return typeof e == "object" && e !== null;
  }, n.wbg.__wbindgen_is_string = function(t) {
    return typeof t == "string";
  }, n.wbg.__wbindgen_is_undefined = function(t) {
    return t === void 0;
  }, n.wbg.__wbindgen_jsval_eq = function(t, e) {
    return t === e;
  }, n.wbg.__wbindgen_lt = function(t, e) {
    return t < e;
  }, n.wbg.__wbindgen_memory = function() {
    return o.memory;
  }, n.wbg.__wbindgen_module = function() {
    return ul.__wbindgen_wasm_module;
  }, n.wbg.__wbindgen_neg = function(t) {
    return -t;
  }, n.wbg.__wbindgen_number_new = function(t) {
    return t;
  }, n.wbg.__wbindgen_shl = function(t, e) {
    return t << e;
  }, n.wbg.__wbindgen_shr = function(t, e) {
    return t >> e;
  }, n.wbg.__wbindgen_string_get = function(t, e) {
    const r = e, i = typeof r == "string" ? r : void 0;
    var s = Ai(i) ? 0 : Wc(i, o.__wbindgen_malloc, o.__wbindgen_realloc), a = z;
    gr().setInt32(t + 4 * 1, a, !0), gr().setInt32(t + 4 * 0, s, !0);
  }, n.wbg.__wbindgen_string_new = function(t, e) {
    return Wn(t, e);
  }, n.wbg.__wbindgen_throw = function(t, e) {
    throw new Error(Wn(t, e));
  }, n;
}
function Qy(n, t) {
  n.wbg.memory = t || new WebAssembly.Memory({ initial: 20, maximum: 16384, shared: !0 });
}
function Wy(n, t, e) {
  if (o = n.exports, ul.__wbindgen_wasm_module = t, Ja = null, Wa = null, typeof e < "u" && (typeof e != "number" || e === 0 || e % 65536 !== 0))
    throw "invalid stack size";
  return o.__wbindgen_start(e), o;
}
function zP(n, t) {
  if (o !== void 0) return o;
  let e;
  typeof n < "u" && (Object.getPrototypeOf(n) === Object.prototype ? { module: n, memory: t, thread_stack_size: e } = n : console.warn("using deprecated parameters for `initSync()`; pass a single object instead"));
  const r = Yy();
  Qy(r, t), n instanceof WebAssembly.Module || (n = new WebAssembly.Module(n));
  const i = new WebAssembly.Instance(n, r);
  return Wy(i, n, e);
}
async function ul(n, t) {
  if (o !== void 0) return o;
  let e;
  typeof n < "u" && (Object.getPrototypeOf(n) === Object.prototype ? { module_or_path: n, memory: t, thread_stack_size: e } = n : console.warn("using deprecated parameters for the initialization function; pass a single object instead")), typeof n > "u" && (n = new URL(
    /* @vite-ignore */
    "/tfhe_bg.wasm",
    import.meta.url
  ));
  const r = Yy();
  (typeof n == "string" || typeof Request == "function" && n instanceof Request || typeof URL == "function" && n instanceof URL) && (n = fetch(n)), Qy(r, t);
  const { instance: i, module: s } = await TP(await n, r);
  return Wy(i, s, e);
}
var kP = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Boolean: BP,
  BooleanCiphertext: Ar,
  BooleanClientKey: He,
  BooleanCompressedCiphertext: Ti,
  BooleanCompressedServerKey: Bo,
  BooleanEncryptionKeyChoice: mP,
  BooleanNoiseDistribution: zi,
  BooleanParameterSet: SP,
  BooleanParameters: ki,
  BooleanPublicKey: Ui,
  CompactCiphertextList: hi,
  CompactCiphertextListBuilder: Uc,
  CompactCiphertextListExpander: Ca,
  CompactPkeCrs: qe,
  CompressedFheBool: Gs,
  CompressedFheInt10: Ls,
  CompressedFheInt12: Ds,
  CompressedFheInt128: Ks,
  CompressedFheInt14: Vs,
  CompressedFheInt16: js,
  CompressedFheInt160: Hs,
  CompressedFheInt2: Ys,
  CompressedFheInt256: Qs,
  CompressedFheInt32: Ws,
  CompressedFheInt4: Js,
  CompressedFheInt6: $s,
  CompressedFheInt64: qs,
  CompressedFheInt8: Zs,
  CompressedFheUint10: Xs,
  CompressedFheUint1024: to,
  CompressedFheUint12: eo,
  CompressedFheUint128: ro,
  CompressedFheUint14: no,
  CompressedFheUint16: io,
  CompressedFheUint160: so,
  CompressedFheUint2: oo,
  CompressedFheUint2048: ao,
  CompressedFheUint256: co,
  CompressedFheUint32: _o,
  CompressedFheUint4: lo,
  CompressedFheUint512: uo,
  CompressedFheUint6: fo,
  CompressedFheUint64: ho,
  CompressedFheUint8: po,
  FheBool: Cr,
  FheInt10: Ir,
  FheInt12: Nr,
  FheInt128: Or,
  FheInt14: Tr,
  FheInt16: zr,
  FheInt160: kr,
  FheInt2: Ur,
  FheInt256: Fr,
  FheInt32: Gr,
  FheInt4: Lr,
  FheInt6: Dr,
  FheInt64: Kr,
  FheInt8: Vr,
  FheTypes: EP,
  FheUint10: jr,
  FheUint1024: Hr,
  FheUint12: Yr,
  FheUint128: Qr,
  FheUint14: Wr,
  FheUint16: Jr,
  FheUint160: $r,
  FheUint2: qr,
  FheUint2048: Zr,
  FheUint256: Xr,
  FheUint32: tn,
  FheUint4: en,
  FheUint512: rn,
  FheUint6: nn,
  FheUint64: sn,
  FheUint8: on,
  ProvenCompactCiphertextList: Co,
  Shortint: IP,
  ShortintCiphertext: mr,
  ShortintClientKey: Oe,
  ShortintCompactPublicKeyEncryptionParameters: ys,
  ShortintCompactPublicKeyEncryptionParametersName: RP,
  ShortintCompressedCiphertext: Fi,
  ShortintCompressedPublicKey: Gi,
  ShortintCompressedServerKey: Io,
  ShortintEncryptionKeyChoice: PP,
  ShortintNoiseDistribution: Ze,
  ShortintPBSOrder: vP,
  ShortintParameters: pi,
  ShortintParametersName: MP,
  ShortintPublicKey: Li,
  TfheClientKey: tt,
  TfheCompactPublicKey: Fe,
  TfheCompressedCompactPublicKey: vi,
  TfheCompressedPublicKey: Ct,
  TfheCompressedServerKey: wo,
  TfheConfig: bs,
  TfheConfigBuilder: Mi,
  TfhePublicKey: Mt,
  TfheServerKey: fc,
  ZkComputeLoad: Hy,
  default: ul,
  initSync: zP,
  initThreadPool: jy,
  init_panic_hook: Vy,
  set_server_key: gP,
  shortint_params_name: bP,
  shortint_pke_params_name: yP,
  tfhe: OP,
  wbg_rayon_PoolBuilder: ll,
  wbg_rayon_start_worker: AP
});
const UP = BigInt(1024 * 1024 * 512), ch = BigInt(1024 * 1024 * 512), _h = BigInt(1024 * 1024 * 512), Za = (n) => n ? new URL(n).href : "", Dw = (n) => {
  let t = n.toString(16);
  return t.length % 2 ? "0" + t : t;
}, gn = (n) => {
  const t = n.replace(/^(0x)/, "").match(/.{1,2}/g);
  return t ? Uint8Array.from(t.map((e) => parseInt(e, 16))) : new Uint8Array();
}, Mf = (n) => n.reduce((t, e) => t + e.toString(16).padStart(2, "0"), ""), h_ = function(n) {
  if (!n || (n == null ? void 0 : n.length) === 0)
    return BigInt(0);
  const t = ne.from(n);
  return a2(t);
}, zu = {}, Jy = async (n, t) => {
  if (zu[n])
    return zu[n];
  try {
    const e = await fetch(`${n}keyurl`);
    if (!e.ok)
      throw new Error(`HTTP error! status: ${e.status}`);
    const r = await e.json();
    if (r) {
      let i;
      if (!t)
        i = r.response.fhe_key_info[0].fhe_public_key.urls[0], t = r.response.fhe_key_info[0].fhe_public_key.data_id;
      else {
        const v = r.response.fhe_key_info.find((R) => R.fhe_public_key.data_id === t);
        if (!v)
          throw new Error(`Could not find FHE key info with data_id ${t}`);
        i = v.fhe_public_key.urls[0];
      }
      const s = await fetch(i);
      if (!s.ok)
        throw new Error(`HTTP error! status: ${s.status} on ${s.url}`);
      const a = await s.bytes(), c = r.response.crs[2048].urls[0], _ = r.response.crs[2048].data_id, p = await fetch(c);
      if (!p.ok)
        throw new Error(`HTTP error! status: ${p.status} on ${p.url}`);
      const f = await p.bytes();
      let d;
      try {
        d = Fe.safe_deserialize(a, ch);
      } catch (v) {
        throw new Error("Invalid public key (deserialization failed)", {
          cause: v
        });
      }
      let y;
      try {
        y = qe.safe_deserialize(new Uint8Array(f), _h);
      } catch (v) {
        throw new Error("Invalid crs (deserialization failed)", {
          cause: v
        });
      }
      const b = {
        publicKey: d,
        publicKeyId: t,
        publicParams: {
          2048: {
            publicParams: y,
            publicParamsId: _
          }
        }
      };
      return zu[n] = b, b;
    } else
      throw new Error("No public key available");
  } catch (e) {
    throw new Error("Impossible to fetch public key: wrong relayer url.", {
      cause: e
    });
  }
};
var FP = [
  {
    inputs: [],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      }
    ],
    name: "AddressEmptyCode",
    type: "error"
  },
  {
    inputs: [],
    name: "ECDSAInvalidSignature",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "length",
        type: "uint256"
      }
    ],
    name: "ECDSAInvalidSignatureLength",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "ECDSAInvalidSignatureS",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "implementation",
        type: "address"
      }
    ],
    name: "ERC1967InvalidImplementation",
    type: "error"
  },
  {
    inputs: [],
    name: "ERC1967NonPayable",
    type: "error"
  },
  {
    inputs: [],
    name: "FailedInnerCall",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidInitialization",
    type: "error"
  },
  {
    inputs: [],
    name: "NotInitializing",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "OwnableInvalidOwner",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "OwnableUnauthorizedAccount",
    type: "error"
  },
  {
    inputs: [],
    name: "UUPSUnauthorizedCallContext",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "slot",
        type: "bytes32"
      }
    ],
    name: "UUPSUnsupportedProxiableUUID",
    type: "error"
  },
  {
    anonymous: !1,
    inputs: [],
    name: "EIP712DomainChanged",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "uint64",
        name: "version",
        type: "uint64"
      }
    ],
    name: "Initialized",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferStarted",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    name: "SignerAdded",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    name: "SignerRemoved",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "implementation",
        type: "address"
      }
    ],
    name: "Upgraded",
    type: "event"
  },
  {
    inputs: [],
    name: "UPGRADE_INTERFACE_VERSION",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "acceptOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    name: "addSigner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "eip712Domain",
    outputs: [
      {
        internalType: "bytes1",
        name: "fields",
        type: "bytes1"
      },
      {
        internalType: "string",
        name: "name",
        type: "string"
      },
      {
        internalType: "string",
        name: "version",
        type: "string"
      },
      {
        internalType: "uint256",
        name: "chainId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "verifyingContract",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "salt",
        type: "bytes32"
      },
      {
        internalType: "uint256[]",
        name: "extensions",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getSigners",
    outputs: [
      {
        internalType: "address[]",
        name: "",
        type: "address[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getThreshold",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getVersion",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [],
    name: "get_DECRYPTIONRESULT_TYPE",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "initialOwner",
        type: "address"
      }
    ],
    name: "initialize",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "isSigner",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pendingOwner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "proxiableUUID",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    name: "removeSigner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newImplementation",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "upgradeToAndCall",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "aclAddress",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "handlesList",
        type: "uint256[]"
      },
      {
        internalType: "bytes",
        name: "decryptedResult",
        type: "bytes"
      },
      {
        internalType: "bytes[]",
        name: "signatures",
        type: "bytes[]"
      }
    ],
    name: "verifySignatures",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const GP = (n) => {
  if (typeof n.network == "string")
    return new e2(n.network);
  if (n.network)
    return new n2(n.network);
  throw new Error("You must provide a network URL or a EIP1193 object (eg: window.ethereum)");
}, LP = async (n, t) => {
  if (t.chainId && typeof t.chainId == "number")
    return t.chainId;
  if (t.chainId && typeof t.chainId != "number")
    throw new Error("chainId must be a number.");
  {
    const e = (await n.getNetwork()).chainId;
    return Number(e);
  }
}, DP = async (n) => {
  if (n.relayerUrl && !n.publicKey) {
    const t = await Jy(Za(n.relayerUrl));
    return { publicKey: t.publicKey, publicKeyId: t.publicKeyId };
  } else if (n.publicKey && n.publicKey.data && n.publicKey.id) {
    const t = n.publicKey.data;
    try {
      return {
        publicKey: Fe.safe_deserialize(t, ch),
        publicKeyId: n.publicKey.id
      };
    } catch (e) {
      throw new Error("Invalid public key (deserialization failed)", {
        cause: e
      });
    }
  } else
    throw new Error("You must provide a public key with its public key ID.");
}, KP = async (n) => {
  if (n.relayerUrl && !n.publicParams)
    return (await Jy(Za(n.relayerUrl))).publicParams;
  if (n.publicParams && n.publicParams[2048]) {
    const t = n.publicParams[2048].publicParams;
    try {
      return {
        2048: {
          publicParams: qe.safe_deserialize(t, _h),
          publicParamsId: n.publicParams[2048].publicParamsId
        }
      };
    } catch (e) {
      throw new Error("Invalid public key (deserialization failed)", {
        cause: e
      });
    }
  } else
    throw new Error("You must provide a valid CRS with its CRS ID.");
}, VP = async (n, t) => await new _s(t.kmsContractAddress, FP, n).getSigners(), jP = {
  1: 0,
  // ebool takes 2 encrypted bits
  4: 1,
  8: 2,
  16: 3,
  32: 4,
  64: 5,
  128: 6,
  160: 7,
  256: 8,
  512: 9,
  1024: 10,
  2048: 11
}, HP = (n, t, e, r, i) => {
  const s = sd("keccak256").update(ne.from(n)).digest(), a = ne.from(gn(e)), c = ne.from(new Uint8Array(l2(BigInt(r), 32)));
  return t.map((p, f) => {
    const d = jP[p], y = ne.from([f]), b = sd("keccak256").update(s).update(y).update(a).update(c).digest(), v = new Uint8Array(32);
    return v.set(b, 0), v.set([f, d, i], 29), v;
  });
}, YP = () => 0, nr = (n, t) => {
  if (n == null)
    throw new Error("Missing value");
  let e;
  if (t >= 8 ? e = BigInt(`0x${new Array(t / 8).fill(null).reduce((r) => `${r}ff`, "")}`) : e = BigInt(2 ** t - 1), typeof n != "number" && typeof n != "bigint")
    throw new Error("Value must be a number or a bigint.");
  if (n > e)
    throw new Error(`The value exceeds the limit for ${t}bits integer (${e.toString()}).`);
}, QP = (n, t, e, r, i) => (s, a) => {
  if (!Tn(s))
    throw new Error("Contract address is not a valid address.");
  if (!Tn(a))
    throw new Error("User address is not a valid address.");
  const c = r, _ = [], p = hi.builder(c);
  let f = new Uint8Array(), d = 0;
  const y = (b) => {
    if (_.reduce((v, R) => v + Math.max(2, R), 0) + b > 2048)
      throw Error("Packing more than 2048 bits in a single input ciphertext is unsupported");
    if (_.length + 1 > 256)
      throw Error("Packing more than 256 variables in a single input ciphertext is unsupported");
  };
  return e = e.slice(-1) == "/" ? e.slice(0, -1) : e, {
    addBool(b) {
      if (b == null)
        throw new Error("Missing value");
      if (typeof b != "boolean" && typeof b != "number" && typeof b != "bigint")
        throw new Error("The value must be a boolean, a number or a bigint.");
      if ((typeof b != "bigint" || typeof b != "number") && Number(b) > 1)
        throw new Error("The value must be 1 or 0.");
      return nr(Number(b), 1), y(2), p.push_boolean(!!b), _.push(1), this;
    },
    add4(b) {
      return nr(b, 4), y(4), p.push_u4(Number(b)), _.push(4), this;
    },
    add8(b) {
      return nr(b, 8), y(8), p.push_u8(Number(b)), _.push(8), this;
    },
    add16(b) {
      return nr(b, 16), y(16), p.push_u16(Number(b)), _.push(16), this;
    },
    add32(b) {
      return nr(b, 32), y(32), p.push_u32(Number(b)), _.push(32), this;
    },
    add64(b) {
      return nr(b, 64), y(64), p.push_u64(BigInt(b)), _.push(64), this;
    },
    add128(b) {
      return nr(b, 128), y(128), p.push_u128(BigInt(b)), _.push(128), this;
    },
    addAddress(b) {
      if (!Tn(b))
        throw new Error("The value must be a valid address.");
      return y(160), p.push_u160(BigInt(b)), _.push(160), this;
    },
    add256(b) {
      return nr(b, 256), y(256), p.push_u256(BigInt(b)), _.push(256), this;
    },
    addBytes64(b) {
      if (b.length !== 64)
        throw Error("Uncorrect length of input Uint8Array, should be 64 for an ebytes64");
      const v = h_(b);
      return nr(v, 512), y(512), p.push_u512(v), _.push(512), this;
    },
    addBytes128(b) {
      if (b.length !== 128)
        throw Error("Uncorrect length of input Uint8Array, should be 128 for an ebytes128");
      const v = h_(b);
      return nr(v, 1024), y(1024), p.push_u1024(v), _.push(1024), this;
    },
    addBytes256(b) {
      if (b.length !== 256)
        throw Error("Uncorrect length of input Uint8Array, should be 256 for an ebytes256");
      const v = h_(b);
      return nr(v, 2048), y(2048), p.push_u2048(v), _.push(2048), this;
    },
    getBits() {
      return _;
    },
    _getClosestPP() {
      const b = (A) => Object.keys(A), v = _.reduce((A, B) => A + B, 0), R = b(i), M = R.find((A) => Number(A) >= v);
      if (!M)
        throw new Error(`Too many bits in provided values. Maximum is ${R[R.length - 1]}.`);
      return M;
    },
    _prove() {
      if (f.length > 0 && d == _.length)
        return f;
      const b = this._getClosestPP(), v = i[b].publicParams, R = gn(s), M = gn(a), A = gn(n), B = gn(t.toString(16)), N = new Uint8Array(R.length + M.length + A.length + 32);
      return N.set(R, 0), N.set(M, 20), N.set(A, 40), N.set(B, N.length - B.length), f = p.build_with_proof_packed(v, N, Hy.Verify).safe_serialize(UP), d = _.length, f;
    },
    async _verify(b) {
      const v = {
        contractAddress: zt(s),
        userAddress: zt(a),
        ciphertextWithZkpok: ne.from(b).toString("hex"),
        contractChainId: "0x" + t.toString(16)
      }, R = {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(v)
      }, M = `${e}/input-proof`;
      let A;
      try {
        const X = await fetch(M, R);
        if (!X.ok)
          throw new Error(`Httpz-relayer didn't response correctly. Bad status ${X.statusText}. Content: ${await X.text()}`);
        try {
          A = await X.json();
        } catch (V) {
          throw new Error("Httpz-relayer didn't response correctly. Bad JSON.", { cause: V });
        }
      } catch (X) {
        throw new Error("Httpz-relayer didn't response correctly.", {
          cause: X
        });
      }
      const B = this._handles();
      if (A.response.handles && A.response.handles.length > 0) {
        const X = A.response.handles.map(gn);
        if (B.length != X.length)
          throw new Error(`Incorrect Handles list sizes: (expected) ${B.length} != ${X.length} (received)`);
        for (let V = 0; V < B.length; V++) {
          let nt = B[V], ft = X[V], pt = ne.from(nt).toString("hex"), At = ne.from(ft).toString("hex");
          if (pt !== At)
            throw new Error(`Incorrect Handle ${V}: (expected) ${pt} != ${At} (received)`);
        }
      }
      const N = A.response.signatures;
      let G = Dw(B.length);
      const D = N.length;
      return G += Dw(D), B.map((X) => Mf(X)).map((X) => G += X), N.map((X) => G += X.slice(2)), {
        handles: B,
        inputProof: gn(G)
      };
    },
    _handles() {
      return HP(this._prove(), _, n, t, YP());
    },
    async encrypt() {
      let b = Date.now();
      const v = await this._prove();
      console.log(`Encrypting and proving in ${Math.round((Date.now() - b) / 100) / 10}s`), b = Date.now();
      const R = await this._verify(v);
      return console.log(`Verifying in ${Math.round((Date.now() - b) / 100) / 10}s`), R;
    }
  };
};
let W, Qt = 0, $a = null;
function No() {
  return ($a === null || $a.byteLength === 0) && ($a = new Uint8Array(W.memory.buffer)), $a;
}
const p_ = typeof TextEncoder < "u" ? new TextEncoder("utf-8") : { encode: () => {
  throw Error("TextEncoder not available");
} }, WP = typeof p_.encodeInto == "function" ? function(n, t) {
  return p_.encodeInto(n, t);
} : function(n, t) {
  const e = p_.encode(n);
  return t.set(e), {
    read: n.length,
    written: e.length
  };
};
function go(n, t, e) {
  if (e === void 0) {
    const c = p_.encode(n), _ = t(c.length, 1) >>> 0;
    return No().subarray(_, _ + c.length).set(c), Qt = c.length, _;
  }
  let r = n.length, i = t(r, 1) >>> 0;
  const s = No();
  let a = 0;
  for (; a < r; a++) {
    const c = n.charCodeAt(a);
    if (c > 127) break;
    s[i + a] = c;
  }
  if (a !== r) {
    a !== 0 && (n = n.slice(a)), i = e(i, r, r = a + n.length * 3, 1) >>> 0;
    const c = No().subarray(i + a, i + r), _ = WP(n, c);
    a += _.written, i = e(i, r, a, 1) >>> 0;
  }
  return Qt = a, i;
}
let Ei = null;
function De() {
  return (Ei === null || Ei.buffer.detached === !0 || Ei.buffer.detached === void 0 && Ei.buffer !== W.memory.buffer) && (Ei = new DataView(W.memory.buffer)), Ei;
}
function yo(n) {
  const t = W.__externref_table_alloc();
  return W.__wbindgen_export_4.set(t, n), t;
}
function mi(n, t) {
  try {
    return n.apply(this, t);
  } catch (e) {
    const r = yo(e);
    W.__wbindgen_exn_store(r);
  }
}
const $y = typeof TextDecoder < "u" ? new TextDecoder("utf-8", { ignoreBOM: !0, fatal: !0 }) : { decode: () => {
  throw Error("TextDecoder not available");
} };
typeof TextDecoder < "u" && $y.decode();
function La(n, t) {
  return n = n >>> 0, $y.decode(No().subarray(n, n + t));
}
function Qn(n) {
  return n == null;
}
function xf(n) {
  const t = typeof n;
  if (t == "number" || t == "boolean" || n == null)
    return `${n}`;
  if (t == "string")
    return `"${n}"`;
  if (t == "symbol") {
    const i = n.description;
    return i == null ? "Symbol" : `Symbol(${i})`;
  }
  if (t == "function") {
    const i = n.name;
    return typeof i == "string" && i.length > 0 ? `Function(${i})` : "Function";
  }
  if (Array.isArray(n)) {
    const i = n.length;
    let s = "[";
    i > 0 && (s += xf(n[0]));
    for (let a = 1; a < i; a++)
      s += ", " + xf(n[a]);
    return s += "]", s;
  }
  const e = /\[object ([^\]]+)\]/.exec(toString.call(n));
  let r;
  if (e && e.length > 1)
    r = e[1];
  else
    return toString.call(n);
  if (r == "Object")
    try {
      return "Object(" + JSON.stringify(n) + ")";
    } catch {
      return "Object";
    }
  return n instanceof Error ? `${n.name}: ${n.message}
${n.stack}` : r;
}
function us(n, t) {
  if (!(n instanceof t))
    throw new Error(`expected instance of ${t.name}`);
}
function hr(n, t) {
  return n = n >>> 0, No().subarray(n / 1, n / 1 + t);
}
function pr(n, t) {
  const e = t(n.length * 1, 1) >>> 0;
  return No().set(n, e / 1), Qt = n.length, e;
}
function Ta(n) {
  const t = W.__wbindgen_export_4.get(n);
  return W.__externref_table_dealloc(n), t;
}
function qy(n, t) {
  const e = t(n.length * 4, 4) >>> 0, r = De();
  for (let i = 0; i < n.length; i++)
    r.setUint32(e + 4 * i, yo(n[i]), !0);
  return Qt = n.length, e;
}
function JP(n, t, e) {
  const r = qy(n, W.__wbindgen_malloc), i = Qt, s = go(t, W.__wbindgen_malloc, W.__wbindgen_realloc), a = Qt, c = go(e, W.__wbindgen_malloc, W.__wbindgen_realloc), _ = Qt, p = W.new_client(r, i, s, a, c, _);
  if (p[2])
    throw Ta(p[1]);
  return fl.__wrap(p[0]);
}
function Zy(n, t) {
  n = n >>> 0;
  const e = De(), r = [];
  for (let i = n; i < n + 4 * t; i += 4)
    r.push(W.__wbindgen_export_4.get(e.getUint32(i, !0)));
  return W.__externref_drop_slice(n, t), r;
}
function $P() {
  const n = W.cryptobox_keygen();
  return Es.__wrap(n);
}
function qP(n) {
  us(n, Es);
  const t = W.cryptobox_get_pk(n.__wbg_ptr);
  return za.__wrap(t);
}
function ZP(n) {
  us(n, za);
  const t = W.cryptobox_pk_to_u8vec(n.__wbg_ptr);
  if (t[3])
    throw Ta(t[2]);
  var e = hr(t[0], t[1]).slice();
  return W.__wbindgen_free(t[0], t[1] * 1, 1), e;
}
function XP(n) {
  us(n, Es);
  const t = W.cryptobox_sk_to_u8vec(n.__wbg_ptr);
  if (t[3])
    throw Ta(t[2]);
  var e = hr(t[0], t[1]).slice();
  return W.__wbindgen_free(t[0], t[1] * 1, 1), e;
}
function tv(n) {
  const t = pr(n, W.__wbindgen_malloc), e = Qt, r = W.u8vec_to_cryptobox_pk(t, e);
  if (r[2])
    throw Ta(r[1]);
  return za.__wrap(r[0]);
}
function ev(n) {
  const t = pr(n, W.__wbindgen_malloc), e = Qt, r = W.u8vec_to_cryptobox_sk(t, e);
  if (r[2])
    throw Ta(r[1]);
  return Es.__wrap(r[0]);
}
function rv(n, t, e, r, i, s, a) {
  us(n, fl), us(i, za), us(s, Es);
  const c = W.process_reencryption_resp_from_js(n.__wbg_ptr, t, e, r, i.__wbg_ptr, s.__wbg_ptr, a);
  if (c[3])
    throw Ta(c[2]);
  var _ = Zy(c[0], c[1]).slice();
  return W.__wbindgen_free(c[0], c[1] * 4, 4), _;
}
typeof FinalizationRegistry > "u" || new FinalizationRegistry((n) => W.__wbg_ciphertexthandle_free(n >>> 0, 1));
const Kw = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => W.__wbg_client_free(n >>> 0, 1));
class fl {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(fl.prototype);
    return e.__wbg_ptr = t, Kw.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Kw.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    W.__wbg_client_free(t, 0);
  }
}
typeof FinalizationRegistry > "u" || new FinalizationRegistry((n) => W.__wbg_cryptoboxct_free(n >>> 0, 1));
typeof FinalizationRegistry > "u" || new FinalizationRegistry((n) => W.__wbg_eip712domainmsg_free(n >>> 0, 1));
typeof FinalizationRegistry > "u" || new FinalizationRegistry((n) => W.__wbg_parsedreencryptionrequest_free(n >>> 0, 1));
const Vw = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => W.__wbg_privateenckey_free(n >>> 0, 1));
class Es {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(Es.prototype);
    return e.__wbg_ptr = t, Vw.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Vw.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    W.__wbg_privateenckey_free(t, 0);
  }
}
typeof FinalizationRegistry > "u" || new FinalizationRegistry((n) => W.__wbg_privatesigkey_free(n >>> 0, 1));
const jw = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => W.__wbg_publicenckey_free(n >>> 0, 1));
class za {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(za.prototype);
    return e.__wbg_ptr = t, jw.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, jw.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    W.__wbg_publicenckey_free(t, 0);
  }
}
typeof FinalizationRegistry > "u" || new FinalizationRegistry((n) => W.__wbg_publicsigkey_free(n >>> 0, 1));
typeof FinalizationRegistry > "u" || new FinalizationRegistry((n) => W.__wbg_reencryptionrequest_free(n >>> 0, 1));
const nv = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => W.__wbg_reencryptionresponse_free(n >>> 0, 1));
class lh {
  static __unwrap(t) {
    return t instanceof lh ? t.__destroy_into_raw() : 0;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, nv.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    W.__wbg_reencryptionresponse_free(t, 0);
  }
  /**
   * @returns {Uint8Array}
   */
  get signature() {
    const t = W.__wbg_get_reencryptionresponse_signature(this.__wbg_ptr);
    var e = hr(t[0], t[1]).slice();
    return W.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * @param {Uint8Array} arg0
   */
  set signature(t) {
    const e = pr(t, W.__wbindgen_malloc), r = Qt;
    W.__wbg_set_eip712domainmsg_name(this.__wbg_ptr, e, r);
  }
  /**
   * This is the external signature created from the Eip712 domain
   * on the structure, where reencryptedShare is bincode::serialize(&payload)
   * struct UserDecryptResponseVerification {
   *      bytes publicKey;
   *      uint256\[\] ctHandles;
   *      bytes reencryptedShare;
   * }
   * @returns {Uint8Array}
   */
  get external_signature() {
    const t = W.__wbg_get_reencryptionresponse_external_signature(this.__wbg_ptr);
    var e = hr(t[0], t[1]).slice();
    return W.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * This is the external signature created from the Eip712 domain
   * on the structure, where reencryptedShare is bincode::serialize(&payload)
   * struct UserDecryptResponseVerification {
   *      bytes publicKey;
   *      uint256\[\] ctHandles;
   *      bytes reencryptedShare;
   * }
   * @param {Uint8Array} arg0
   */
  set external_signature(t) {
    const e = pr(t, W.__wbindgen_malloc), r = Qt;
    W.__wbg_set_eip712domainmsg_version(this.__wbg_ptr, e, r);
  }
  /**
   * The actual \[ReencryptionResponsePayload\].
   * @returns {ReencryptionResponsePayload | undefined}
   */
  get payload() {
    const t = W.__wbg_get_reencryptionresponse_payload(this.__wbg_ptr);
    return t === 0 ? void 0 : O_.__wrap(t);
  }
  /**
   * The actual \[ReencryptionResponsePayload\].
   * @param {ReencryptionResponsePayload | undefined} [arg0]
   */
  set payload(t) {
    let e = 0;
    Qn(t) || (us(t, O_), e = t.__destroy_into_raw()), W.__wbg_set_reencryptionresponse_payload(this.__wbg_ptr, e);
  }
}
const Hw = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => W.__wbg_reencryptionresponsepayload_free(n >>> 0, 1));
class O_ {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(O_.prototype);
    return e.__wbg_ptr = t, Hw.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Hw.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    W.__wbg_reencryptionresponsepayload_free(t, 0);
  }
  /**
   * The server's signature verification key, Encoded using SEC1.
   * Needed to validate the response, but MUST also be linked to a list of
   * trusted keys.
   * @returns {Uint8Array}
   */
  get verification_key() {
    const t = W.__wbg_get_reencryptionresponsepayload_verification_key(this.__wbg_ptr);
    var e = hr(t[0], t[1]).slice();
    return W.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * The server's signature verification key, Encoded using SEC1.
   * Needed to validate the response, but MUST also be linked to a list of
   * trusted keys.
   * @param {Uint8Array} arg0
   */
  set verification_key(t) {
    const e = pr(t, W.__wbindgen_malloc), r = Qt;
    W.__wbg_set_eip712domainmsg_name(this.__wbg_ptr, e, r);
  }
  /**
   * This is needed to ensure the response corresponds to the request.
   * It is the digest of UserDecryptionLinker hashed using EIP712
   * under the given domain in the request.
   * @returns {Uint8Array}
   */
  get digest() {
    const t = W.__wbg_get_reencryptionresponsepayload_digest(this.__wbg_ptr);
    var e = hr(t[0], t[1]).slice();
    return W.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * This is needed to ensure the response corresponds to the request.
   * It is the digest of UserDecryptionLinker hashed using EIP712
   * under the given domain in the request.
   * @param {Uint8Array} arg0
   */
  set digest(t) {
    const e = pr(t, W.__wbindgen_malloc), r = Qt;
    W.__wbg_set_eip712domainmsg_version(this.__wbg_ptr, e, r);
  }
  /**
   * The resulting signcrypted ciphertexts, each ciphertext
   * must be decrypted and then reconstructed with the other shares
   * to produce the final plaintext.
   * @returns {(TypedSigncryptedCiphertext)[]}
   */
  get signcrypted_ciphertexts() {
    const t = W.__wbg_get_reencryptionresponsepayload_signcrypted_ciphertexts(this.__wbg_ptr);
    var e = Zy(t[0], t[1]).slice();
    return W.__wbindgen_free(t[0], t[1] * 4, 4), e;
  }
  /**
   * The resulting signcrypted ciphertexts, each ciphertext
   * must be decrypted and then reconstructed with the other shares
   * to produce the final plaintext.
   * @param {(TypedSigncryptedCiphertext)[]} arg0
   */
  set signcrypted_ciphertexts(t) {
    const e = qy(t, W.__wbindgen_malloc), r = Qt;
    W.__wbg_set_reencryptionresponsepayload_signcrypted_ciphertexts(this.__wbg_ptr, e, r);
  }
  /**
   * The ID of the MPC party doing the reencryption. Used for polynomial
   * reconstruction.
   * @returns {number}
   */
  get party_id() {
    return W.__wbg_get_reencryptionresponsepayload_party_id(this.__wbg_ptr) >>> 0;
  }
  /**
   * The ID of the MPC party doing the reencryption. Used for polynomial
   * reconstruction.
   * @param {number} arg0
   */
  set party_id(t) {
    W.__wbg_set_reencryptionresponsepayload_party_id(this.__wbg_ptr, t);
  }
  /**
   * The degree of the sharing scheme used.
   * @returns {number}
   */
  get degree() {
    return W.__wbg_get_reencryptionresponsepayload_degree(this.__wbg_ptr) >>> 0;
  }
  /**
   * The degree of the sharing scheme used.
   * @param {number} arg0
   */
  set degree(t) {
    W.__wbg_set_reencryptionresponsepayload_degree(this.__wbg_ptr, t);
  }
}
typeof FinalizationRegistry > "u" || new FinalizationRegistry((n) => W.__wbg_requestid_free(n >>> 0, 1));
const Yw = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => W.__wbg_typedciphertext_free(n >>> 0, 1));
class hc {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(hc.prototype);
    return e.__wbg_ptr = t, Yw.register(e, e.__wbg_ptr, e), e;
  }
  static __unwrap(t) {
    return t instanceof hc ? t.__destroy_into_raw() : 0;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Yw.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    W.__wbg_typedciphertext_free(t, 0);
  }
  /**
   * The actual ciphertext to decrypt, taken directly from HTTPZ.
   * @returns {Uint8Array}
   */
  get ciphertext() {
    const t = W.__wbg_get_typedciphertext_ciphertext(this.__wbg_ptr);
    var e = hr(t[0], t[1]).slice();
    return W.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * The actual ciphertext to decrypt, taken directly from HTTPZ.
   * @param {Uint8Array} arg0
   */
  set ciphertext(t) {
    const e = pr(t, W.__wbindgen_malloc), r = Qt;
    W.__wbg_set_eip712domainmsg_name(this.__wbg_ptr, e, r);
  }
  /**
   * The type of plaintext encrypted.
   * @returns {number}
   */
  get fhe_type() {
    return W.__wbg_get_typedciphertext_fhe_type(this.__wbg_ptr);
  }
  /**
   * The type of plaintext encrypted.
   * @param {number} arg0
   */
  set fhe_type(t) {
    W.__wbg_set_typedciphertext_fhe_type(this.__wbg_ptr, t);
  }
  /**
   * The external handle of the ciphertext (the handle used in the copro).
   * @returns {Uint8Array}
   */
  get external_handle() {
    const t = W.__wbg_get_typedciphertext_external_handle(this.__wbg_ptr);
    var e = hr(t[0], t[1]).slice();
    return W.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * The external handle of the ciphertext (the handle used in the copro).
   * @param {Uint8Array} arg0
   */
  set external_handle(t) {
    const e = pr(t, W.__wbindgen_malloc), r = Qt;
    W.__wbg_set_eip712domainmsg_version(this.__wbg_ptr, e, r);
  }
  /**
   * The ciphertext format, see CiphertextFormat documentation for details.
   * CiphertextFormat::default() is used if unspecified.
   * @returns {number}
   */
  get ciphertext_format() {
    return W.__wbg_get_typedciphertext_ciphertext_format(this.__wbg_ptr);
  }
  /**
   * The ciphertext format, see CiphertextFormat documentation for details.
   * CiphertextFormat::default() is used if unspecified.
   * @param {number} arg0
   */
  set ciphertext_format(t) {
    W.__wbg_set_typedciphertext_ciphertext_format(this.__wbg_ptr, t);
  }
}
const Qw = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => W.__wbg_typedplaintext_free(n >>> 0, 1));
class uh {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(uh.prototype);
    return e.__wbg_ptr = t, Qw.register(e, e.__wbg_ptr, e), e;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Qw.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    W.__wbg_typedplaintext_free(t, 0);
  }
  /**
   * The actual plaintext in bytes.
   * @returns {Uint8Array}
   */
  get bytes() {
    const t = W.__wbg_get_typedplaintext_bytes(this.__wbg_ptr);
    var e = hr(t[0], t[1]).slice();
    return W.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * The actual plaintext in bytes.
   * @param {Uint8Array} arg0
   */
  set bytes(t) {
    const e = pr(t, W.__wbindgen_malloc), r = Qt;
    W.__wbg_set_eip712domainmsg_name(this.__wbg_ptr, e, r);
  }
  /**
   * The type of plaintext encrypted.
   * @returns {number}
   */
  get fhe_type() {
    return W.__wbg_get_typedplaintext_fhe_type(this.__wbg_ptr);
  }
  /**
   * The type of plaintext encrypted.
   * @param {number} arg0
   */
  set fhe_type(t) {
    W.__wbg_set_typedplaintext_fhe_type(this.__wbg_ptr, t);
  }
}
const Ww = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => W.__wbg_typedsigncryptedciphertext_free(n >>> 0, 1));
class pc {
  static __wrap(t) {
    t = t >>> 0;
    const e = Object.create(pc.prototype);
    return e.__wbg_ptr = t, Ww.register(e, e.__wbg_ptr, e), e;
  }
  static __unwrap(t) {
    return t instanceof pc ? t.__destroy_into_raw() : 0;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Ww.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    W.__wbg_typedsigncryptedciphertext_free(t, 0);
  }
  /**
   * The type of plaintext encrypted.
   * @returns {number}
   */
  get fhe_type() {
    return W.__wbg_get_typedciphertext_fhe_type(this.__wbg_ptr);
  }
  /**
   * The type of plaintext encrypted.
   * @param {number} arg0
   */
  set fhe_type(t) {
    W.__wbg_set_typedciphertext_fhe_type(this.__wbg_ptr, t);
  }
  /**
   * The signcrypted payload, using a hybrid encryption approach in
   * sign-then-encrypt.
   * @returns {Uint8Array}
   */
  get signcrypted_ciphertext() {
    const t = W.__wbg_get_typedsigncryptedciphertext_signcrypted_ciphertext(this.__wbg_ptr);
    var e = hr(t[0], t[1]).slice();
    return W.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * The signcrypted payload, using a hybrid encryption approach in
   * sign-then-encrypt.
   * @param {Uint8Array} arg0
   */
  set signcrypted_ciphertext(t) {
    const e = pr(t, W.__wbindgen_malloc), r = Qt;
    W.__wbg_set_eip712domainmsg_name(this.__wbg_ptr, e, r);
  }
  /**
   * The external handles that were originally in the request.
   * @returns {Uint8Array}
   */
  get external_handle() {
    const t = W.__wbg_get_typedsigncryptedciphertext_external_handle(this.__wbg_ptr);
    var e = hr(t[0], t[1]).slice();
    return W.__wbindgen_free(t[0], t[1] * 1, 1), e;
  }
  /**
   * The external handles that were originally in the request.
   * @param {Uint8Array} arg0
   */
  set external_handle(t) {
    const e = pr(t, W.__wbindgen_malloc), r = Qt;
    W.__wbg_set_eip712domainmsg_version(this.__wbg_ptr, e, r);
  }
}
async function iv(n, t) {
  if (typeof Response == "function" && n instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming == "function")
      try {
        return await WebAssembly.instantiateStreaming(n, t);
      } catch (r) {
        if (n.headers.get("Content-Type") != "application/wasm")
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", r);
        else
          throw r;
      }
    const e = await n.arrayBuffer();
    return await WebAssembly.instantiate(e, t);
  } else {
    const e = await WebAssembly.instantiate(n, t);
    return e instanceof WebAssembly.Instance ? { instance: e, module: n } : e;
  }
}
function sv() {
  const n = {};
  return n.wbg = {}, n.wbg.__wbg_String_8f0eb39a4a4c2f66 = function(t, e) {
    const r = String(e), i = go(r, W.__wbindgen_malloc, W.__wbindgen_realloc), s = Qt;
    De().setInt32(t + 4 * 1, s, !0), De().setInt32(t + 4 * 0, i, !0);
  }, n.wbg.__wbg_buffer_61b7ce01341d7f88 = function(t) {
    return t.buffer;
  }, n.wbg.__wbg_call_500db948e69c7330 = function() {
    return mi(function(t, e, r) {
      return t.call(e, r);
    }, arguments);
  }, n.wbg.__wbg_call_b0d8e36992d9900d = function() {
    return mi(function(t, e) {
      return t.call(e);
    }, arguments);
  }, n.wbg.__wbg_crypto_ed58b8e10a292839 = function(t) {
    return t.crypto;
  }, n.wbg.__wbg_done_f22c1561fa919baa = function(t) {
    return t.done;
  }, n.wbg.__wbg_error_7534b8e9a36f1ab4 = function(t, e) {
    let r, i;
    try {
      r = t, i = e, console.error(La(t, e));
    } finally {
      W.__wbindgen_free(r, i, 1);
    }
  }, n.wbg.__wbg_getRandomValues_bcb4912f16000dc4 = function() {
    return mi(function(t, e) {
      t.getRandomValues(e);
    }, arguments);
  }, n.wbg.__wbg_get_9aa3dff3f0266054 = function(t, e) {
    return t[e >>> 0];
  }, n.wbg.__wbg_get_bbccf8970793c087 = function() {
    return mi(function(t, e) {
      return Reflect.get(t, e);
    }, arguments);
  }, n.wbg.__wbg_getwithrefkey_1dc361bd10053bfe = function(t, e) {
    return t[e];
  }, n.wbg.__wbg_instanceof_ArrayBuffer_670ddde44cdb2602 = function(t) {
    let e;
    try {
      e = t instanceof ArrayBuffer;
    } catch {
      e = !1;
    }
    return e;
  }, n.wbg.__wbg_instanceof_Uint8Array_28af5bc19d6acad8 = function(t) {
    let e;
    try {
      e = t instanceof Uint8Array;
    } catch {
      e = !1;
    }
    return e;
  }, n.wbg.__wbg_isArray_1ba11a930108ec51 = function(t) {
    return Array.isArray(t);
  }, n.wbg.__wbg_isSafeInteger_12f5549b2fca23f4 = function(t) {
    return Number.isSafeInteger(t);
  }, n.wbg.__wbg_iterator_23604bb983791576 = function() {
    return Symbol.iterator;
  }, n.wbg.__wbg_length_65d1cd11729ced11 = function(t) {
    return t.length;
  }, n.wbg.__wbg_length_d65cf0786bfc5739 = function(t) {
    return t.length;
  }, n.wbg.__wbg_msCrypto_0a36e2ec3a343d26 = function(t) {
    return t.msCrypto;
  }, n.wbg.__wbg_new_3ff5b33b1ce712df = function(t) {
    return new Uint8Array(t);
  }, n.wbg.__wbg_new_8a6f238a6ece86ea = function() {
    return new Error();
  }, n.wbg.__wbg_newnoargs_fd9e4bf8be2bc16d = function(t, e) {
    return new Function(La(t, e));
  }, n.wbg.__wbg_newwithbyteoffsetandlength_ba35896968751d91 = function(t, e, r) {
    return new Uint8Array(t, e >>> 0, r >>> 0);
  }, n.wbg.__wbg_newwithlength_34ce8f1051e74449 = function(t) {
    return new Uint8Array(t >>> 0);
  }, n.wbg.__wbg_next_01dd9234a5bf6d05 = function() {
    return mi(function(t) {
      return t.next();
    }, arguments);
  }, n.wbg.__wbg_next_137428deb98342b0 = function(t) {
    return t.next;
  }, n.wbg.__wbg_node_02999533c4ea02e3 = function(t) {
    return t.node;
  }, n.wbg.__wbg_process_5c1d670bc53614b8 = function(t) {
    return t.process;
  }, n.wbg.__wbg_randomFillSync_ab2cfe79ebbf2740 = function() {
    return mi(function(t, e) {
      t.randomFillSync(e);
    }, arguments);
  }, n.wbg.__wbg_reencryptionresponse_unwrap = function(t) {
    return lh.__unwrap(t);
  }, n.wbg.__wbg_require_79b1e9274cde3c87 = function() {
    return mi(function() {
      return module.require;
    }, arguments);
  }, n.wbg.__wbg_set_23d69db4e5c66a6e = function(t, e, r) {
    t.set(e, r >>> 0);
  }, n.wbg.__wbg_stack_0ed75d68575b0f3c = function(t, e) {
    const r = e.stack, i = go(r, W.__wbindgen_malloc, W.__wbindgen_realloc), s = Qt;
    De().setInt32(t + 4 * 1, s, !0), De().setInt32(t + 4 * 0, i, !0);
  }, n.wbg.__wbg_static_accessor_GLOBAL_0be7472e492ad3e3 = function() {
    const t = typeof N_ > "u" ? null : N_;
    return Qn(t) ? 0 : yo(t);
  }, n.wbg.__wbg_static_accessor_GLOBAL_THIS_1a6eb482d12c9bfb = function() {
    const t = typeof globalThis > "u" ? null : globalThis;
    return Qn(t) ? 0 : yo(t);
  }, n.wbg.__wbg_static_accessor_SELF_1dc398a895c82351 = function() {
    const t = typeof self > "u" ? null : self;
    return Qn(t) ? 0 : yo(t);
  }, n.wbg.__wbg_static_accessor_WINDOW_ae1c80c7eea8d64a = function() {
    const t = typeof window > "u" ? null : window;
    return Qn(t) ? 0 : yo(t);
  }, n.wbg.__wbg_subarray_46adeb9b86949d12 = function(t, e, r) {
    return t.subarray(e >>> 0, r >>> 0);
  }, n.wbg.__wbg_typedciphertext_new = function(t) {
    return hc.__wrap(t);
  }, n.wbg.__wbg_typedciphertext_unwrap = function(t) {
    return hc.__unwrap(t);
  }, n.wbg.__wbg_typedplaintext_new = function(t) {
    return uh.__wrap(t);
  }, n.wbg.__wbg_typedsigncryptedciphertext_new = function(t) {
    return pc.__wrap(t);
  }, n.wbg.__wbg_typedsigncryptedciphertext_unwrap = function(t) {
    return pc.__unwrap(t);
  }, n.wbg.__wbg_value_4c32fd138a88eee2 = function(t) {
    return t.value;
  }, n.wbg.__wbg_versions_c71aa1626a93e0a1 = function(t) {
    return t.versions;
  }, n.wbg.__wbindgen_as_number = function(t) {
    return +t;
  }, n.wbg.__wbindgen_boolean_get = function(t) {
    const e = t;
    return typeof e == "boolean" ? e ? 1 : 0 : 2;
  }, n.wbg.__wbindgen_debug_string = function(t, e) {
    const r = xf(e), i = go(r, W.__wbindgen_malloc, W.__wbindgen_realloc), s = Qt;
    De().setInt32(t + 4 * 1, s, !0), De().setInt32(t + 4 * 0, i, !0);
  }, n.wbg.__wbindgen_error_new = function(t, e) {
    return new Error(La(t, e));
  }, n.wbg.__wbindgen_in = function(t, e) {
    return t in e;
  }, n.wbg.__wbindgen_init_externref_table = function() {
    const t = W.__wbindgen_export_4, e = t.grow(4);
    t.set(0, void 0), t.set(e + 0, void 0), t.set(e + 1, null), t.set(e + 2, !0), t.set(e + 3, !1);
  }, n.wbg.__wbindgen_is_function = function(t) {
    return typeof t == "function";
  }, n.wbg.__wbindgen_is_null = function(t) {
    return t === null;
  }, n.wbg.__wbindgen_is_object = function(t) {
    const e = t;
    return typeof e == "object" && e !== null;
  }, n.wbg.__wbindgen_is_string = function(t) {
    return typeof t == "string";
  }, n.wbg.__wbindgen_is_undefined = function(t) {
    return t === void 0;
  }, n.wbg.__wbindgen_jsval_loose_eq = function(t, e) {
    return t == e;
  }, n.wbg.__wbindgen_memory = function() {
    return W.memory;
  }, n.wbg.__wbindgen_number_get = function(t, e) {
    const r = e, i = typeof r == "number" ? r : void 0;
    De().setFloat64(t + 8 * 1, Qn(i) ? 0 : i, !0), De().setInt32(t + 4 * 0, !Qn(i), !0);
  }, n.wbg.__wbindgen_string_get = function(t, e) {
    const r = e, i = typeof r == "string" ? r : void 0;
    var s = Qn(i) ? 0 : go(i, W.__wbindgen_malloc, W.__wbindgen_realloc), a = Qt;
    De().setInt32(t + 4 * 1, a, !0), De().setInt32(t + 4 * 0, s, !0);
  }, n.wbg.__wbindgen_string_new = function(t, e) {
    return La(t, e);
  }, n.wbg.__wbindgen_throw = function(t, e) {
    throw new Error(La(t, e));
  }, n;
}
function ov(n, t) {
  return W = n.exports, Xy.__wbindgen_wasm_module = t, Ei = null, $a = null, W.__wbindgen_start(), W;
}
async function Xy(n) {
  if (W !== void 0) return W;
  typeof n < "u" && (Object.getPrototypeOf(n) === Object.prototype ? { module_or_path: n } = n : console.warn("using deprecated parameters for the initialization function; pass a single object instead")), typeof n > "u" && (n = new URL(
    /* @vite-ignore */
    "/kms_lib_bg.wasm",
    import.meta.url
  ));
  const t = sv();
  (typeof n == "string" || typeof Request == "function" && n instanceof Request || typeof URL == "function" && n instanceof URL) && (n = fetch(n));
  const { instance: e, module: r } = await iv(await n, t);
  return ov(e, r);
}
const av = (n, t, e) => (r, i, s, a, c) => {
  if (c && !Tn(c))
    throw new Error("Invalid delegated account.");
  if (!Tn(t))
    throw new Error("Invalid verifying contract address.");
  if (!i.every((b) => Tn(b)))
    throw new Error("Invalid contract address.");
  const _ = typeof r == "string" ? r.startsWith("0x") ? r : `0x${r}` : r, p = typeof s == "number" ? s.toString() : s, f = typeof a == "number" ? a.toString() : a, d = [
    { name: "name", type: "string" },
    { name: "version", type: "string" },
    { name: "chainId", type: "uint256" },
    { name: "verifyingContract", type: "address" }
  ], y = {
    name: "DecryptionManager",
    version: "1",
    chainId: n,
    verifyingContract: t
  };
  return c ? {
    types: {
      EIP712Domain: d,
      DelegatedUserDecryptRequestVerification: [
        { name: "publicKey", type: "bytes" },
        { name: "contractAddresses", type: "address[]" },
        { name: "contractsChainId", type: "uint256" },
        { name: "startTimestamp", type: "uint256" },
        { name: "durationDays", type: "uint256" },
        {
          name: "delegatedAccount",
          type: "address"
        }
      ]
    },
    primaryType: "DelegatedUserDecryptRequestVerification",
    domain: y,
    message: {
      publicKey: _,
      contractAddresses: i,
      contractsChainId: e,
      startTimestamp: p,
      durationDays: f,
      delegatedAccount: c
    }
  } : {
    types: {
      EIP712Domain: d,
      UserDecryptRequestVerification: [
        { name: "publicKey", type: "bytes" },
        { name: "contractAddresses", type: "address[]" },
        { name: "contractsChainId", type: "uint256" },
        { name: "startTimestamp", type: "uint256" },
        { name: "durationDays", type: "uint256" }
      ]
    },
    primaryType: "UserDecryptRequestVerification",
    domain: y,
    message: {
      publicKey: _,
      contractAddresses: i,
      contractsChainId: e,
      startTimestamp: p,
      durationDays: f
    }
  };
}, cv = () => {
  const n = $P();
  return {
    publicKey: Mf(ZP(qP(n))),
    privateKey: Mf(XP(n))
  };
}, _v = [
  "function persistAllowed(uint256 handle, address account) view returns (bool)"
], lv = (n, t, e, r, i, s, a) => async (c, _, p, f, d, y, b, v) => {
  console.log("gatewayChainId", t), console.log("chainId", e), console.log("verifyingContractAddress", r);
  const R = new _s(i, _v, a), M = c.map(async ({ ctHandle: V, contractAddress: nt }) => {
    const ft = await R.persistAllowed(V, y), pt = await R.persistAllowed(V, nt);
    if (!ft)
      throw new Error("User is not authorized to reencrypt this handle!");
    if (!pt)
      throw new Error("dApp contract is not authorized to reencrypt this handle!");
    if (y === nt)
      throw new Error("userAddress should not be equal to contractAddress when requesting reencryption!");
  });
  Promise.all(M).catch((V) => {
    throw V;
  });
  const A = {
    ctHandleContractPairs: c.map((V) => ({
      ctHandle: V.ctHandle.toString(16).padStart(64, "0"),
      contractAddress: V.contractAddress
    })),
    requestValidity: {
      startTimestamp: b.toString(),
      // Convert to string
      durationDays: v.toString()
      // Convert to string
    },
    contractsChainId: e.toString(),
    // Convert to string
    contractAddresses: d.map((V) => zt(V)),
    userAddress: zt(y),
    signature: f.replace(/^(0x)/, ""),
    publicKey: p.replace(/^(0x)/, "")
  }, B = {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify(A)
  };
  let N, G;
  try {
    N = tv(gn(p)), G = ev(gn(_));
  } catch (V) {
    throw new Error("Invalid public or private key", { cause: V });
  }
  let D, $;
  try {
    if (D = await fetch(`${s}user-decrypt`, B), !D.ok)
      throw new Error(`Reencrypt failed: relayer respond with HTTP code ${D.status}`);
  } catch (V) {
    throw new Error("Reencrypt failed: Relayer didn't respond", { cause: V });
  }
  try {
    $ = await D.json();
  } catch (V) {
    throw new Error("Reencrypt failed: Relayer didn't return a JSON", {
      cause: V
    });
  }
  if ($.status === "failure")
    throw new Error("Reencrypt failed: the reencryption didn't succeed for an unknown reason", { cause: $ });
  const X = JP(n, y, "default");
  try {
    const V = new ArrayBuffer(32);
    new DataView(V).setUint32(28, t, !1);
    const pt = {
      name: "DecryptionManager",
      version: "1",
      chain_id: new Uint8Array(V),
      verifying_contract: r,
      salt: null
    }, At = {
      signature: f,
      client_address: y,
      enc_key: p,
      ciphertext_handles: c.map((kt) => kt.ctHandle.toString(16).padStart(64, "0")),
      eip712_verifying_contract: r
    };
    return rv(X, At, pt, $.response, N, G, !0).map((kt) => h_(kt.bytes));
  } catch (V) {
    throw new Error("An error occured during decryption", { cause: V });
  }
}, uv = (n, t, e, r, i, s, a) => async (c) => {
  const _ = {
    ciphertext_handle: c.toString(16).padStart(64, "0")
  }, p = {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify(_)
  };
  let f, d;
  try {
    if (f = await fetch(`${s}publicDecrypt`, p), !f.ok)
      throw new Error(`Reencrypt failed: relayer respond with HTTP code ${f.status}`);
  } catch (y) {
    throw new Error("Public decrypt failed: Relayer didn't respond", {
      cause: y
    });
  }
  try {
    d = await f.json();
  } catch (y) {
    throw new Error("Public decrypt failed: Relayer didn't return a JSON", {
      cause: y
    });
  }
  if (d.status === "failure")
    throw new Error("Public decrypt failed: the public decrypt didn't succeed for an unknown reason", { cause: d });
  return d;
};
ba.fetch = hP(ba.fetch, { retries: 5, retryDelay: 500 });
const wv = async (n) => {
  const { publicKey: t, kmsContractAddress: e, verifyingContractAddress: r, aclContractAddress: i, gatewayChainId: s } = n;
  if (!e || !Tn(e))
    throw new Error("KMS contract address is not valid or empty");
  if (!r || !Tn(r))
    throw new Error("Verifying contract address is not valid or empty");
  if (!i || !Tn(i))
    throw new Error("ACL contract address is not valid or empty");
  if (t && !(t.data instanceof Uint8Array))
    throw new Error("publicKey must be a Uint8Array");
  const a = GP(n);
  if (!a)
    throw new Error("No network has been provided!");
  const c = await LP(a, n), _ = await DP(n), p = await KP(n), f = await VP(a, n), d = lv(f, s, c, r, i, Za(n.relayerUrl), a), y = uv(f, s, c, r, i, Za(n.relayerUrl));
  return {
    createEncryptedInput: QP(i, c, Za(n.relayerUrl), _.publicKey, p),
    generateKeypair: cv,
    createEIP712: av(s, r, c),
    publicDecrypt: y,
    userDecrypt: d,
    getPublicKey: () => _.publicKey ? {
      publicKey: _.publicKey.safe_serialize(ch),
      publicKeyId: _.publicKeyId
    } : null,
    getPublicParams: (b) => p[b] ? {
      publicParams: p[b].publicParams.safe_serialize(_h),
      publicParamsId: p[b].publicParamsId
    } : null
  };
};
let Jw = !1;
const gv = async ({ tfheParams: n, kmsParams: t, thread: e } = {}) => (e == null && (e = navigator.hardwareConcurrency), await pP() || (console.warn(`This browser does not support threads. Verify that your server returns correct headers:
`, `'Cross-Origin-Opener-Policy': 'same-origin'
`, "'Cross-Origin-Embedder-Policy': 'require-corp'"), e = void 0), Jw || (await ul({ module_or_path: n }), await Xy({
  module_or_path: t
}), e && (Vy(), await jy(e)), Jw = !0), !0);
export {
  av as createEIP712,
  wv as createInstance,
  cv as generateKeypair,
  gv as initHTTPZ
};
